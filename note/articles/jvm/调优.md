# JVM 调优

- 目录
    - [内存区域优化](#内存区域优化)
        - [显式指定堆内存](#显式指定堆内存)
        - [显式指定新生代内存](#显式指定新生代内存)
        - [显示指定永久代/元空间的大小](#显示指定永久代/元空间的大小)
        - [平衡新生代和老年代](#平衡新生代和老年代)
        - [调整线程堆栈大小](#调整线程堆栈大小)
    - [GC 优化](#GC-优化)  

本文从内存区域和 GC 两个角度，分析 JVM 调优

### 内存区域优化

#### 显式指定堆内存

与性能有关的最常见实践之一是根据应用程序要求初始化堆内存。如果我们需要指定最小和最大堆大小（推荐显示指定大小），以下参数可以帮助你实现：

```C
-Xms<heap size>[unit] 
-Xmx<heap size>[unit]
```

- heap size 表示要初始化内存的具体大小。
- unit 表示要初始化内存的单位。单位为 g(GB) 、m（MB）、k（KB）。

注意：为了防止垃圾收集器在最小、最大之间收缩堆而产生额外的时间，通常把最大、最小设置为相同的值,即：

```C
-Xms2G -Xmx2G
```

#### 显式指定新生代内存

在堆总可用内存配置完成之后，第二大影响因素是为 `Young Generation` （新生代内存）在堆内存所占的比例。

一共有两种指定 新生代内存大小的方法：

1. 通过 -XX:NewSize 和 -XX:MaxNewSize 指定

```C
-XX:NewSize=<young size>[unit] 
-XX:MaxNewSize=<young size>[unit]
```

2. 通过 -Xmn<young size>[unit] 指定

```C
-Xmn256M 
```

#### 显示指定永久代/元空间的大小

JDK 1.8 之前永久代还没被彻底移除的时候通常通过下面这些参数来调节方法区大小：

```C
-XX:PermSize=<perm size>[unit] //方法区 (永久代) 初始大小
-XX:MaxPermSize=<perm size>[unit] //方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGen
```

这个区域垃圾收集行为相对而言出现的比较少，但并非数据进入方法区后就 "永久存在" 了。

JDK 1.8 开始，方法区（HotSpot 的永久代）被彻底移除了（JDK 1.7 就已经开始了），取而代之是元空间，元空间使用的是本地内存。
如果我们没有指定 Metaspace 的大小，随着更多类的创建，虚拟机会耗尽所有可用的系统内存（永久代并不会出现这种情况）。

```C
-XX:MetaspaceSize=<metaspace size>[unit] //设置 Metaspace 的初始（和最小大小）
-XX:MaxMetaspaceSize=<metaspace size>[unit] //设置 Metaspace 的最大大小，如果不指定大小的话，随着更多类的创建，虚拟机会耗尽所有可用的系统内存。
```

#### 平衡新生代和老年代

GC 调优策略中很重要的一条经验总结是这样说的：

> 将新对象预留在新生代，由于 Full GC 的成本远高于 Minor GC，因此尽可能将对象分配在新生代是明智的做法，实际项目中根据 GC 日志分析新生代空间大小分配是否合理，适当通过“-Xmn”命令调节新生代大小，最大限度降低新对象直接进入老年代的情况。

另外，你还可以通过 `-XX:NewRatio=<int>` 来设置新生代和老年代内存的比值。比如下面的参数就是设置新生代（包括 Eden 和两个 Survivor 区）与老年代的比值为 1。也就是说：新生代与老年代所占比值为 1：1，新生代占整个堆栈的 1/2。

```C
-XX:NewRatio=1
```

更大的年轻代必然导致更小的年老代，大的年轻代会延长普通 GC 的周期，但会增加每次 GC 的时间；小的年老代会导致更频繁的 Full GC；
更小的年轻代必然导致更大年老代，小的年轻代会导致普通 GC 很频繁，但每次的 GC 时间会更短；大的年老代会减少 Full GC 的频率。

如何选择应该依赖应用程序对象生命周期的分布情况：如果应用存在大量的临时对象，应该选择更大的年轻代；如果存在相对较多的持久对象，年老代应该适当增大。但很多应用都没有这样明显的特性。

在抉择时应该根据以下两点：

- 本着 Full GC 尽量少的原则，让年老代尽量缓存常用对象，JVM 的年轻代和年老代默认比例 1：2 也是这个道理。
- 通过观察应用一段时间，看其他在峰值时年老代会占多少内存，在不影响Full GC的前提下，根据实际情况加大年轻代，比如可以把比例控制在 1：1。但应该给年老代至少预留1/3的增长空间。

#### 调整线程堆栈大小

每个线程默认会开启 1M 的堆栈，用于存放栈帧、调用参数、局部变量等，对大多数应用而言这个默认值太了，一般 256K 就足用。如果留给私有线程的内存空间有限，每个线程默认大小越大，最大线程数就越小。

实际上，影响线程数的因素还有操作系统，一般操作系统都存在最大线程数。

### GC 优化
