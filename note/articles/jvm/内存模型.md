# 内存模型

- 目录
    - [现代计算机内存模型](#现代计算机内存模型)
    - [Java 内存模型](#Java-内存模型)
        - [内存间交互协议](#内存间交互协议)
        - [线程安全](#线程安全)
            - [synchronized 和 volatile](#synchronized-和-volatile)
        - [有序性](#有序性)

Java 内存模型（又称 JMM）是用来屏蔽硬件和操作系统的内存访问差异的逻辑模型。

### 现代计算机内存模型

在了解 Java 内存模型之前，我们先了解一下现代计算机的内存模型。计算机执行运算任务往往需要处理器和存储设备交互进行，但处理器的运算速度和存储设备的读写速度有着几个数量级的差距，
现代计算机系统一般加一层或多层高速缓存来作为处理器和内存之间的缓冲：将运算所需要使用的数据复制到缓存中，让运算能快速运行，当运算结束后再从缓存同步到内存中。

基于高速缓存的存储交互很好地缓解了处理器的运算速度和存储设备的读写速度之间的矛盾，但是这也为计算机系统带来了更高的复杂度。
它引入了一个新的问题：缓存一致性。在多路处理器系统中，每个处理器都有字节的高速缓存。而它们又共享同一主存，这种系统称为共享内存多核系统。
多个处理器的运算任务都涉及同一块主存区域，可以导致它们之间的缓存数据不一致，为了解决缓存一致性问题，各个处理器访问缓存时候要遵循缓存一致性协议。

<div align="left">
    <img src="https://github.com/lazecoding/Note/blob/main/images/jvm/现代计算机内存模型.png" width="600px">
</div>

除了增加高速缓存，为了更充分利用处理器内部的运算单元，处理器可能会对输入代码进行乱序执行优化，处理器会在计算结束后将乱序执行的结果重组，保证结果与顺序执行的效果一致。
与处理器的乱序执行优化类似，Java 虚拟机的即时编译器中也有指令重排序优化。

### Java 内存模型

Java 内存模型的主要目的是定义程序中各种变量的访问规则，即关注虚拟机把变量值存储到内存和从内存中取出变量值的过程。
Java 内存模型规定了所有的变量（非私有，因为私有变量不存在线程竞争问题）都存储在主内存中，每条线程还有私有的工作线程，工作线程中保存了该线程使用的变量的副本，线程对变量的所有操作都必须在工作内存中完成，不可直接读写主内存。
不同线程之间无法直接访问对方工作内存中的变量，线程间变量值传递必须通过主内存来完成。

<div align="left">
    <img src="https://github.com/lazecoding/Note/blob/main/images/jvm/Java内存模型.png" width="600px">
</div>

注意：Java 内存模型中讲的主内存、工作内存和Java 内存区域中堆、栈等概念不是一个层次的内存划分。

#### 内存间交互协议

关于主内存与工作内存之间的具体交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步到主内存之间的实现细节，Java内存模型定义了以下八种操作来完成：

- lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占状态。
- unlock（解锁）：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。
- read（读取）：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的 load 动作使用。
- load（载入）：作用于工作内存的变量，它把 read 操作从主内存中得到的变量值放入工作内存的变量副本中。
- use（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。
- assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。
- store（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。
- write（写入）：作用于主内存的变量，它把 store 操作从工作内存中一个变量的值传送到主内存的变量中。

<div align="left">
    <img src="https://github.com/lazecoding/Note/blob/main/images/jvm/内存间交互操作.png" width="600px">
</div>

Java 内存模型还规定了在执行上述八种基本操作时，必须满足如下规则：

- 如果要把一个变量从主内存中复制到工作内存，就需要按顺序地执行 read 和 load 操作，如果把变量从工作内存中同步回主内存中，就要按顺序地执行 store 和 write 操作。但 Java 内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。
- 不允许 read 和 load、store 和 write 操作之一单独出现。
- 不允许一个线程丢弃它的最近 assign 的操作，即变量在工作内存中改变了之后必须同步到主内存中。
- 不允许一个线程无原因地（没有发生过任何 assign 操作）把数据从工作内存同步回主内存中。
- 一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load 或 assign）的变量。即就是对一个变量实施 use 和 store 操作之前，必须先执行过了 assign 和 load 操作。
- 一个变量在同一时刻只允许一条线程对其进行 lock 操作，但 lock 操作可以被同一条线程重复执行多次，多次执行 lock 后，只有执行相同次数的 unlock 操作，变量才会被解锁。lock 和 unlock 必须成对出现。
- 如果对一个变量执行 lock 操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行 load 或 assign 操作初始化变量的值。
- 如果一个变量事先没有被 lock 操作锁定，则不允许对它执行 unlock 操作；也不允许去 unlock 一个被其他线程锁定的变量。
- 对一个变量执行 unlock 操作之前，必须先把此变量同步到主内存中（执行 store 和 write 操作）。

后来 Java 开发团队将 Java 内存模型的操作简化为 read、write、lock 和 unlock 四种，但这只是语言描述上的等价简化，Java 内存模型的基础设计并未改变。

#### 线程安全

Java 内存模型是围绕原子性、可见性和有序性三个特征建立的，要解决的是线程安全问题。如果一个数据具备互斥访问和可见性，就可以说这个数据是线程安全的。

##### synchronized 和 volatile

为了保证线程安全，Java 提供了 synchronized 关键字。synchronized 是基于 "如果对一个变量执行 lock 操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行 load 或 assign 操作初始化变量的值。" 和 "对一个变量执行 unlock 操作之前，必须先把此变量同步到主内存中（执行 store 和 write 操作）。" 这两条原则实现的。synchronized 关键字解决的是执行控制的问题，它会阻止其它线程获取当前对象的监控锁，这样就使得当前对象中被 synchronized 关键字保护的代码块无法被其它线程访问，也就无法并发执行。

Java 还提供了一种更轻量的同步机制 —— volatile 关键字。 当一个变量被定义为 volatile，它将具备两个特性：

- 一是保证此变量对所有线程的可见性，这里的 "可见性" 是指当一条线程修改了这个变量值，新值对于其他线程来说是可以立即得知的。
- 二是禁止指令重排序，被 volatile 关键字修饰的变量会在变量读写前后增加内存屏障，保证变量赋值操作的顺序和程序代码执行顺序一致。
  
volatile 变量在各个线程的工作内存中是不存在一致性问题的，从物理存储的角度看，各个线程的工作内存中 volatile 可以存在不一致情况，但每次使用前都需要刷新，因此可以认为不存在一致性问题。但这并不能得出基于 volatile 变量的运算在并发下是线程安全的，因为 Java 中运算符操作是非原子操作，这就导致了 volatile 变量的运算在并发下一样是不安全的。故此，只有符合下面两个条件才可以使用 volatile 关键字：

- 变量的结果不依赖变量的当前值，或能够确保只有单一线程修改变量值。
- 变量不需要与其他的状态变量共同参与不变约束。

volatile 和 synchronized 的区别:

- volatile 本质是告诉Java虚拟机被修饰变量在工作内存中的值是不确定的，需要从主存中读取；synchronized 则是锁定同步块，只有一个线程可以访问该同步块，其他线程被阻塞住。
- volatile 仅能使用在变量级别；synchronized 则可以使用在变量、方法、和类级别的。
- volatile 仅能保证可见性，不能保证原子性；而 synchronized 可以保证可见性和原子性。
- volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。
- volatile 标记的变量不会被编译器优化；synchronized 标记的变量可以被编译器优化。

#### 有序性

在 Java 内存模型中，允许编译器和处理器对指令进行重排序，重排序不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。我们可以通过 volatile、synchronized、lock 保证有序性。另外，Java 内存模型具有先天的有序性，即不需要通过任何手段就可以得到保证的有序性。这称为 happens-before 原则。如果两个操作的执行次序无法从 happens-before 原则推导出来，那么它们就不能保证它们的有序性。虚拟机可以随意地对它们进行重排序。

happens-before 原则:

- 程序次序规则：在一个单独的线程中，按照程序代码书写的顺序执行。
- 锁定规则：一个 unlock 操作 happen-before 后面对同一个锁的 lock 操作。
- volatile 变量规则：对一个 volatile 变量的写操作 happen-before 后面对该变量的读操作。
- 线程启动规则：Thread 对象的 start() 方法 happen-before 此线程的每一个动作。
- 线程终止规则：线程的所有操作都 happen-before 对此线程的终止检测，可以通过 Thread.join() 方法结束、Thread.isAlive() 的返回值等手段检测到线程已经终止执行。
- 线程中断规则：对线程 interrupt() 方法的调用 happen-before 发生于被中断线程的代码检测到中断时事件的发生。
- 对象终结规则：一个对象的初始化完成（构造函数执行结束）happen-before 它的 finalize() 方法的开始。
- 传递性：如果操作 A happen-before 操作 B，操作 B happen—before 操作 C，那么可以得出 A happen-before 操作 C。