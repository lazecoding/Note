# 内存区域

- 目录
    - [内存区域](#内存区域)
        - [程序计数器](#程序计数器)
        - [虚拟机栈](#虚拟机栈)
        - [本地方法栈](#本地方法栈)
        - [堆](#堆)
        - [方法区](#方法区)
        - [直接内存](#直接内存)
        - [运行时常量池](#运行时常量池)
    - [对象的内存布局](#对象的内存布局)
    - [类加载过程](#类加载过程)
    - [对象的创建](#对象的创建)
    - [对象的访问方式](#对象的访问方式)
    - [引用类型](#引用类型)
    
Java 虚拟机在执行 Java 程序的过程会把它管理的内存划分为若干不同的数据区域，这些区域有各自的用途，以及创建和销毁的时间。

### 内存区域

Java 虚拟机内存区域的划分在 JDK 1.8 前后有所不同。

JDK 1.8 之前：

<div align="left">
    <img src="https://github.com/lazecoding/Note/blob/main/images/jvm/1.8前内存区域.png" width="600px">
</div>

JDK 1.8：

<div align="left">
    <img src="https://github.com/lazecoding/Note/blob/main/images/jvm/1.8起内存区域.png" width="600px">
</div>

#### 程序计数器

程序计数器是当前线程所执行的字节码的行号指示器，线程私有。在虚拟机的概念模型里，字节码解释器通过改变程序计数器的值来选取下一条需要执行的字节码指令。

这个区域是唯一没有规定任何 OutOfMemoryError 异常的区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。

#### 虚拟机栈

Java 虚拟机栈也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是 Java 方法执行的内存模型：每个方法被执行的时候都会同时创建一个用于存储局部变量表、操作栈、动态链接、方法出口等信息的栈帧。每个方法被调用直至执行完成就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。

这个区域规定了两种异常：

- 如果线程请求的栈深度大于虚拟机所允许的栈深度，即创建栈帧时没有内存空间，虚拟机会抛出 StackOverflowError 异常。
- 如果虚拟机栈可以动态扩展，当扩展时无法申请到内存空间虚拟机会抛出 OutOfMemoryError 异常。

#### 本地方法栈

本地方法栈也是线程私有的，与虚拟机栈的作用是相似，不同在于虚拟机栈为虚拟机执行 Java 方法服务，而本地方法栈为虚拟机使用 Native 方法服务。Native 方法并不是用 Java 代码实现的，而是本地库实现的，如 dll 动态链接库文件。

这个区域也会抛出 StackOverflowError 异常和 OutOfMemoryError 异常。

#### 堆

Java 堆是虚拟机中一块线程共享的内存区域，在虚拟机启动时被创建。此内存区域的主要作用是存放对象实例，大部分的对象实例都是在堆中分配内存的。Java 堆是 GC 的主要工作区域，从 GC 分代收集的角度看，堆可以细分为：新生代和老年代。新生代还可以分为 Eden 空间、From Survivor 空间、To Survivor 空间。

Java 堆可以处在物理上不连续的内存空间中，只要逻辑上连续即可。当堆中没有内存可供实例分配，而且堆也无法扩展时虚拟机会抛出 OutOfMemoryError 异常。

#### 方法区

方法区与堆一样，是线程共享的内存区域，用于存储被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。JDK 1.8 之前，方法区是在堆内的，以永久代的方式实现。JDK 1.8 开始 Java 虚拟机在堆外内存开辟元空间，通过元空间实现。

这个区域的数据较为稳定，很少进行垃圾回收，而且垃圾回收的效果也不太明显。当没有内存分配时虚拟机将抛出 OutOfMemoryError 异常。

#### 直接内存

直接内存并不属于虚拟机运行时数据区，但该区域也被频繁使用。直接内存的分配不会收到堆大小的限制，但会受到机器物理内存和操作系统寻址范围的限制，如果动态扩展超出物理内存或寻址范围的限制虚拟机将抛出 OutOfMemoryError 异常。

#### 运行时常量池

运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池表（用于存放编译期生成的各种字面量和符号引用）。

- 在 JDK 1.6 及之前版本，运行时常量池包含字符串常量池存放在方法区, 此时方法区的实现为永久代。
- 在 JDK 1.7 版本中 String#intern() 发生了改变，String Pool 中也可以存放堆内的字符串对象的引用。字符串常量池被剥离出运行时常量池，被存放到堆内存中，运行时常量池依旧存放在方法区中。
- JDK 1.8 版本方法区的实现由永久代转化为元空间，因此运行时常量池存放到了元空间中。

当常量池无法再申请到内存时虚拟机会抛出 OutOfMemoryError 异常。

### 对象的内存布局

在 HotSpot 虚拟机中，对象的内存布局可以划分为 3 个部分：对象头、实例数据、对齐填充。

- 对象头包括两类信息。第一类是对象的运行时数据，如哈希码、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等。另一类是类型指针，即对象指向它的类型元数据的指针。
- 实例数据是对象真正存储的有效信息，即用户在程序代码中定义的内容。
- 对象填充没啥特别意义，就是起占位符作用，因为 HotSpot 要求每个对象的起始地址必须是 8 字节的整数倍。

### 对象的创建

对象的创建过程：类加载检查>分配内存>初始化零值>设置对象头>执行 init 方法。

- 当虚拟机遇到一条字节码 new 指令，首先会根据指令参数获取符号引用，并检查这个符号引用所代表的类是否已被加载。如果没有，就执行类加载过程。
- 当类加载检查通过，虚拟机会为新生对象分配内存，实际上就是为其在堆中分配一块内存空间。
- 当内存分配完成后，虚拟机将分配的内存空间（不包括对象头）初始化为零值。
- 完成上述操作后，虚拟机需要为对象设置对象头。
- 最后执行对象的 <init>() 方法，按照用户意愿初始化对象。

### 对象的访问方式

主流的对象访问方式有两种：句柄和直接指针。

- 句柄：如果使用句柄的话，Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息；
- 直接指针：如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象的地址。

使用句柄的优势在于对象移动只需要改变句柄中指针；使用直接引用的好处在于和句柄访问相比少了一次指针定位的开销，访问速度更快。就 HotSpot 虚拟机而言，主要采用直接指针的方式访问对象。

### 引用类型

Java 中存在 4 种引用：强引用、软引用 、弱引用、虚引用。
- 强引用是最常用的一种引用，如 new 创建的对象就属于强引用。只要强引用关系存在，对象就不会被回收。
- 软引用是由 java.lang.ref.SoftReference 提供的功能，只有虚拟机内存不足时才会回收该对象。很多人说可以当缓存，但如果不是单机架构就不太可行。
- 弱引用是由 java.lang.ref.WeakReference 提供的功能，只要发生 GC 对象就会被回收。
- 虚引用是由 java.lang.ref.PhantomReference 提供的功能，用户无法通过虚引用来获取对一个对象的真实引用，虚引用需要结合引用队列使用，当其所引用对象被回收时会自动加入到引用队列中。也就是说你可以通过虚引用得到哪些内存已被回收，在 NIO 中，就利用虚引用管理堆外内存。