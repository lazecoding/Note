# 内存区域

Java 虚拟机在执行 Java 程序的过程会把它管理的内存划分为若干不同的数据区域，这些区域有各自的用途，以及创建和销毁的时间。

### 内存区域

Java 虚拟机内存区域的划分在 JDK 1.8 前后有所不同。

JDK 1.8 之前：

<div align="left">
    <img src="https://github.com/lazecoding/Note/blob/main/images/jvm/1.8前内存区域.png" width="600px">
</div>

JDK 1.8：

<div align="left">
    <img src="https://github.com/lazecoding/Note/blob/main/images/jvm/1.8起内存区域.png" width="600px">
</div>

#### 程序计数器

程序计数器是当前线程所执行的字节码的行号指示器，线程私有。在虚拟机的概念模型里，字节码解释器通过改变程序计数器的值来选取下一条需要执行的字节码指令。

这个区域是唯一没有规定任何 OutOfMemoryError 异常的区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。

#### 虚拟机栈

Java 虚拟机栈也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是 Java 方法执行的内存模型：每个方法被执行的时候都会同时创建一个用于存储局部变量表、操作栈、动态链接、方法出口等信息的栈帧。每个方法被调用直至执行完成就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。

这个区域规定了两种异常：
- 如果线程请求的栈深度大于虚拟机所允许的栈深度，即创建栈帧时没有内存空间，虚拟机会抛出 StackOverflowError 异常。
- 如果虚拟机栈可以动态扩展，当扩展时无法申请到内存空间虚拟机会抛出 OutOfMemoryError 异常。

#### 本地方法栈

本地方法栈也是线程私有的，与虚拟机栈的作用是相似，不同在于虚拟机栈为虚拟机执行 Java 方法服务，而本地方法栈为虚拟机使用 Native 方法服务。Native 方法并不是用 Java 代码实现的，而是本地库实现的，如 dll 动态链接库文件。

这个区域也会抛出 StackOverflowError 异常和 OutOfMemoryError 异常。

#### 堆

Java 堆是虚拟机中一块线程共享的内存区域，在虚拟机启动时被创建。此内存区域的主要作用是存放对象实例，大部分的对象实例都是在堆中分配内存的。Java 堆是 GC 的主要工作区域，从 GC 分代收集的角度看，堆可以细分为：新生代和老年代。新生代还可以分为 Eden 空间、From Survivor 空间、To Survivor 空间。

Java 堆可以处在物理上不连续的内存空间中，只要逻辑上连续即可。当堆中没有内存可供实例分配，而且堆也无法扩展时虚拟机会抛出 OutOfMemoryError 异常。

#### 方法区

方法区与堆一样，是线程共享的内存区域，用于存储被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。JDK 1.8 之前，方法区是在堆内的，以永久代的方式实现。JDK 1.8 开始 Java 虚拟机在堆外内存开辟元空间，通过元空间实现。

这个区域的数据较为稳定，很少进行垃圾回收，而且垃圾回收的效果也不太明显。当没有内存分配时虚拟机将抛出 OutOfMemoryError 异常。

#### 直接内存

直接内存并不属于虚拟机运行时数据区，但该区域也被频繁使用。直接内存的分配不会收到堆大小的限制，但会受到机器物理内存和操作系统寻址范围的限制，如果动态扩展超出物理内存或寻址范围的限制虚拟机将抛出 OutOfMemoryError 异常。

#### 运行时常量池

运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池表（用于存放编译期生成的各种字面量和符号引用）。

- 在 JDK 1.6 及之前版本，运行时常量池包含字符串常量池存放在方法区, 此时方法区的实现为永久代。
- 在 JDK 1.7 版本中 String#intern() 发生了改变，String Pool 中也可以存放堆内的字符串对象的引用。字符串常量池被剥离出运行时常量池，被存放到堆内存中，运行时常量池依旧存放在方法区中。
- JDK 1.8 版本方法区的实现由永久代转化为元空间，因此运行时常量池存放到了元空间中。

当常量池无法再申请到内存时虚拟机会抛出 OutOfMemoryError 异常。

### 对象的创建