# 执行引擎

- 目录
  - [字节码执行引擎](#字节码执行引擎)
  - [运行时栈帧](#运行时栈帧)
    - [局部变量表](#局部变量表)
    - [操作数栈](#操作数栈)
    - [动态连接](#动态连接)
    - [方法返回地址](#方法返回地址)
    - [附加信息](#附加信息)
  - [编译执行和解释执行](#编译执行和解释执行)
    - [基于栈的字节码解释执行引擎](#基于栈的字节码解释执行引擎)
    - [基于栈的指令集与基于寄存器的指令集](#基于栈的指令集与基于寄存器的指令集)

执行引擎是 Java 虚拟机的三个核心子系统之一。（本文仅讲解概念模型，具体的虚拟机实现还存在各自优化）

### 字节码执行引擎

虚拟机是相对于物理机的概念，它们都有代码执行能力，区别在于物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上的，而虚拟机的执行引擎是由软件实现的，因此虚拟机的执行引擎可以摆脱物理条件制约，定制指令集与执行引擎的结构体系，能够执行那些不被硬件直接支持的指令集格式。

Java 虚拟机将字节码装载到运行空间，但字节码无法够直接运行在操作系统之上，因为字节码指令不等价于本地机器指令，它内部包含的仅仅只是一些能够被 Java 虚拟机识别的字节码指令、符号表和其他辅助信息。执行引擎的任务就是将字节码指令编译/解释为对应平台上的本地机器指令，简单来说，Java 虚拟机中的执行引擎是将高级语言翻译为机器语言的译者。它的输入是字节码二进制流，处理过程是字节码解析执行的等效过程，输出的是执行结果，所以Java 虚拟机的执行引擎是字节码执行引擎。

### 运行时栈帧

Java 虚拟机以方法作为最基本的执行单元，"栈帧" 是虚拟机进行方法调用和方法执行背后的数据结构。

栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息。每一个方法从调用开始至执行结束的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。

<div align="left">
    <img src="https://github.com/lazecoding/Note/blob/main/images/jvm/栈帧结构.png" width="600px">
</div>

#### 局部变量表

局部变量表是用于存放方法参数和方法内部定义的局部变量的数组。局部变量表的容量以变量槽（Variable Slot）为最小单位，Java 虚拟机规范没有明确指出一个变量槽应占用的内存空间大小，只是要求每个变量槽都应该可以存放 boolean、 byte、char、short、int、float、reference 或 returnAddress 这 8 种数据类型。
由于局部变量表是建立在虚拟机栈中，线程私有，所以无论读写两个连续的变量槽是否为原子操作，都不会引起数据竞争和线程安全问题。

#### 操作数栈

操作数栈也被称为操作栈，它是一个先入后出的栈。Java 虚拟机的解释执行引擎被称为 "基于栈的执行引擎"，这里的“栈”指的就是操作数栈 。当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈和入栈操作。

另外在概念模型中，两个不同栈帧作为不同方法的栈元素，是相互独立的。但是在大多虚拟机的实现里都会进行一些优化处理，让两个栈帧出现一部分重叠。让下面栈帧的部分操作数栈与上面栈帧的部分局部变量表重叠在一起，这样不仅可以节约空间，更重要的是在进行方法调用时可以直接共用一部分数据，无须进行额外的参数传递。

<div align="left">
    <img src="https://github.com/lazecoding/Note/blob/main/images/jvm/栈帧数据共享.png" width="600px">
</div>

#### 动态连接

每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。Class 文件的常量池中存有大量的符号引用，字节码中方法调用指令就以常量池里指向方法的符号引用作为参数。这些符号引用一部分会在类加载阶段或者第一次使用的时候就被转化为直接引用，这种转化被称为静态解析。另外一部分将在每一次运行期间都转化为直接引用，这部分就称为动态连接。

#### 方法返回地址

当一个方法开始执行后，只有两种方式退出这个方法：

- 执行引擎遇到任意一个方法返回的字节码指令会向上层的方法调用者传递返回值。
- 方法执行的过程中遇到了异常，并且这个异常没有在方法体内得到妥善处理，导致非正常退出，不会上层调用者提供任何返回值。

无论采用哪种方式，方法退出之后都必须返回到最初方法被调用时的位置，程序才能继续执行。一般来说，方法正常退出时，主调方法的 PC 计数器的值就可以作为返回地址，栈帧中很可能会保存这个计数器值。而方法异常退出时，返回地址是要通过异常处理器表来确定的，栈帧中就一般不会保存这部分信息。方法退出的过程实际上等同于把当前栈帧出栈，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值（如果有的话）压入调用者栈帧的操作数栈中，调整 PC 计数器的值以指向方法调用指令后面的一条指令等。

#### 附加信息

Java 虚拟机规范允许虚拟机实现增加一些规范里没有描述的信息到栈帧之中，例如与调试、性能收集相关的信息，这部分信息完全取决于具体的虚拟机实现。

### 编译执行和解释执行

高级语言通常会有三种执行方式：编译执行、解释执行、混合执行。

- 编译执行是将源代码一次性转换为机器语言语言表示的目标程序的过程。程序一次性编译耗时较长，不支持跨平台执行，但是其编译后的可执行文件运行速度快。
- 解释执行是将源代码逐句转换为目标代码的过程，计算机逐句执行，并不产生目标程序。解释型程序可跨平台执行，无需编译，但由于是逐句解释执行，所以运行速度不如编译型程序。
- 混合执行是编译执行和解释执行相结合的执行方式，程序先被编译成字节码文件，然后字节码被解释器解释执行。

#### 基于栈的字节码解释执行引擎

Java 在编译时期将程序源码编译成 Class 文件 ，配合 Java 虚拟机跨平台的抽象，屏蔽底层计算机操作系统和硬件的区别，实现了 "一次编译，到处运行"。运行时期，主流的 Java 虚拟机都是采用混合模式，即解释运行和编译运行配合使用。解释器的优势在于无需等待，编译器则具有更高的运行效率。在 Java 虚拟机运行时，解释器和即时编译器能够相互协作，各自取长补短，从而提高运行效率。

不论是解释执行还是编译执行，高级语言大多遵从现代经典编译原理的思路：在执行前先对程序源码进行词法分析和语法分析，把源码转化为抽象语法树。对于一门具体语言的实现来说，词法分析、语法分析以至后面的优化器和目标代码生成器可以选择独立于执行引擎，形成一个完整意义的编译器去实现，这类代表是 C/C++ 语言。也可以选择把其中一部分步骤（如生成抽象语法树之前的步骤）实现为一个半独立的编译器，这类代表是Java 语言。又或者把这些步骤和执行引擎全部集中封装在一个封闭的黑匣子之中，如大多数的 JavaScript 执行器。

<div align="left">
    <img src="https://github.com/lazecoding/Note/blob/main/images/jvm/编译过程.png" width="600px">
</div>

对于 Java,编译器完成了程序源码经过词法分析、语法分析到抽象语法树,再遍历语法树生成线性的字节码指令流的过程。这一部分动作是在 Java 虚拟机之外进行的, 而解释器在虚拟机的内部,所以说 Java 程序的编译就是半独立的实现。

#### 基于栈的指令集与基于寄存器的指令集

Java 编译器输出的指令流，基本上是一种基于栈的指令集架构，指令流中的指令大部分都是零地址指令，零地址指令只有操作码，而没有地址码，它们依赖操作数栈进行工作。与之对应的另一套常用的指令集架构是基于寄存器的指令集，最典型的就是 x86 的二进制指令集。

寄存器是由硬件直接提供的，程序直接依赖这些硬件寄存器就不可避免地受到硬件的约束。基于栈的指令集的主要优点就是可移植，用户程序不会直接使用这些寄存器，由具体的虚拟机实现自行决定把一些访问最频繁的数据（程序计数器、栈顶缓存等）放到寄存器中以获取尽量好的性能。

基于栈的指令集的主要缺点就是执行速度相对较慢，源于指令数量和内存访问。虽然基于栈的指令集架构的代码比较紧凑，但是完成相同功能所需的指令数量一般会比基于寄存器的指令集架构要多，因为出栈、入栈操作本身就产生了很多的指令数量。更重要的是，栈实现在内存之中，频繁的栈访问也就意味着频繁的内存访问，对于处理器来说（CPU 太快了），内存访问始终是执行速度的瓶颈。