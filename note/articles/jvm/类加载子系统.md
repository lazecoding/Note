# 类加载子系统

- 目录
  - [类文件结构](#类文件结构)
    - [魔数](#魔数)
    - [Class 文件版本](#Class-文件版本)
    - [常量池](#常量池)
    - [访问标志](#访问标志)
    - [类索引、父类索引与接口索引集合](#类索引、父类索引与接口索引集合)
    - [字段表集合](#字段表集合)
    - [方法表集合](#方法表集合)
    - [属性表集合](#属性表集合)
  - [类加载机制](#类加载机制)
    - [类加载过程](#类加载过程)
      - [加载](#加载)
      - [验证](#验证)
      - [准备](#准备)
      - [解析](#解析)
      - [初始化](#初始化)
    - [类加载器](#类加载器)
      - [类与类加载器](#类与类加载器)
      - [双亲委派模型](#双亲委派模型)
      - [破坏双亲委派模型](#破坏双亲委派模型)
      - [全局负责机制](#全局负责机制)
      - [缓存机制](#缓存机制)

代码编译的结果从本地机器码转换为字节码，是存储格式的一小步，却是编程语言的一大步。

类加载子系统负责将 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型。

### 类文件结构

Java 虚拟机不与任何语言绑定，只与 Class 文件这种特定的二进制文件格式关联，Class 文件中包含了虚拟机指令集、符号表以及若干辅助信息。Class 文件是一组以 8 位字节为基础单位的二进制流，当遇到需要 8 位字节以上空间的数据项时，则会按照高位在前的方式分隔成若干个 8 位字节进行存储,不足 8 字节会以空格填充。

Class 采用一种类似 C 语言结构体的伪结构体来存储数据，这种伪结构体只有两种数据：无符号数和表。
- 无符号数：以 u1、u2、u4、u8 分别代表 1 个字节、2 个字节、4 个字节和 8 个字节的无符号数，可以用来描述数字、索引引用、数量值、按照 UTF-8 编码构成的字符串值。
- 表：由多个无符号数或其他表作为数据项构成的复杂数据类型，所有表都习惯性地以 "_info" 结尾。

```C
ClassFile {
    u4             magic;                                 //Class 文件的标志
    u2             minor_version;                         //Class 的小版本号
    u2             major_version;                         //Class 的大版本号
    u2             constant_pool_count;                   //常量池的数量
    cp_info        constant_pool[constant_pool_count-1];  //常量池
    u2             access_flags;                          //Class 的访问标记
    u2             this_class;                            //当前类
    u2             super_class;                           //父类
    u2             interfaces_count;                      //接口
    u2             interfaces[interfaces_count];          //一个类可以实现多个接口
    u2             fields_count;                          //Class 文件的字段属性
    field_info     fields[fields_count];                  //一个类会可以有多个字段
    u2             methods_count;                         //Class 文件的方法数量
    method_info    methods[methods_count];                //一个类可以有个多个方法
    u2             attributes_count;                      //此类的属性表中的属性数
    attribute_info attributes[attributes_count];          //属性表集合
}
```

#### 魔数

```C
    u4             magic;                                 //Class 文件的标志
```

每个 Class 文件的前 4 个字节称为魔数（Magic Number）,它的唯一作用是确定这个文件是否为一个能被虚拟机接收的 Class 文件。

程序设计者很多时候都喜欢用一些特殊的数字表示固定的文件类型或者其它特殊的含义。

#### Class 文件版本

```C
    u2             minor_version;                         //Class 的小版本号
    u2             major_version;                         //Class 的大版本号
```

紧接着魔数的四个字节存储的是 Class 文件的版本号：第 5 个和第 6 个是 `次版本号`，第 7 个和第 8 个是 `主版本号`。

高版本的 Java 虚拟机可以执行低版本编译器生成的 Class 文件，但是低版本的 Java 虚拟机不能执行高版本编译器生成的 Class 文件。所以，我们在实际开发的时候要确保开发的的 JDK 版本和生产环境的 JDK 版本保持一致。

#### 常量池

```C
    u2             constant_pool_count;                   //常量池的数量
    cp_info        constant_pool[constant_pool_count-1];  //常量池
```

版本信息之后就是常量池，常量池中存放两种类型的常量：

- 字面值常量：字面值常量就是我们在程序中定义的字符串和被 final 修饰的值。
- 符号引用：符号引用就是我们定义的各种名字，即类和接口的全限定名、字段的名字和描述符、方法的名字和描述符。



常量池中每一项常量都是一个表，这 14 种表有一个共同的特点：`开始的第一位是一个 u1 类型的标志位 -tag 来标识常量的类型，代表当前这个常量属于哪种常量类型。`

|               类型               | 标志（tag） |          描述          |
| :------------------------------: | :---------: | :--------------------: |
|        CONSTANT_utf8_info        |      1      |   UTF-8编码的字符串    |
|      CONSTANT_Integer_info       |      3      |       整形字面量       |
|       CONSTANT_Float_info        |      4      |      浮点型字面量      |
|        CONSTANT_Long_info        |     ５      |      长整型字面量      |
|       CONSTANT_Double_info       |     ６      |   双精度浮点型字面量   |
|       CONSTANT_Class_info        |     ７      |   类或接口的符号引用   |
|       CONSTANT_String_info       |     ８      |    字符串类型字面量    |
|      CONSTANT_Fieldref_info      |     ９      |     字段的符号引用     |
|     CONSTANT_Methodref_info      |     10      |   类中方法的符号引用   |
| CONSTANT_InterfaceMethodref_info |     11      |  接口中方法的符号引用  |
|    CONSTANT_NameAndType_info     |     12      |  字段或方法的符号引用  |
|     CONSTANT_MothodType_info     |     16      |      标志方法类型      |
|    CONSTANT_MethodHandle_info    |     15      |      表示方法句柄      |
|   CONSTANT_InvokeDynamic_info    |     18      | 表示一个动态方法调用点 |

`.class` 文件可以通过`javap -v class类名` 指令来看一下其常量池中的信息(`javap -v  class类名-> temp.txt` ：将结果输出到 temp.txt 文件)。

#### 访问标志

在常量池结束之后，紧接着的两个字节代表访问标志，这个标志用于识别一些类或者接口层次的访问信息，包括：这个 Class 是类还是接口，是否为 public 或者 abstract 类型，如果是类的话是否声明为 final 等等。

#### 类索引、父类索引与接口索引集合

```C
    u2             this_class;                            //当前类
    u2             super_class;                           //父类
    u2             interfaces_count;                      //接口
    u2             interfaces[interfaces_count];          //一个类可以实现多个接口
```

类索引和父类索引都是一个 u2 类型的数据，而接口索引集合是一组 u2 类型的数据的集合，Class 文件中由这三项数据来确定类的继承关系。类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名。

由于 Java 不允许多重继承，所以父类索引只有一个，除了 java.lang.Object 之外，所有的 Java 类都有父类，因此除了 java.lang.Object 外，所有 Java 类的父类索引都不为 0。一个类可能实现了多个接口，因此用接口索引集合来描述。这个集合第一项为 u2 类型的数据，表示索引表的容量，接下来就是接口的名字索引。

类索引和父类索引用两个 u2 类型的索引值表示，它们各自指向一个类型为 CONSTANT_Class_info 的类描述符常量，通过该常量总的索引值可以找到定义在 CONSTANT_Utf8_info 类型的常量中的全限定名字符串。

#### 字段表集合

```C
    u2             fields_count;                          //Class 文件的字段属性
    field_info     fields[fields_count];                  //一个类会可以有多个字段
```

字段表（field_info）用于描述接口或类中声明的变量。字段包括类级变量以及实例变量，但不包括在方法内部声明的局部变量。每一个字段表只表示一个成员变量，本类中的所有成员变量构成了字段表集合。

字段表结构如下：

| 类型 | 名称             | 数量             | 说明                                                                                                 |
| ---- | ---------------- | ---------------- | ---------------------------------------------------------------------------------------------------- |
| u2   | access_flags     | 1                | 字段的访问标志，与类稍有不同                                                                         |
| u2   | name_index       | 1                | 字段名字的索引                                                                                       |
| u2   | descriptor_index | 1                | 描述符，用于描述字段的数据类型。 基本数据类型用大写字母表示； 对象类型用“L 对象类型的全限定名”表示。 |
| u2   | attributes_count | 1                | 属性表集合的长度                                                                                     |
| u2   | attributes       | attributes_count | 属性表集合，用于存放属性的额外信息，如属性的值。                                                     |

字段表集合中不会出现从父类（或接口）中继承而来的字段，但有可能出现原本 Java 代码中不存在的字段，譬如在内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段。

#### 方法表集合

```C
    u2             methods_count;                         //Class 文件的方法数量
    method_info    methods[methods_count];                //一个类可以有个多个方法
```

Class 文件存储格式中对方法的描述与对字段的描述几乎采用了完全一致的方式。方法表的结构如同字段表一样，依次包括了访问标志、名称索引、描述符索引、属性表集合几项。

注意：因为`volatile`修饰符和`transient`修饰符不可以修饰方法，所以方法表的访问标志中没有这两个对应的标志，但是增加了`synchronized`、`native`、`abstract`等关键字修饰方法，所以也就多了这些关键字对应的标志。

#### 属性表集合

```C
    u2             attributes_count;                      //此类的属性表中的属性数
    attribute_info attributes[attributes_count];          //属性表集合
```

在 Class 文件，字段表，方法表中都可以携带自己的属性表集合，以用于描述某些场景专有的信息。与 Class 文件中其它的数据项目要求的顺序、长度和内容不同，属性表集合的限制稍微宽松一些，不再要求各个属性表具有严格的顺序，并且只要不与已有的属性名重复，任何人实现的编译器都可以向属性表中写 入自己定义的属性信息，Java 虚拟机运行时会忽略掉它不认识的属性。

### 类加载机制

Java 虚拟机把类描述文件（Class 文件）加载到内存，并对数据进行校验、准备、解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这就是 Java 虚拟机的类加载机制。

#### 类加载过程

一个类型从加载到虚拟机内存中开始到卸载出内存为止，它的整个声明周期将会经历加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）七个阶段，其中验证、准备、解析三个阶段合称为连接（Linking）。

<div align="left">
    <img src="https://github.com/lazecoding/Note/blob/main/images/jvm/类的生命周期.png" width="600px">
</div>

类加载过程包括其中 5 个阶段：
- 加载
- 验证
- 准备
- 解析
- 初始化

##### 加载

加载阶段，Java 虚拟机主要做 3 件事情：
- 通过类的全限定名来获取这个类的二进制字节流。
- 将字节流所代表的静态存储结构转换为方法区的运行时数据结构。
- 在内存中创建一个代表该类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口。

对于 Class 文件，虚拟机没有指明要从哪里获取、怎样获取。除了直接从编译好的 .class 文件中读取，还有以下几种方式：
- 从 zip 包中读取，如 jar、war 等。
- 从网络中获取，如 Applet。
- 通过动态代理技术生成代理类的二进制字节流。
- 由 JSP 文件生成对应的 Class 类。
- 从数据库中读取，如有些中间件服务器可以选择把程序安装到数据库中来完成程序代码在集群间的分发。
- ...

虚拟机规范也未规定 Class 对象的存储位置，对于 HotSpot 虚拟机而言，Class 对象比较特殊，虽是对象，但存放在方法区中。

##### 验证

验证是连接阶段的第一步，目的是确保 Class 文件的信息符合 Java 虚拟机约束，保证这些信息不会危害虚拟机自身安全。

验证阶段大致上会完成下面 4 个阶段的检验动作：
- 文件格式验证：验证字节流是否符合 Class 文件格式的规范，并且能被当前版本的虚拟机处理，验证点如下：
    - 是否以魔数 0XCAFEBABE 开头
    - 主次版本号是否在当前虚拟机处理范围内
    - 常量池是否有不被支持的常量类型
    - 指向常量的索引值是否指向了不存在的常量
    - CONSTANT_Utf8_info 型的常量是否有不符合 UTF8 编码的数据
    - ......
- 元数据验证：元数据验证对字节码描述信息进行语义分析，确保其符合 Java 语法规范。
- 字节码验证：字节码验证是验证过程中最复杂的一个阶段，是对方法体进行语义分析，保证方法在运行时不会出现危害虚拟机的事件。
- 符号引用验证：符号引用验证发生在虚拟机将符号引用转化为直接引用的时候，即解析阶段，是对类自身以外的各类信息进行匹配项校验，通俗的说就是该类是否缺少或者被禁止访问它依赖的某些外部类、方法、字段等资源。

验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类已经经过反复验证，那么可以考虑采用 -Xverifynone 参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。

##### 准备

准备阶段是正式为类变量（即静态变量，被 static 修饰的变量）分配内存并设置初始值的阶段，这些变量（不包括实例变量）所使用的内存都在方法区中进行分配。

值得注意的是，这时候进行内存分配的仅仅是静态变量，不包括实例变量，实例变量将随着对象实例化在 Java 堆中分配。其次，这里的初始指通常情况下是“零值”，但是如果被 final 关键字修饰了，会赋予程序中定义的值。

```java
// 初始值：0
public static int value = 123;

// 初始值：123
public static final int value = 123;
```

##### 解析

解析阶段是 Java 虚拟机将常量池内的符号引用转化称直接引用的过程。

`符号引用`：符号引用就是一组符号来描述目标，可以是任何字面量。

`直接引用`：直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。

##### 初始化

初始化是类加载的最后一步，也是真正执行类中定义的 Java 程序代码(字节码)的阶段，初始化阶段会根据程序员通过程序编码制定的主观计划去初始化类变量和其他资源。更直接表达就是初始化阶段就是执行初始化方法 <clinit>() 方法的过程。

#### 类加载器

Java 虚拟机设计团队有意把类加载阶段中的”通过一个类的全限定名来获取描述该类的二进制字节流“这个动作放到 Java 虚拟机外部去实现，以便让程序自己决定如何去获取所需的类。实现这个动作的代码被称为”类加载器“（Class Loader）。

##### 类与类加载器

任意一个类，都由加载它的类加载器和这个类本身一同确立其在 Java 虚拟机中的唯一性，每一个类加载器，都有一个独立的类名称空间。

因此，比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个 Class 文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那么这两个类就必定不相等。

这里的“相等”，包括代表类的 Class 对象的 equals() 方法、isInstance() 方法的返回结果，也包括使用 instanceof 关键字做对象所属关系判定等情况。

##### 双亲委派模型

站在虚拟机的角度，只存在两类加载器：一类是启动类加载器，C++ 实现，是虚拟机的一部分；另一类是其他类加载器，Java 实现，独立于虚拟机存在，并且都继承自 java.lang.ClassLoader。

站在 Java 开发人员的角度来看，类加载器应该划分的更细致。绝大多数 Java 程序都会使用到以下 3 个系统提供的类加载器。

- 启动类加载器（Bootstrap ClassLoader）：负责将存放在 <JAVA_HOME>\lib 目录中的，并且能被虚拟机识别的（仅按照文件名识别，如 rt.jar，名字不符合的类库即使放在 lib 目录中也不会被加载）类库加载到虚拟机内存中。
- 扩展类加载器（Extension ClassLoader）：负责加载 <JAVA_HOME>\lib\ext 目录中的所有类库，开发者可以直接使用扩展类加载器。
- 应用程序类加载器（Application ClassLoader）：由于这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值，所以一般也称它为“系统类加载器”。它负责加载用户类路径（classpath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。

各种类加载器之间的层级关系被称为类加载器的”双亲委派模型“。它要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。（父子关系一般不会以继承的关系实现，而是以组合关系来复用父加载器的代码）

<div align="left">
    <img src="https://github.com/lazecoding/Note/blob/main/images/jvm/类加载器双亲委派模型.png" width="600px">
</div>

双亲委派模型的工作过程：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（找不到所需的类）时，子加载器才会尝试自己去加载。

双亲委派模型的实现代码非常简单，逻辑非常清晰，都集中在 java.lang.ClassLoader 的 loadClass() 中，相关代码如下所示。

```java
private final ClassLoader parent; 
protected Class<?> loadClass(String name, boolean resolve)
        throws ClassNotFoundException {
    synchronized (getClassLoadingLock(name)) {
        // 首先，检查请求的类是否已经被加载过
        Class<?> c = findLoadedClass(name);
        if (c == null) {
            long t0 = System.nanoTime();
            try {
                if (parent != null) {//父加载器不为空，调用父加载器loadClass()方法处理
                    c = parent.loadClass(name, false);
                } else {//父加载器为空，使用启动类加载器 BootstrapClassLoader 加载
                    c = findBootstrapClassOrNull(name);
                }
            } catch (ClassNotFoundException e) {
               //抛出异常说明父类加载器无法完成加载请求
            }
            
            if (c == null) {
                long t1 = System.nanoTime();
                //自己尝试加载
                c = findClass(name);

                // this is the defining class loader; record the stats
                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);
                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                sun.misc.PerfCounter.getFindClasses().increment();
            }
        }
        if (resolve) {
            resolveClass(c);
        }
        return c;
    }
}
```

使用双亲委派模型来组织类加载器之间的关系，一个显而易见的好处就是 Java 中的类随着它的类加载器一起具备了一种带优先级的层次关系。例如 java.lang.Object 这些存放在 rt.jar 中的类，无论使用哪个类加载器加载，最终都会委派给最顶端的启动类加载器加载，从而使得不同加载器加载的 Object 类都是同一个。相反，如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己编写了一个称为 java.lang.Object 的类，并放在 classpath 下，那么系统将会出现多个不同的 Object 类，Java 类型体系中最基础的行为也就无法保证。

##### 破坏双亲委派模型

如果我们不想打破双亲委派模型，就重写 ClassLoader 类中的 findClass() 方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。但是，如果想打破双亲委派模型则需要重写 loadClass() 方法。

双亲委派模型并不是一个强制性约束的模型，有的时候我们需要打破双亲委派模型。在Java生态发展过程中要发送三次大规模“被破坏”的情况，当前破坏并不是贬义词。

- 第一次是双亲委派模型诞生之初，面对已经存在的用户自定义类加载器的代码，Java 设计者们在引入双亲委派模型时不得不做出一些妥协，以便兼容这些已有代码。
- 第二次是破坏的原因在于双亲委派解决了各个类加载器协作时基础类型的一致性问题，保证用户使用基础类型的安全性，但也存在基础类型调用用户代码的情况，如 JDBC。为了解决这一问题，Java 引入了线程上下文类加载器，这个类加载器可以通过 java.lang.Thread 中 setContextClassLoader(ClassLoader cl) 方法进行设置，如果创建线程时还未设置，他将会从父线程中继承一个，如果在应用程序全局范围内都没有设置过，那么这个类加载器默认就是应用程序类加载器。我们通过线程上下文类加载器去获取所需的 SPI 服务代码，这是一种父类加载器去请求子类加载器完成类加载的行为，实质是打破了双亲委派模型。
- 第三次打破是用户对程序的动态性追求导致的，如代码热替换，也就是在运行期间更新 Java 类文件，实现不重启应用的情况下更新应用。OSGI 是 IBM 提出的模块化规范，OSGI 实现模块化热部署的关键在于每个程序模块都有自己的类加载器，当更新一个模块时，就把模块连同类加载器一起换掉以实现代码的热替换。在 OSGI 环境下类加载器不再采用双亲委派模型，而是更为复杂的网状结构。

##### 全局负责机制

当一个类加载器负责加载某个 Class 时，该 Class 所依赖的和引用的其他 Class 也将由该类加载器负责载入，除非显式地使用另外一个类加载器来载入。

##### 缓存机制

缓存机制将会保证所有加载过的 Class 都会被缓存，当程序中需要使用某个 Class 时，类加载器先从缓存区寻找该 Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成 Class 对象，存入缓存区。这就是为什么修改了 Class 后，必须重启 JVM，程序的修改才会生效。