# 类加载子系统

代码编译的结果从本地机器码转换为字节码，是存储格式的一小步，却是编程语言的一大步。

类加载子系统负责将 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型。

### 类文件结构

Java 虚拟机不与任何语言绑定，只与 Class 文件这种特定的二进制文件格式关联，Class 文件中包含了虚拟机指令集、符号表以及若干辅助信息。Class 文件是一组以 8 位字节为基础单位的二进制流，当遇到需要 8 位字节以上空间的数据项时，则会按照高位在前的方式分隔成若干个 8 位字节进行存储,不足 8 字节会以空格填充。

Class 采用一种类似 C 语言结构体的伪结构体来存储数据，这种伪结构体只有两种数据：无符号数和表。
- 无符号数：以 u1、u2、u4、u8 分别代表 1 个字节、2 个字节、4 个字节和 8 个字节的无符号数，可以用来描述数字、索引引用、数量值、按照 UTF-8 编码构成的字符串值。
- 表：由多个无符号数或其他表作为数据项构成的复杂数据类型，所有表都习惯性地以 "_info" 结尾。

```C
ClassFile {
    u4             magic;                                 //Class 文件的标志
    u2             minor_version;                         //Class 的小版本号
    u2             major_version;                         //Class 的大版本号
    u2             constant_pool_count;                   //常量池的数量
    cp_info        constant_pool[constant_pool_count-1];  //常量池
    u2             access_flags;                          //Class 的访问标记
    u2             this_class;                            //当前类
    u2             super_class;                           //父类
    u2             interfaces_count;                      //接口
    u2             interfaces[interfaces_count];          //一个类可以实现多个接口
    u2             fields_count;                          //Class 文件的字段属性
    field_info     fields[fields_count];                  //一个类会可以有多个字段
    u2             methods_count;                         //Class 文件的方法数量
    method_info    methods[methods_count];                //一个类可以有个多个方法
    u2             attributes_count;                      //此类的属性表中的属性数
    attribute_info attributes[attributes_count];          //属性表集合
}
```

#### 魔数

```C
    u4             magic;                                 //Class 文件的标志
```

每个 Class 文件的前 4 个字节称为魔数（Magic Number）,它的唯一作用是确定这个文件是否为一个能被虚拟机接收的 Class 文件。

程序设计者很多时候都喜欢用一些特殊的数字表示固定的文件类型或者其它特殊的含义。

#### Class 文件版本

```C
    u2             minor_version;                         //Class 的小版本号
    u2             major_version;                         //Class 的大版本号
```

紧接着魔数的四个字节存储的是 Class 文件的版本号：第 5 个和第 6 个是 `次版本号`，第 7 个和第 8 个是 `主版本号`。

高版本的 Java 虚拟机可以执行低版本编译器生成的 Class 文件，但是低版本的 Java 虚拟机不能执行高版本编译器生成的 Class 文件。所以，我们在实际开发的时候要确保开发的的 JDK 版本和生产环境的 JDK 版本保持一致。

#### 常量池

```C
    u2             constant_pool_count;                   //常量池的数量
    cp_info        constant_pool[constant_pool_count-1];  //常量池
```

版本信息之后就是常量池，常量池中存放两种类型的常量：

- 字面值常量：字面值常量就是我们在程序中定义的字符串和被 final 修饰的值。
- 符号引用：符号引用就是我们定义的各种名字，即类和接口的全限定名、字段的名字和描述符、方法的名字和描述符。



常量池中每一项常量都是一个表，这 14 种表有一个共同的特点：`开始的第一位是一个 u1 类型的标志位 -tag 来标识常量的类型，代表当前这个常量属于哪种常量类型。`

|               类型               | 标志（tag） |          描述          |
| :------------------------------: | :---------: | :--------------------: |
|        CONSTANT_utf8_info        |      1      |   UTF-8编码的字符串    |
|      CONSTANT_Integer_info       |      3      |       整形字面量       |
|       CONSTANT_Float_info        |      4      |      浮点型字面量      |
|        CONSTANT_Long_info        |     ５      |      长整型字面量      |
|       CONSTANT_Double_info       |     ６      |   双精度浮点型字面量   |
|       CONSTANT_Class_info        |     ７      |   类或接口的符号引用   |
|       CONSTANT_String_info       |     ８      |    字符串类型字面量    |
|      CONSTANT_Fieldref_info      |     ９      |     字段的符号引用     |
|     CONSTANT_Methodref_info      |     10      |   类中方法的符号引用   |
| CONSTANT_InterfaceMethodref_info |     11      |  接口中方法的符号引用  |
|    CONSTANT_NameAndType_info     |     12      |  字段或方法的符号引用  |
|     CONSTANT_MothodType_info     |     16      |      标志方法类型      |
|    CONSTANT_MethodHandle_info    |     15      |      表示方法句柄      |
|   CONSTANT_InvokeDynamic_info    |     18      | 表示一个动态方法调用点 |

`.class` 文件可以通过`javap -v class类名` 指令来看一下其常量池中的信息(`javap -v  class类名-> temp.txt` ：将结果输出到 temp.txt 文件)。

#### 访问标志

在常量池结束之后，紧接着的两个字节代表访问标志，这个标志用于识别一些类或者接口层次的访问信息，包括：这个 Class 是类还是接口，是否为 public 或者 abstract 类型，如果是类的话是否声明为 final 等等。

#### 类索引、父类索引与接口索引集合

```C
    u2             this_class;                            //当前类
    u2             super_class;                           //父类
    u2             interfaces_count;                      //接口
    u2             interfaces[interfaces_count];          //一个类可以实现多个接口
```

类索引和父类索引都是一个 u2 类型的数据，而接口索引集合是一组 u2 类型的数据的集合，Class 文件中由这三项数据来确定类的继承关系。类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名。

由于 Java 不允许多重继承，所以父类索引只有一个，除了 java.lang.Object 之外，所有的 Java 类都有父类，因此除了 java.lang.Object 外，所有 Java 类的父类索引都不为 0。一个类可能实现了多个接口，因此用接口索引集合来描述。这个集合第一项为 u2 类型的数据，表示索引表的容量，接下来就是接口的名字索引。

类索引和父类索引用两个 u2 类型的索引值表示，它们各自指向一个类型为 CONSTANT_Class_info 的类描述符常量，通过该常量总的索引值可以找到定义在 CONSTANT_Utf8_info 类型的常量中的全限定名字符串。

#### 字段表集合

```C
    u2             fields_count;                          //Class 文件的字段属性
    field_info     fields[fields_count];                  //一个类会可以有多个字段
```

字段表（field_info）用于描述接口或类中声明的变量。字段包括类级变量以及实例变量，但不包括在方法内部声明的局部变量。每一个字段表只表示一个成员变量，本类中的所有成员变量构成了字段表集合。

字段表结构如下：

| 类型 | 名称             | 数量             | 说明                                                                                                 |
| ---- | ---------------- | ---------------- | ---------------------------------------------------------------------------------------------------- |
| u2   | access_flags     | 1                | 字段的访问标志，与类稍有不同                                                                         |
| u2   | name_index       | 1                | 字段名字的索引                                                                                       |
| u2   | descriptor_index | 1                | 描述符，用于描述字段的数据类型。 基本数据类型用大写字母表示； 对象类型用“L 对象类型的全限定名”表示。 |
| u2   | attributes_count | 1                | 属性表集合的长度                                                                                     |
| u2   | attributes       | attributes_count | 属性表集合，用于存放属性的额外信息，如属性的值。                                                     |

字段表集合中不会出现从父类（或接口）中继承而来的字段，但有可能出现原本 Java 代码中不存在的字段，譬如在内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段。

#### 方法表集合

```C
    u2             methods_count;                         //Class 文件的方法数量
    method_info    methods[methods_count];                //一个类可以有个多个方法
```

Class 文件存储格式中对方法的描述与对字段的描述几乎采用了完全一致的方式。方法表的结构如同字段表一样，依次包括了访问标志、名称索引、描述符索引、属性表集合几项。

注意：因为`volatile`修饰符和`transient`修饰符不可以修饰方法，所以方法表的访问标志中没有这两个对应的标志，但是增加了`synchronized`、`native`、`abstract`等关键字修饰方法，所以也就多了这些关键字对应的标志。

#### 属性表集合

```C
    u2             attributes_count;                      //此类的属性表中的属性数
    attribute_info attributes[attributes_count];          //属性表集合
```

在 Class 文件，字段表，方法表中都可以携带自己的属性表集合，以用于描述某些场景专有的信息。与 Class 文件中其它的数据项目要求的顺序、长度和内容不同，属性表集合的限制稍微宽松一些，不再要求各个属性表具有严格的顺序，并且只要不与已有的属性名重复，任何人实现的编译器都可以向属性表中写 入自己定义的属性信息，Java 虚拟机运行时会忽略掉它不认识的属性。

### 类加载机制

Java 虚拟机把类描述文件（Class 文件）加载到内存，并对数据进行校验、准备、解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这就是 Java 虚拟机的类加载机制。

#### 类的生命周期

一个类型从加载到虚拟机内存中开始到卸载出内存为止，它的整个声明周期将会经历加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）七个阶段，其中验证、准备、解析三个阶段合称为连接（Linking）。

<div align="left">
    <img src="https://github.com/lazecoding/Note/blob/main/images/jvm/类的生命周期.png" width="600px">
</div>

类加载过程包括其中 5 个阶段：
- 加载
- 验证
- 准备
- 解析
- 初始化

##### 加载

加载阶段，Java 虚拟机主要做 3 件事情：
- 通过类的全限定名来获取这个类的二进制字节流。
- 将字节流所代表的静态存储结构转换为方法区的运行时数据结构。
- 在内存中创建一个代表该类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口。

对于 Class 文件，虚拟机没有指明要从哪里获取、怎样获取。除了直接从编译好的 .class 文件中读取，还有以下几种方式：
- 从 zip 包中读取，如 jar、war 等。
- 从网络中获取，如 Applet。
- 通过动态代理技术生成代理类的二进制字节流。
- 由 JSP 文件生成对应的 Class 类。
- 从数据库中读取，如有些中间件服务器可以选择把程序安装到数据库中来完成程序代码在集群间的分发。
- ...

虚拟机规范也未规定 Class 对象的存储位置，对于 HotSpot 虚拟机而言，Class 对象比较特殊，虽是对象，但存放在方法区中。

##### 验证

验证是连接阶段的第一步，目的是确保 Class 文件的信息符合 Java 虚拟机约束，保证这些信息不会危害虚拟机自身安全。

验证阶段大致上会完成下面 4 个阶段的检验动作：
- 文件格式验证：验证字节流是否符合 Class 文件格式的规范，并且能被当前版本的虚拟机处理，验证点如下：
    - 是否以魔数 0XCAFEBABE 开头
    - 主次版本号是否在当前虚拟机处理范围内
    - 常量池是否有不被支持的常量类型
    - 指向常量的索引值是否指向了不存在的常量
    - CONSTANT_Utf8_info 型的常量是否有不符合 UTF8 编码的数据
    - ......
- 元数据验证：元数据验证对字节码描述信息进行语义分析，确保其符合 Java 语法规范。
- 字节码验证：字节码验证是验证过程中最复杂的一个阶段，是对方法体进行语义分析，保证方法在运行时不会出现危害虚拟机的事件。
- 符号引用验证：符号引用验证发生在虚拟机将符号引用转化为直接引用的时候，即解析阶段，是对类自身以外的各类信息进行匹配项校验，通俗的说就是该类是否缺少或者被禁止访问它依赖的某些外部类、方法、字段等资源。

验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类已经经过反复验证，那么可以考虑采用 -Xverifynone 参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。

##### 准备

准备阶段是正式为类变量（即静态变量，被 static 修饰的变量）分配内存并设置初始值的阶段，这些变量（不包括实例变量）所使用的内存都在方法区中进行分配。

值得注意的是，这时候进行内存分配的仅仅是静态变量，不包括实例变量，实例变量将随着对象实例化在 Java 堆中分配。其次，这里的初始指通常情况下是“零值”，但是如果被 final 关键字修饰了，会赋予程序中定义的值。

```java
// 初始值：0
public static int value = 123;

// 初始值：123
public static final int value = 123;
```

##### 解析

解析阶段是 Java 虚拟机将常量池内的符号引用转化称直接引用的过程。

`符号引用`：符号引用就是一组符号来描述目标，可以是任何字面量。

`直接引用`：直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。

##### 初始化

初始化是类加载的最后一步，也是真正执行类中定义的 Java 程序代码(字节码)的阶段，初始化阶段会根据程序员通过程序编码制定的主观计划去初始化类变量和其他资源。更直接表达就是初始化阶段就是执行初始化方法 <clinit>() 方法的过程。


