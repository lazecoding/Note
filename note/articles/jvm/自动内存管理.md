# 自动内存管理

和 C 语言的手动管理内存不同，Java 虚拟机提供了自动内存管理机制，实现内存的自动分配和释放。

### 对象已死？

对象存活判断主要有两种方式：引用计数和可达性分析。

- 引用计数：每个对象拥有一个引用计数器，当有个地方引用它时，计数器加 1；引用失效时，计数器减 1；当计数器为 0 时，意味着对象不可能再被使用。这种方法简单，但无法解决循环引用的问题。
- 可达性分析：从 GC Roots 开始向下搜索，搜索路径被称为引用链，当一个对象和 GC Roots 之间没有任何引用链相连，就意味着对象不可能在被使用，它们将被判定为可回收对象。在 Java 语言中，GC Roots 包括：虚拟机栈中引用的对象、方法区中类静态属性引用的对象、常量池中常量引用的对象、本地方法栈中 Native 方法引用的对象。

### 引用类型

Java 中存在 4 种引用：强引用、软引用 、弱引用、虚引用。

- 强引用是最常用的一种引用，如 new 创建的对象就属于强引用。只要强引用关系存在，对象就不会被回收。
- 软引用是由 java.lang.ref.SoftReference 提供的功能，只有虚拟机内存不足时才会回收该对象。很多人说可以当缓存，但如果不是单机架构就不太可行。
- 弱引用是由 java.lang.ref.WeakReference 提供的功能，只要发生 GC 对象就会被回收。
- 虚引用是由 java.lang.ref.PhantomReference 提供的功能，用户无法通过虚引用来获取对一个对象的真实引用，虚引用需要结合引用队列使用，当其所引用对象被回收时会自动加入到引用队列中。也就是说你可以通过虚引用得到哪些内存已被回收，在 NIO 中，就利用虚引用管理堆外内存。

### 垃圾收集

程序计数器、虚拟机栈、本地方法栈随线程而生，也随线程而灭；栈帧随着方法的开始而入栈，随着方法的结束而出栈。这几个区域的内存分配和回收都具有确定性，在这几个区域内不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟随着回收了。

而对于 Java 堆和方法区，我们只有在程序运行期间才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，垃圾收集所关注的正是这部分内存。

#### 垃圾收集算法

垃圾收集算法的目的是回收可回收对象所使用的内存空间并归还程序，垃圾收集算法主要有 4 种：标记清除算法、复制算法、标记整理算法和分代收集算法。

##### 标记清除算法

分为标记和清除两个阶段，标记阶段标记出所有可回收区域，清除阶段回收所有被标记为可回收的区域。

速度块，但容易产生内存碎片。

##### 复制算法

将内存一份为二，标记存活对象，将存活对象复制到空白的内存区域，然后清空旧的内存区域。

简单高效，但浪费内存。

<div align="left">
    <img src="https://github.com/lazecoding/Note/blob/main/images/jvm/复制算法.png" width="600px">
</div>

##### 标记整理算法

会整理清除后的内存区域，进行顺序存储，优点是节约内存，避免产生内存碎片，

避免产生内存碎片，但如果这个环节负担过大，会明显降低系统的吞吐量。

<div align="left">
    <img src="https://github.com/lazecoding/Note/blob/main/images/jvm/标记整理算法.png" width="600px">
</div>

##### 分代收集算法

分代收集算法是把堆内存分为新生代和老年代，根据其各自的特点采用最适当的收集算法。

- 新生代中对象大多朝生夕死，只有少量存活，一般选用复制算法。
- 老年代中对象存活几率高，没有额外的空间对它进行分配担保，一般使用标记-清除或者标记-整理算法。

研究表明，新生代中的 90% 的对象是“朝生夕死”的，所以不需要按照 1:1 的比例来划分内存空间，而是分为一块较大的 Eden 空间和两块较小的 Survivor （From、To）空间，每次使用 Eden 和其中一块 Survivor。
当回收时，将 Eden 和 Survivor 中还存活着的对象复制到另外一块 Survivor 空间上，最后清理 Eden 和刚刚使用的 Survivor 空间。

<div align="left">
    <img src="https://github.com/lazecoding/Note/blob/main/images/jvm/分代收集算法.png" width="600px">
</div>