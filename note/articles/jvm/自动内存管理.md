# 自动内存管理

和 C 语言的手动管理内存不同，Java 虚拟机提供了自动内存管理机制，实现内存的自动分配和释放。

### 对象已死？

对象存活判断主要有两种方式：引用计数和可达性分析。

- 引用计数：每个对象拥有一个引用计数器，当有个地方引用它时，计数器加 1；引用失效时，计数器减 1；当计数器为 0 时，意味着对象不可能再被使用。这种方法简单，但无法解决循环引用的问题。
- 可达性分析：从 GC Roots 开始向下搜索，搜索路径被称为引用链，当一个对象和 GC Roots 之间没有任何引用链相连，就意味着对象不可能在被使用，它们将被判定为可回收对象。在 Java 语言中，GC Roots 包括：虚拟机栈中引用的对象、方法区中类静态属性引用的对象、常量池中常量引用的对象、本地方法栈中 Native 方法引用的对象。

### 引用类型

Java 中存在 4 种引用：强引用、软引用 、弱引用、虚引用。

- 强引用是最常用的一种引用，如 new 创建的对象就属于强引用。只要强引用关系存在，对象就不会被回收。
- 软引用是由 java.lang.ref.SoftReference 提供的功能，只有虚拟机内存不足时才会回收该对象。很多人说可以当缓存，但如果不是单机架构就不太可行。
- 弱引用是由 java.lang.ref.WeakReference 提供的功能，只要发生 GC 对象就会被回收。
- 虚引用是由 java.lang.ref.PhantomReference 提供的功能，用户无法通过虚引用来获取对一个对象的真实引用，虚引用需要结合引用队列使用，当其所引用对象被回收时会自动加入到引用队列中。也就是说你可以通过虚引用得到哪些内存已被回收，在 NIO 中，就利用虚引用管理堆外内存。

### 垃圾收集

程序计数器、虚拟机栈、本地方法栈随线程而生，也随线程而灭；栈帧随着方法的开始而入栈，随着方法的结束而出栈。这几个区域的内存分配和回收都具有确定性，在这几个区域内不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟随着回收了。

而对于 Java 堆和方法区，我们只有在程序运行期间才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，垃圾收集所关注的正是这部分内存。

#### 垃圾收集算法

垃圾收集算法的目的是回收可回收对象所使用的内存空间并归还程序，垃圾收集算法主要有 4 种：标记清除算法、复制算法、标记整理算法和分代收集算法。

##### 标记清除算法

分为标记和清除两个阶段，标记阶段标记出所有可回收区域，清除阶段回收所有被标记为可回收的区域。

速度块，但容易产生内存碎片。

##### 复制算法

将内存一份为二，标记存活对象，将存活对象复制到空白的内存区域，然后清空旧的内存区域。

简单高效，但浪费内存。

<div align="left">
    <img src="https://github.com/lazecoding/Note/blob/main/images/jvm/复制算法.png" width="600px">
</div>

##### 标记整理算法

会整理清除后的内存区域，进行顺序存储，优点是节约内存，避免产生内存碎片，

避免产生内存碎片，但如果这个环节负担过大，会明显降低系统的吞吐量。

<div align="left">
    <img src="https://github.com/lazecoding/Note/blob/main/images/jvm/标记整理算法.png" width="600px">
</div>

##### 分代收集算法

分代收集算法是把堆内存分为新生代和老年代，根据其各自的特点采用最适当的收集算法。

- 新生代中对象大多朝生夕死，只有少量存活，一般选用复制算法。
- 老年代中对象存活几率高，没有额外的空间对它进行分配担保，一般使用标记-清除或者标记-整理算法。

研究表明，新生代中的 90% 的对象是“朝生夕死”的，所以不需要按照 1:1 的比例来划分内存空间，而是分为一块较大的 Eden 空间和两块较小的 Survivor （From、To）空间，每次使用 Eden 和其中一块 Survivor。
当回收时，将 Eden 和 Survivor 中还存活着的对象复制到另外一块 Survivor 空间上，最后清理 Eden 和刚刚使用的 Survivor 空间。

<div align="left">
    <img src="https://github.com/lazecoding/Note/blob/main/images/jvm/分代收集算法.png" width="600px">
</div>

#### 垃圾收集器

收集算法是内存回收的方法论，而垃圾收集器就是内存回收的具体实现。在我们了解垃圾收集器之前我们先引入一个 "Stop The World" 的概念，简称 STW：垃圾收集时暂停其他工作线程，直至垃圾收集结束的状态。

下图展示几种经典的垃圾收集器，连线表示组合关系：

<div align="left">
    <img src="https://github.com/lazecoding/Note/blob/main/images/jvm/垃圾收集器组合.png" width="600px">
</div>

##### Serial 和 Serial Old

它们分别是作用于年轻代和老年代的收集器，单线程串行收集，对于内存稍大的，会出现长时间的 STW。其中 Serial 采用标记复制算法，Serial Old 采用标记 - 整理算法，他们设计简单，适合客户端程序，但不适合并发大、内存大的服务端程序。

<div align="left">
    <img src="https://github.com/lazecoding/Note/blob/main/images/jvm/Serial和SerialOld.png" width="600px">
</div>

##### ParNew

ParNew 收集器运行在年轻代，是 Serial 的多线程版本，同样采用标记复制算法，会暂停工作线程。一般和 Serial Old、CMS 配合使用。

<div align="left">
    <img src="https://github.com/lazecoding/Note/blob/main/images/jvm/ParNew.png" width="600px">
</div>

##### Parallel Scavenge 和 Parallel Old

Parallel Scavenge 也是年轻代垃圾收集器，采用标记复制算法，能够并行 GC，需要暂停工作线程。但是它可以配置最大停顿事件、垃圾收集事件占比等参数，提高系统吞吐量，是 "吞吐量优先" 的收集器。Parallel Old 是 Parallel Scavenge 的老年代版本，支持并发 GC，基于标记整理算法。

<div align="left">
    <img src="https://github.com/lazecoding/Note/blob/main/images/jvm/Parallel.png" width="600px">
</div>

##### CMS

CMS，全称 Concurrent Mark Sweep，顾名思义，并发标记清除收集器。CMS 是以获取最短回收间隔时间为目标的收集器，仅仅运行在老年代的收集器，分为四个阶段：初始标记、并发标记、重新标记、并发清除。

- 初始标记：仅标记 GC Roots 能直接关联到的对象，速度很快，会产生 "Stop The World"。
- 并发标记：会从 GC Roots 开始对堆中对象进行可达性分析，耗时长，但是不暂停工作线程，与工作线程并行。
- 重新标记：是为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，短暂暂停工作线程，多线程并行。
- 并发清除：清除掉标记阶段的标记对象，因为采用的是标记清除算法，未整理移动对象，所以也可以和工作线程并发执行。

<div align="left">
    <img src="https://github.com/lazecoding/Note/blob/main/images/jvm/CMS.png" width="600px">
</div>

CMS 的优点是并发收集、低停顿，但缺点也很明显。一是并发收集对 CPU 敏感，会占用计算机的线程资源，导致应用程序变慢；二是会产生浮动垃圾，因为是与用户线程并行的，所以可能在标记结束后继续出垃圾；三是采用的是标记清除算法会产生内存碎片，当老年代找不到足够的连续内存空间，就会引发 Full GC。

##### G1

G1，全称 Garbage First。到了JDK1.8，G1 才真正的完成。G1 是一款面向服务器的垃圾收集器，主要针对配备多颗处理器及大容量内存的机器，以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征.

G1 把内存空间分为多个连续大小固定的独立区域（Region），并且跟踪这些区域的垃圾堆积程度，维护一个优先列表，根据允许的收集时间，优先选择回收价值最大的 Region。G1 在物理上不分代，但是在逻辑上是分代的，保留新生代、老年代的概念。从整个内存区域的角度看是 G1 采用的是标记整理算法，从单个 Region 看 G1 采用的是复制算法。

<div align="left">
    <img src="https://github.com/lazecoding/Note/blob/main/images/jvm/G1Region.png" width="600px">
</div>

G1分为四个阶段：初始标记、并发标记、最终标记、筛选回收。
- 初始标记：仅标记 GC Roots 能直接关联到的对象，速度很快，会产生 "Stop The World"。
- 并发标记：会从 GC Roots 开始对堆中对象进行可达性分析，耗时长，但是不暂停工作线程，与工作线程并行。
- 最终标记：是为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，短暂暂停工作线程，多线程并行。
- 筛选回收：在后台维护一个优先列表，对各个 Region 的回收价值和成本进行排序，根据根据用户所期待的 GC 停顿时间，优先回收价值最大的 Region。这里的操作涉及存活对象的移动，必须暂停用户线程，多条收集器线程并行完成。

<div align="left">
    <img src="https://github.com/lazecoding/Note/blob/main/images/jvm/G1.png" width="600px">
</div>

##### ZGC [](https://tech.meituan.com/2020/08/06/new-zgc-practice-in-meituan.html)
[](https://dinfuehr.github.io/blog/a-first-look-into-zgc/)
ZGC 全称 The Z Garbage Collector，采用标记-复制算法，但对该算法做了重大改进，使得 ZGC 中出现 Stop The World 的情况会更少。

ZGC 是 JDK 11 中推出的一款低延迟垃圾回收器，它的设计目标包括：

- 停顿时间不超过 10ms；
- 停顿时间不会随着堆的大小，或者活跃对象的大小而增加；
- 支持 8MB ~ 4TB 级别的堆（未来支持 16TB）。

