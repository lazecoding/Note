# 内存溢出和内存泄漏

- 目录
    - [内存溢出](#内存溢出)
        - [内存溢出场景](#内存溢出场景)
    - [内存泄漏](#内存泄漏)
        - [内存泄漏场景](#内存泄漏场景)

内存溢出和内存泄漏是两个容易混淆的问题。

### 内存溢出

Java 虚拟机中内存溢出一般是指内存越界，对于 C 类语言内存溢出还存在缓冲区溢出的情况，Java 虚拟机中只有在极端情况下会出现缓冲区溢出。

- 通过 jni 调用本机代码。
- 虚拟机本身(通常用 C++ 编写)。
- 解释器或 JIT 编译器不能正常工作(Java 字节码强制进行边界检查)。

#### 内存溢出场景

- Java 堆溢出：OutOfMemoryError：Java heap space

Java堆主要用于存储对象实例，当出现 OutOfMemoryError 异常首先转储 Dump 文件进行分析，确认导致 OOM 的对象是否是有用对象，即确认是不是因内存泄漏而导致的内存溢出。如果这些对象都是有用的，就意味着不是内存泄漏导致的内存溢出，这时就需要根据机器内存调整虚拟机的堆大小参数（-Xmx、-Xms），并从代码层面检查是否有生命周期过长、存储结构不合理等情况，尽可能减少程序运行的内存消耗。

- 虚拟机栈和本地方法栈溢出：StackOverFlowError

虚拟机栈和本地方法中存在两种异常：如果线程请求的栈深度大于虚拟机所允许的栈深度，即创建栈帧时没有内存空间 Java 虚拟机将抛出 StackOverflowError 异常；如果虚拟机栈可以动态扩展，当扩展时无法申请到内存空间 JVM 将抛出 OutOfMemoryError 异常。

栈帧是虚拟机方法调用和方法执行的数据结构，栈帧存储了局部变量表、操作数栈等信息。当虚拟机栈发生了内存溢出，可以调整线程栈大小参数（-Xss），但给线程分配的栈内存越大，也可能会导致更容易发生内存溢出异常。因为进程所能使用的最大内存取决于操作系统的寻址范围，如 32 位操作系统单个进程的最大内存限制为 2G。Java 虚拟机能使用的最大内存空间减去最大堆和最大方法区容量，忽略占内存较小的程序计数器容量，再忽略虚拟机运行本身的内存消耗和直接内存，剩下的内存就由虚拟机栈和本地方法栈分配了，当每个线程分配的栈内存越大，可建立的线程数量自然就越小，如果建立线程过多就可能导致内存溢出。

- 方法区溢出，方法区在 JDK 1.8 前后处于虚拟机的不同区域，以 JDK 1.8 为例：OutOfMemoryError：MetaSpace

方法区主要存储被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。自方法区移除出Java堆，方法区很少出现内存溢出，当出现内存溢出，可以调整元空间内存容量大小。

- 本地直接内存溢出：OutOfMemoryError

直接内存容量可通过 -xx：MaxDirectMemorySize 指定，如果不指定，则默认与 Java 堆内存大小最大值（-Xmx）一样。当发生直接内存溢出，明显特征就是 Heap Dump 文件很小。

### 内存泄漏

内存泄漏是指无用对象（不再使用的对象）长期占有内存或无用对象的内存得不到及时释放，从而造成内存空间的浪费称为内存泄漏。内存泄露有时不严重且不易察觉，但有时很严重，甚至导致内存溢出。

Java虚拟机中，发生内存泄漏的对象有以下两个特点：

- 这些对象是可达的，即在有向图中，存在通路可以与其相连；
- 这些对象是无用的，即程序以后不会再使用这些对象。

内存泄漏的根本原因是长生命周期对象持有短生命周期对象的引用。这样会导致短生命周期对象虽然已经不再使用，但由于长生命周期对象持有它的引用而导致短生命周期对象无法被回收。

#### 内存泄漏场景

- 静态容器

诸如 ArrayList、HashMap、ThreadLocal 之类的容器，他们所引用的对象将伴随这些容器的生命周期。静态变量的生命周期和应用程序一致，如果这些容器是静态的，那么这些容器所引用的对象将永远不会被回收，因此使用容器时要谨慎地移除容器中无用对象，尤其是使用静态容器。

- 静态变量

类似于静态容器，如果一个静态变量持有一个对象的引用，被引用的对象将永远不会被回收。如单例模式中，单例对象将贯穿整个 Java 虚拟机的生命周期，如果单例对象引用了外部对象，被引用的对象将永远不会被回收。

- 内部类

如果一个外部类的实例对象的方法返回了一个内部类的实例对象，这个内部类对象被长期引用了，即使那个外部类实例对象不再被使用，但由于内部类持有外部类的实例对象的引用，这样也会导致内存泄露。

- 各种连接

数据库、Socket 和 IO 等连接必须显式地调用了其 close() 方法关闭连接，否则 GC 不会回收这些连接。数据库操作过程中，首先需要建立与数据库的连接，当不再使用时需要调用其 close() 方法释放数据库连接。只有连接被关闭后，GC 才会回收相应对象，如果不显性地关闭 Connection、Statement、ResultSet，将会引起内存泄漏。

- 监听器

监听器使用完毕也需要及时关闭，否则也会造成内存泄漏。