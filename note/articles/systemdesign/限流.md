# 限流

- 目录
    - [计数器算法](#计数器算法)
    - [滑动时间窗口算法](#滑动时间窗口算法)
    - [漏桶算法](#漏桶算法)
    - [令牌桶算法](#令牌桶算法)
    - [总结](#总结)

每个系统都有最大服务能力，即达到阈值之前，系统都可以正常提供服务。为了保证系统面临大流量时依然可以对外提供服务，我们就需要使用限流技术。

常见限流算法：计数器算法、滑动时间窗口算法、漏斗算法、令牌桶算法。

### 计数器算法

该算法维护一个 counter，单位时间内 counter 的大小不能超过阈值，每隔单位时间将 counter 清零。如果这个 counter 大于设定的阈值，系统就开始拒绝请求。计数器算法存在一个时间临界值问题，如果上一个单位时间的最后一刻和下一个单位时间的最初一刻产生大量请求，就可能超过系统负载。

### 滑动时间窗口算法

滑动时间窗口算法也是限制单位时间请求次数，但与计数器算法不同的是它将一个固定长度的时间窗口划分为多个小窗口，随着时间流逝就进行移动，每个窗口计数判断阀值，这样就巧妙地不开了计数器的临界点问题。

<div align="left">
    <img src="https://github.com/lazecoding/Note/blob/main/images/systemdesign/限流-滑动时间窗口算法.png" width="600px">
</div>

### 漏桶算法

该算法维护一个固定容量的桶，这个桶会按照指定的速度漏水。请求到达系统就类似于将水加入桶中，如果这个桶满了，就会忽略后面来的请求，直到这个桶可以存放多余的水。漏桶算法的好处是可以将系统的处理能力维持在一个比较平稳的水平，缺点是在瞬间流量过来时，会拒绝后续的请求流量。一般来说，代码中会使用一个队列实现 "漏桶" 的效果，当请求过多时，队列中的请求就开始积压，当队列满了之后系统就会开始拒绝请求。

<div align="left">
    <img src="https://github.com/lazecoding/Note/blob/main/images/systemdesign/限流-漏桶算法.png" width="600px">
</div>

### 令牌桶算法

令牌桶算法和漏桶算法效果类似，但思路相反：随着瞬间的流逝，系统会按照指定速度往桶里添加 token，每来一个新请求，就从桶里拿走一个 token，如果没有 token 就拒绝服务。这种算法的好处便是控制系统的处理速度，甚至可以通过统计信息实时优化令牌桶的大小。

<div align="left">
    <img src="https://github.com/lazecoding/Note/blob/main/images/systemdesign/限流-令牌桶算法.png" width="600px">
</div>

### 总结

从理论上来说，令牌桶算法和漏桶算法的不同之处在于处理瞬间到达的大流量的不同：令牌桶算法由于在令牌桶中攒了很多令牌，因此在大流量到达的瞬间可以一次性将队列中所有的请求都处理完，然后按照恒定的速度处理请求；漏桶算法则一直有一个恒定的阈值，在大流量到达的时候，会将多余的请求拒绝。在 Nginx 这种基本没什么业务逻辑的网关中，自身的处理也不会是瓶颈，在这种场景下，就比较合适使用令牌桶算法。