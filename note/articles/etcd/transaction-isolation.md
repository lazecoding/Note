# 事务和隔离

- 目录
  - [ACID](#ACID)
  - [隔离性](#隔离性)
  - [事务](#事务)

etcd v2 提供了针对单个 key 的条件更新操作，即 CAW (Compare-And-Swap)操作。客户端在对一个 key 进行写操作的时候需要提供该 key 的版本号或者当前值，客户端会进行比较更新。显而易见，etcd v2 只能保证单个 key 的原子操作。

因此，etcd v3 引入了迷你事务（mini-transaction）的操作，每次事务都可以包含一系列的条件语句，只有当条件都满足时，事务才会执行成功。

### ACID

事务必须满足 ACID 四个特性：原子性、一致性、隔离性、持久性。

- 原子性

单个事务包含一系列的操作 比如查找、增加、更新等。在事务提交之后，事务中对数据库的所有操作都必须反映到数据库上。但如果由于某些原因发生中断，那么对数据的所有操作必须恢复到这个事务开始之前。就是事务对数据库的操作，要么全部执行，要么都不执行。

- 一致性

一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。

- 隔离性

每个读写事务的对象对于其他事务相互分离，即该事务提交前其他事务不可见。

- 持久性

事务一旦提交，其结果就是永久的。

### 隔离性

这里重点说明一下事务的隔离性，当多个客户端都开启事务操作数据库时，数据库需要进行隔离操作，以保证各个客户端获取数据的准确性。

4 种隔离级别：

- READ UNCOMMITTED：读未提交
- READ COMMITTED：读已提交
- REPEATABLE READ：可重复读
- SERIALIZABLE：可串行化

`READ UNCOMMITTED`：查询时，读取的数据中允许含有脏数据，不检查来自各存储节点的数据是否活跃，即不检查来自各个存储节点的数据是否来自同一版本或同一时刻的副本数据。在该隔离级别，所有事务都可以看到其他未提交事务的执行结果，存在脏读问题。脏读（Dirty Read）是指读取未提交的数据。

`READ COMMITTED`：查询时，读取的数据中不允许包含脏数据，检查来自各存储节点的数据不能为活跃状态，即检查来自各存储节点的数据必须为同一版本或同一时刻的副本数据。该隔离级别通过对数据的版本进行校验解决了脏读问题，但存在不可重复读问题。不可重复读（Nonrepeatable Read）是指，同一查询可能返回不同结果。

`REPEATABLE READ`：它确保同一事务的多个实例在并发（多次）读取数据时，会看到同样的数据行。该隔离级别存在幻读（Phantom Read）问题，简单地说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的 "幻影" 行。

`SERIALIZABLE`：这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。

### 事务

etcd 实现了在一个事务中，原子地执行冲突检查、更新多个 keys 的值。除此之外，etcd 将底层 MVCC 机制的版本信息暴露出来，根据版本信息封装出了一套基于乐观锁的事务框架 STM，并实现了不同的隔离级别。

STM 系统可以确保的事项具体如下：

- 事务是原子的，一个事务提交以后，如果该事务涉及了对多个 key 的操作那么对多个 key 的操作要么都成功，要么都不成功。
- 事务至少具有可重复读取隔离型，以保证不会读到脏数据。
- 数据是一致的，提交的时候 STM 会自动检测到数据冲突并重试事务以解决这些冲突。

 点击查看，[更多内容](https://blog.betacat.io/post/2019/08/learn-transaction-isolation-levels-from-etcd) 。