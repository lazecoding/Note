# MVCC

- 目录
  - [并发控制方式](#并发控制方式)
    - [悲观并发控制](#悲观并发控制)
    - [乐观并发控制](#乐观并发控制)
    - [多版本并发控制](#多版本并发控制)
  - [为什么选择 MVCC](#为什么选择-MVCC)
  - [v2 存储机制实现](#v2-存储机制实现)
  - [v3 数据模型](#v3-数据模型)
    - [revision](#revision)
    - [逻辑视图](#逻辑视图)
    - [物理视图](#物理视图)
  - [v3 的 MVCC 实现](#v3-的-MVCC-实现)
  - [为什么选择 BoltDB 作为底层的存储引擎](#为什么选择-BoltDB-作为底层的存储引擎)

在数据库领域，并发控制是一个很具有挑战性的领域。

### 并发控制方式

常见的并发控制方式包括悲观并发控制、乐观并发控制和多版本并发控制。

#### 悲观并发控制

在关系型数据库中，并发控制（又名悲观锁，Pessimistic Concurrency Control ,PCC）是一种并发控制的方法。它可以阻止一个事物以影响其他用户的方式来修改数据。它可以阻止一个事务以影响其他用户的方式来修改数据。如果一个事物执行的操作对某行数据应用了锁，那么只有在这个事务将锁释放后，其他事务才能执行与该锁冲突的操作。悲观并发控制主要用于数据竞争激烈的环境，以及发生并发冲突时使用锁保护数据的成本要低于回滚事务的成本环境中。

#### 乐观并发控制

乐观并发控制（又名乐观锁）也是一种并发控制的方法。它假设多用户并发的事务在处理时彼此之间互不影响，各个事务能够在不产生锁的情况下处理格子影响的那部分数据。在提交数据更新之前，每个事务都会检查在该事务读取数据之后，有没有其他事务又修改了数据。如果其他事务有更新的化，那么提交的事务会发生回滚。

乐观并发控制多用于数据竞争不大，冲突较少的环境。在这种环境下，偶尔发生事务回滚的成本要低于读取数据时锁定数据的成本，因此，这种环境下乐观并发控制可以获得比其他并发控制方法更高的吞吐量。

#### 多版本并发控制

多版本并发控制（Multiversion Concurrency Control ,MVCC）并不是一个与乐观并发控制和悲观并发控制对立的概念。它能够与两者很好的结合以增加事务的并发量，目前最流行的SQL数据库MySQL和PostgreSQL都对MVCC进行实现。MVCC每一个写操作都会创建一个新版本的数据，读操作会从有限多个版本的数据中挑选一个最合适的（要么是最新版本，要么是指定版本）的结果返回。通过这种方式，读写操作之间的冲突不再需要收到关注。

### 为什么选择 MVCC

对一个系统进行优化时，相应的思路并不是凭空产生的，而实存在一定的方法论，首先我们应该分析 etcd 的使用场景，然后才能进行针对性的优化。首先 etcd 定位是一个分布式，一致的 key-value 存储，主要用途时共享配置和服务发现，它不是一个类似于 ceph 那样存储海量数据的存储体系，也不是类似于 MySQL 这样的关系型数据库。它存储的其实是一些非常重要的元数据，元数据的写操作是非常少的，但是会有很多客户端同时 watch 这些元数据的变更。也就是说 etcd 使用场景是一种 "读多写少" 的场景，etcd 的一个 key 其实不不会频繁变更，但是一旦发生变更，etcd 就需要通知监听这个 key 的所有客户端。

因为同一时间可能会存在很多用户连接，那么这段时间一定会存在许多并发问题，比如数据竞争。etcd 必须保证并发操作产生的结果是安全的。etcd v2 是一个纯内存数据库，整个数据库有一个 stop the world 的锁，可以通过所锁机制来解决并发带来的数据问题，但是通过锁的方式存在一些缺点：

- 锁的粒度不好控制，每次操作 stop the world 时都会锁住整个数据库。
- 读锁和写锁会互相阻塞（block）。
- 如果使用基于锁的隔离机制，并且有一段很长的读事务，那么在这段时间内这个对象就会无法被改写，后面的事务会被阻塞，直到这个事务完成为。这种机制对于并发性能来说影响很大。

MVCC 则以一种优雅的方式解决了所带来的问题。在 MVCC 中，每当想要更改或者删除某个数据对象时，DBMS 不会在原地删除或者修改这个已有的数据对象本身，而实针对该数据对象创建一个新的版本，这样一来，并发读取操作仍然可以读取老版本的数据，而写数据就可以同时进行。这个模式的好处在于，可以读取操作不再阻塞，事实上根本不需要锁。

### v2 存储机制实现

etcd v2 是一个纯内存数据库，写操作通过 Raft 复制日志文件，复制成功后将数据写入到内存，整个数据库在内存中是一个简单的树形结构。etcd v2 并未实时地将内存中的数据写入到磁盘，持久化是靠快照实现的，具体实现就是将整个内存中的数据复制一份，然后序列化成 JSON，写入磁盘，成为一个快照。做快照的时候使用的是复制出来的数据库，客户端读写请求依然落在原始的数据库上，这样的话，做快照的操作不会阻塞客户端的读写请求。


### v3 数据模型

etcd v3 可靠的存储不经常更新的数据，并且提供可靠的 watch 查询。etcd v3 与 etcd v2 不同的是，它支持暴露旧版本的键值来支持高效的快照和 watch 历史事件。一个持久化的，MVCC 的数据模型非常适合 etcd v3 使用场景——因为如果仅仅维持一个 key，一个 value 的数据模型，那么连续更新就只能保存最后一个 value，历史版本无法追溯，而 MVCC 则可以解决这个问题。

etcd v3 将数据存储在一个多版本的持久化 key-value 存储里面。值得注意的是，作为 key-value 存储的 etcd 会将数据存储在另一个 key-value 数据库中。当持久简直存储的值发生变化时，持久化键值保存先前版本的键值对。etcd 后台的键值存储实际是不可变的，etcd 操作不会就地更新结构，而实始终生成一个更新之后的结构。发生修改后，key先前的版本的所有制仍然可以访问和 watch。为了防止数据存储随时间的推移无限增长，并且为了维护旧版本，etcd 可能会压缩（删除）key 的旧版本数据。

#### revision

每个 revision 都由（main ID，sub ID）唯一标识，它也是实现 etcd v3 的基础。

- 每个事务都有唯一事务 ID，全局递增不重复，即 revision 的 main ID。
- 一个事务可以包含多个修改操作，每个修改操作均对应一个 revision，它们共享一个 main ID。
- 一个事务内连续多个修改操作都会从 0 开始递增编号，这个编号即为 sub ID。

#### 逻辑视图

etcd v3 存储的逻辑视图是一个扁平的二进制键空间。该键空间对 key 有一个此法排序索引，因此此范围查询的成本很低。etcd 键空间可能维护很多 revision。每个原子修改（例如，一个事务操作可能包含多个操作）都会在键空间上创建一个新的 revision，之前 revision 所有数据均保持不变，旧版本（version）的 key 仍然可以通过之前的 revision 进行访问。同样，revision 也是被索引的，因此 Watcher 可以实现高效的范围 watch。revision 在 etcd 中可以起到逻辑时钟的作用。revision 在集群的声明周期时单调递增的。如果因为节省空间而压缩空间，那么在此 revision 之前的的 revision 都会被删除，只保留之后的 revision。

我们将 key 创建和删除的过程称为一个生命周期。在 etcd 中，每个 key 都可能有多个生命周期，也就是说被创建，删除多次。创建一个 key 时，如果在当前 revision 中该 key 不存在（即之前没有创建过），那么它的 revision 就会被设置为1.删除 key 就会生成一个 key 的墓碑。可以通过将其 version 重置 0 来结束 key 的生命周期。对 key 的每一次修改都会增加其 version，因此，key 的 version 在 key 的一次生命周期中是单调递增的。

revision 是集群状态的版本号，存储状态每一次更新（例如，写，删除，事务等）都会让 revision 值加 1。version 特指 etcd 键空间某个 key 从创建开始被修改的次数，即 KeyValue.Version。

#### 物理视图

etcd 将物理数据存储为一棵持久化 B+ 树中的键值对。为了高效，每个 revision 的存储状态都只包含相较于之前 revision 的增量。一个 revision 可能对应于树中的多个 key。

B+ 树中的键值对的 key 即 revision，revision 是一个 2 元组（main，sub），其中 main 是该 revision 的主版本号，sub 是同一 revision 的副版本号，其用于区分同一个 revision 的不同 key。B+ 树中的键值对的 value 包含了相对于之前 revision 的修改，即相对于之前 revision 的一个增量。

B+ 树按 key 的字典字节序进行排序。这样，etcd v3 对 revision 增量的范围查询（range query，即从某个 revision 到另一个 revision）会很快，因为我们已经记录了从一个特定 revision 到其他 revision 的修改量。etcd v3 的压缩操作会删除过时的键值对。

etcd v3 还在内存中维护一个基于 B 树的二级索引来加快对 key 的范围查询。该 B 树索引的 key是向用户暴露的 etcd v3 存储的 key，而该 B 树索引的 value 则是一个指向上文谈论的持久化 B+ 树的增量的指针。etcd v3 的压缩操作会删除指向 B 树索引的无效指针。

### v3 的 MVCC 实现

etcd v2 每一个 key 都只保留一个 value，所以数据库并不大，可以直接放到内存中。但是 etcd v3 实现了每一个 MVCC 以后 ，每一个 key 的 value 都会保存，即存在多个历史版本。对此一个自然的解决方案就是将数据存储在磁盘中。etcd v3 当前使用 BoltDB 将数据存储到磁盘中。

BoltDB 是 根据 Howard Chu 的 LMDB 项目开发的一个存粹的 Go 语言版的 key/value 存储。它的目标是为项目提供一个简单，高效，可嵌入式的，可序列化的键/值数据库，而不是要求像一个 MySQL 那样完整的数据库服务器。BoltDB 还是一个支持事务的键值存储 etcd 的事务就是基于 BoltDB 的事务实现的。

BoltDB 只提供简单的 key/value 存储，没有其他特性，也因此 BoltDB 可以做到代码精简，质量高，非常适合 yiBoltDB 为基础在其之上构建更加复杂的数据库功能。由于 BoltDB 的设计适合 "读多写少" 的场景。

etcd 在 BoltDB 中存储的 key 是 revision，value 是 etcd 自己的 key-value 组合，也就是说 etcd 会在 BoltDB 中保存每个版本，从而实现多版本机制。

revision 主要有两部分组成，第一部分是 main rev，每操作以此事务就加一第二部分是 sub rev，同一事务每进行以此操作就加 1。这样的实现方式带来的问题就是整个数据库会越来越大，最终超过磁盘容量。因此 MVCC 还需要定期删除老的版本，etcd 提供了命令行工具以及配置选项，供用户手动删除老版本数据操作为数据压缩。

了解了 etcd v3 的磁盘存储之后，可以看到想要从 BoltDB 查询数据，必须通过 revision，但是客户端都通过 key 来查询 value 的，所以 etcd v3 在内存中维护一个 kvindex，保存的就是 key 与 revision 的映射关系，用来加速查询。kvindex，是基于 Google 开源的 Golang的 B 树实现的，也就是前文提到的 etcd v3 在内存中维护的二级索引。这样客户端通过 key 来查询 value 时候，会先在 kvindex 中查询这个 key 的所有 revision，然后通过 revision 从这 BoltDB 中查询数据。

之前讲过，etcd v2的数据持久化机制是依靠定期做快照来实现的，即将内存中整个数据库都复制一份，然后序列化到磁盘，做快照会对磁盘造成较大的压力。而etcd v3实现了MVCC之后，数据是实时写入BoltDB数据库的，数据持久化其实已经分摊每次对key的写请求上了，因此etcd v3就不需要做快照了。

需要注意的是，etcd v3虽然不需要做快照，但是需要定期对数据库进行压缩，因为磁盘的容量是有限的，不可能保存key的所有历史版本的value。

### 为什么选择 BoltDB 作为底层的存储引擎

BoltDB 是基于 B 树和 mmap 的数据库，基本原理是用 mmap 将磁盘的 page 映射到内存的 page ，而操作系统是通过 COW (copy-on-write) 技术进行 page 管理，通过 COW 技术，系统可实现无锁的读写并发，但是无法 实现无锁的写写并发，这类数据库读性能超高，但写性能一般，因 此非常适合于 "读多写少" 的场景。同时 BoltDB 支持完全可序列化的ACID 事务。因此最适合作为 etcd 的底层存储引擎。