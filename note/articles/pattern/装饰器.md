# 装饰器

装饰模式（Decorator Pattern）是一种比较常见的模式，其定义如下：
`Attach additional responsibilities to an object dynamically keeping the same interface.Decorators provide a flexible alternative to subclassing for extending functionality.`
（动态地给一个对象添加一些额外的职责。就增加功能来说，装饰模式相比生成子类更为灵活。）

### 装饰器模式

装饰器模式由 4 个角色构成：

- Component 抽象构件

Component 是一个接口或者是抽象类，在装饰模式中，必然有一个最基本、最核心、最原始的接口或抽象类充当 Component 抽象构件用来定义我们最核心的对象。

- ConcreteComponent 具体构件

ConcreteComponent 是最核心、最原始、最基本的接口或抽象类的实现，要装饰的就是它。

- Decorator 装饰角色

一般是一个抽象类，做什么用呢？实现接口或者抽象方法，它里面可不一定有抽象的方法呀，在它的属性里必然有一个 private 变量指向 Component 抽象构件。

- ConcreteDecorator 具体装饰角色

ConcreteDecorator 是具体的装饰类。

通用类图如下：

<div align="left">
    <img src="https://github.com/lazecoding/Note/blob/main/images/pattern/装饰器模式通用类图.png" width="600px">
</div>

示例代码如下：

- 抽象构件

````java
public abstract class Component {
    /**
     * 抽象方法
     */
    public abstract void operate();
}
````

- 具体构件

````java
public class ConcreteComponent extends Component{
    @Override
    public void operate() {
        System.out.println("ConcreteComponent Something ...");
    }
}
````

- 装饰角色

````java
public abstract class Decorator extends Component {
    private Component component = null;

    /**通过构造函数传递被修饰者
     *
     * @param _component
     */
    public Decorator(Component _component){
        this.component = _component;
    }
    //

    /**
     * 委托给被修饰者执行
     */
    @Override
    public void operate() {
        this.component.operate();
    }
}
````

- 具体装饰角色

````java
public class ConcreteDecorator1 extends Decorator {

    /**
     * 定义被修饰者
     *
     * @param _component
     */
    public ConcreteDecorator1(Component _component) {
        super(_component);
    }

    /**
     * 定义自己的修饰方法
     */
    private void method1() {
        System.out.println("method1 修饰");
    }

    @Override
    public void operate() {
        this.method1();
        super.operate();
    }
}

public class ConcreteDecorator2 extends Decorator {
    /**
     * 定义被修饰者
     * @param _component
     */
    public ConcreteDecorator2(Component _component) {
        super(_component);
    }

    /**
     * 定义自己的修饰方法
     */
    private void method2() {
        System.out.println("method2 修饰");
    }

    @Override
    public void operate() {
        super.operate();
        this.method2();
    }
}
````

- 场景类

````java
public class Client {
    public static void main(String[] args) {
        Component component = new ConcreteComponent();
        //第一次修饰
        component = new ConcreteDecorator1(component);
        //第二次修饰
        component = new ConcreteDecorator2(component);
        //修饰后运行
        component.operate();
    }
}
````