# 抽象工厂

抽象工厂模式（Abstract Factory Pattern）是一种比较常用的模式，其定义如下：
`Provide an interface for creating families of related or dependent objects without specifying their concrete classes.`
（为创建一组相关或相互依赖的对象提供一个接口，而且无须指定它们的具体类。）

### 抽象工厂模式

抽象工厂模式创建的是对象家族，也就是很多对象而不是一个对象，并且这些对象是相关的，也就是说必须一起创建出来。而工厂方法模式只是用于创建一个对象，这和抽象工厂模式有很大不同。

抽象工厂模式用到了工厂方法模式来创建单一对象，AbstractFactory 中的 createProductA() 和 createProductB() 方法都是让子类来实现，这两个方法单独来看就是在创建一个对象，这符合工厂方法模式的定义。

至于创建对象的家族这一概念是在 Client 体现，Client 要通过 AbstractFactory 同时调用两个方法来创建出两个对象，在这里这两个对象就有很大的相关性，Client 需要同时创建出这两个对象。

从高层次来看，抽象工厂使用了组合，即 Cilent 组合了 AbstractFactory，而工厂方法模式使用了继承。

通用类图如下：

<div align="left">
    <img src="https://github.com/lazecoding/Note/blob/main/images/pattern/抽象工厂模式通用类图.png" width="600px">
</div>

示例代码如下：

- 抽象产品 A

```java
public class AbstractProductA {
}
```

- 抽象产品 B

```java
public class AbstractProductB {
}
```

- 具体产品 A1

```java
public class ProductA1 extends AbstractProductA {
}
```

- 具体产品 A2

```java
public class ProductA2 extends AbstractProductA {
}
```

- 具体产品 B1

```java
public class ProductB1 extends AbstractProductB {
}
```

- 具体产品 B2

```java
public class ProductB2 extends AbstractProductB {
}
```

- 抽象工厂

```java
public abstract class AbstractFactory {
    abstract AbstractProductA createProductA();
    abstract AbstractProductB createProductB();
}
```

- 具体工厂 ConcreteFactory1

````java
public class ConcreteFactory1 extends AbstractFactory {
    AbstractProductA createProductA() {
        return new ProductA1();
    }

    AbstractProductB createProductB() {
        return new ProductB1();
    }
}
````

- 具体工厂 ConcreteFactory2

````java
public class ConcreteFactory2 extends AbstractFactory {
    AbstractProductA createProductA() {
        return new ProductA2();
    }

    AbstractProductB createProductB() {
        return new ProductB2();
    }
}
````

- 场景类

````java
public class Client {
    public static void main(String[] args) {
        AbstractFactory abstractFactory = new ConcreteFactory1();
        AbstractProductA productA = abstractFactory.createProductA();
        AbstractProductB productB = abstractFactory.createProductB();
        // do something with productA and productB
    }
}
````

在场景类中，没有任何一个方法与实现类有关系，对于一个产品来说，我们只要知道它的工厂方法就可以直接产生一个产品对象，无须关心它的实现类。