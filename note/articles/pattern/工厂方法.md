# 工厂方法

工厂方法模式使用的频率非常高，在我们日常的开发中总能见到它的身影。其定义为：
`Define an interface for creating an object,but let subclasses decide which class to instantiate.Factory Method lets a class defer instantiation to subclasses.`
（定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。）

### 工厂方法模式

在工厂方法模式中，抽象产品类 Product 负责定义产品的共性，实现对事物最抽象的定义；Creator 为抽象创建类，也就是抽象工厂，具体如何创建产品类是由具体的实现工厂 ConcreteCreator 完成的。

通用类图如下：

<div align="left">
    <img src="https://github.com/lazecoding/Note/blob/main/images/pattern/工厂方法模式通用类图.png" width="400px">
</div>

抽象产品类代码如下：

- 抽象产品类

```java
public abstract class Product {
    // 产品类的公共方法
    public void method1(){
        // 业务逻辑处理
    }
    // 抽象方法
    public abstract void method2();
}
```
具体的产品类可以有多个，都继承于抽象产品类。

- 具体产品类

```java
public class ConcreteProduct1 extends Product  {
    @Override
    public void method2() {
        // 业务逻辑处理
    }
}
```

抽象工厂类负责定义产品对象的产生。

- 抽象工厂类

```java
public abstract class Factory {
    /*
     * 创建一个产品对象，其输入参数类型可以自行设置
     * 通常为 String、Enum、Class等，当然也可以为空
     */
    public abstract <T extends Product> T createProduct(Class<T> c);
}
```

具体如何产生一个产品的对象，是由具体的工厂类实现的。

- 具体工厂类

```java
public class ConcreteFactory extends Factory {
    @Override
    public <T extends Product> T createProduct(Class<T> c) {
        Product product = null;
        try {
            product = (Product) Class.forName(c.getName()).newInstance();
        } catch (Exception e) {
            // 异常处理
        }
        return (T) product;
    }
}
```

- 场景类

```java
public class Client {
    public static void main(String[] args) {
        Factory creator = new ConcreteFactory();
        Product product = creator.createProduct(ConcreteProduct1.class);
        System.out.println(product);
        /*
         * 继续业务处理
         */
    }
}
```

### 