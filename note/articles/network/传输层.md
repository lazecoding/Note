# 传输层

传输层位于应用层和网络层之间，主要负责向两个主机中进程之间的通信提供服务。传输层协议是在端系统中而不是在路由器中实现的。在发送端，传输层将发送应用程序接收到的报文转换成传输层分组，即`报文段`，
每个报文段都包含一个传输层首部标识。然后，在发送端系统中，传输层将这些报文段传递给网络层，网络层将其封装成网络层分组（即数据报），并向目的地发送。在接收端，网络层从数据报中提取传输层报文段，
并将该报文段向上交给传输层。传输层则处理接收到的报文段，使该报文段中数据可以由接收应用进程使用。

### 套接字

传输层协议将由网络层提供的主机到主机的服务延申到主机上进程到进程的交付服务。一个进程可以拥有一个或者多个套接字（socket），它相当于从网络向进程传递数据和向网络传递数据的门户。
进程与进程通信，其实并不是直接将数据交付给对方进程，而且通过一个中间的套接字进行交付数据的。每个套接字都有唯一的标识，标识符的格式取决于它是 UDP 还是 TCP 套接字。

socket 并不是一种协议，而是为方便直接使用更底层协议而存在的一个抽象层。socket 和 TCP/IP 协议也没有必然联系，只是用 TCP/IP 协议栈更方便而已。所以 socket 是对 TCP/IP 协议的封装，
它是一组接口，把复杂的 TCP/IP 协议族隐藏在 socket 接口后面。

以 UDP 和 TCP 为例，这两种协议的套接字也是有区别的。

一个 UDP 套接字是由一个二元组标识的，该二元组包含一个目的 IP 地址和一个目的端口号。因此，如果两个 UDP 报文段有不同的源 IP 地址或源端口号，但具有相同的目的 IP 地址和目的端口号，
那么这两个报文段将通过相同的套接字被定向到相同的进程。

一个 TCP 套接字是由一个四元组标识的，该四元组包含源 IP 地址、源端口号、目的 IP 地址、目的端口号。这样，当一个 TCP 报文段从网络到达一个主机时，该主机使用四元组来将报文定向到对应的套接字。

### 传输层协议

传输层中最为常见的两个协议分别是 UDP（User Datagram Protocol，用户数据报协议） 和 TCP（Transmission Control Protocol，传输控制协议 ）。UDP 提供的是一种不可靠、面向无连接的服务，
TCP 为应用程序提供了一种可靠的、面向连接的服务。UDP 和 TCP 的最基本责任是，将两个端系统间 IP 交付服务扩展为运行在端系统上的两个进程之间的交付服务。

网络层为传输层提供服务，网络层的 IP （即网际协议）协议与传输层联系比较紧密。IP 为主机之间提供了逻辑通信，IP 的服务模型是尽力而为的交付服务，这意味着 IP 尽它最大努力在通信主机之间交付报文段，
但不做任何确保。如不确保报文段是否交付，不保证报文段按序交付，不保证报文段中数据的完整性。因此，IP 被称为不可靠服务。

socket 是对传输层协议（如 UDP、TCP）的封装，而传输层协议无非就是对网络层协议增加分解和聚合功能而已（分解、聚合就从 IP 维度细化到端口的维度，网络层只提供了 IP 协议，传输层细化到端口）。

#### UDP 协议

UDP 是面向无连接的协议，它只做了运输协议最基本的工作，处理聚合/分解功能以及少量的差错检测外，它基本没有对 IP 增加别的东西。基本上，应用进程使用 UDP 差不多就直接和 IP 打交道。
即使是出现网络拥堵的情况，UDP 也无法进行浏览控制等避免网络阻塞的行为，发送丢包 UDP 也不会负责重发，数据包乱序也不负责纠正。

UDP 从应用进程得到数据，附加上源和目的 IP、端口，以及其他两个小字段，形成报文段交给网络层。网络层将传输层报文封装到一个 IP 数据报中，然后尽力而为地将报文段中数据交付给目的应用程序。
一个 UDP 请求是不需要建立连接地，发送端和目的端也不需要进行 "握手"，也因此 UDP 被称为面向无连接的协议。

UDP 面向无连接，可以随时发送数据，而且 UDP 没有复杂的机制，往往用于以下几个方面：

- 包总量较少的通信（DNS、SNMP 等）。
- 视频、音频等多媒体通信（即时通讯）。
- 限定于 LAN 等特定网络中的应用通信。
- 广播通信（广播、多播）

#### TCP 协议

TCP 是面向连接的协议，这是因为一个应用程序在向另一个应用程序发送数据之前，两个应用程序必须先相互 "握手"，即它们必须互相发送某些预备报文段，以建立确保数据传输的参数。
作为 TCP 连接建立的一部分，连接双方都将初始化与 TCP 连接的相关状态变量。

为什么说 TCP 是面向连接，是因为 TCP 的 "连接" 并不像电路交换一样真正地建立了一条端到端地连接。TCP 协议至少再端系统中运行，中间网络设备并不维持 TCP 连接状态。实际上，路由器对 TCP 连接毫无反应，
他们看到地至少数据报，而不是连接。

TCP 提供的是全双工服务，即两个端系统建立 TCP 连接，他们可以同时互相收发数据。TCP 连接总是`点对点`的，即单一发送端和电一接收端之间的连接。

##### 建立 TCP 连接

建立 TCP 连接需要经过 "三次握手" 的过程，三次握手是指建立一个 TCP 连接时，需要客户端和服务器总共发送三个包，目的是连接服务器指定端口，建立 TCP 连接，并同步连接双方的序列号和确认号，交换 TCP 窗口大小信息。

<div align="left">
    <img src="https://github.com/lazecoding/Note/blob/main/images/network/TCP三次握手.png" width="600px">
</div>

- 第一次握手(SYN=1, seq=x):

客户端发送一个 TCP 的 SYN 标志位置 1 的包，指明客户端打算连接的服务器的端口，以及初始序号 X,保存在包头的序列号(Sequence Number)字段里。

发送完毕后，客户端进入 `SYN_SEND` 状态。

- 第二次握手(SYN=1, ACK=1, seq=y, ACKnum=x+1):

服务器发回确认包(ACK)应答。即 SYN 标志位和 ACK 标志位均为 1。服务器端选择自己 ISN 序列号，放到 Seq 域里，同时将确认序号(Acknowledgement Number)设置为客户的 ISN 加 1，即 X+1。 发送完毕后，服务器端进入 `SYN_RCVD` 状态。

- 第三次握手(ACK=1，ACKnum=y+1)

客户端再次发送确认包(ACK)，SYN 标志位为 0，ACK 标志位为 1，并且把服务器发来 ACK 的序号字段 +1，放在确定字段中发送给对方，并且在数据段放写 ISN 的 +1

发送完毕后，客户端进入 `ESTABLISHED` 状态，当服务器端接收到这个包时，也进入 `ESTABLISHED` 状态，TCP 握手结束。

##### 通过 TCP 发送数据

一旦建立起一条 TCP 连接，两个应用进程之间就可以互相发送数据了。

发送端通过套接字传递数据流，TCP 将这些数据引导入该连接的`发送缓存`，TCP 从缓存中取出数据组织报文段。TCP 为每个报文段都配上了一个 TCP 首部，从而形成 `TCP 报文段`。
这些报文段被下传给网络层，网络层将其封装在网络层 IP 数据包中，然后这些数据包被发送到网络中。当接收端接收到报文段，该 TCP 报文段就会被放入该 TCP 连接的`接收缓存`中,应用程序从缓存中读取数据流。

TCP 报文段结构：

<div align="left">
    <img src="https://github.com/lazecoding/Note/blob/main/images/network/TCP报文段结构.png" width="600px">
</div>

- `源端口号`：发送端端口号，16 位。
- `目标端口号`：接收端端口号，16 位。
- `序列号`：32 位，指发送数据的位置，每发送一次数据回家累加一次该数据字节数大小。
- `确认应答号`：32 位，指下一次应该收到的数据的序列号。
- `数据偏移`：4 位，表示该报文段数据部分应该从哪一位开始计算，其实就是首部的大小。
- `保留`：未用。
- `控制位`：8 位，存储控制标识，从左到右分别是 CWR、ECE、URC、ACK、PSH、RST、SYN、FIN。
- `窗口大小`：16 位，用于通知从相同 TCP 首部的确认应答号所指位置开始能接收的数据大小。
- `校验和`：接收端接收到 TCP 数据包，从 IP 首部获取 IP 信息构造 TCP 伪首部，再进行校验和计算。由于校验和字段里保存着除本字段外其他部分的和的补码，因此计算校验和字段在内的所有数据的 16 位的结构是 "16 位全是 1" 说明数据是正确的。
- `紧急指针`：16 位，只有再 URG 控制位位 1 时有效，表示本报文段中紧急数据的指针。
- `选项`：该字段用于发送端和接收端协商报文段属性。
- `填充`：即填充。
- `数据`：数据实体，除去 TCP 首部的部分。

控制标识含义：

CWR、ECE、URC、ACK、PSH、RST、SYN、FIN

##### 断开 TCP 连接

断开 TCP 连接需要发送四个包，因此称为四次挥手(Four-way handshake)。客户端或服务器均可主动发起挥手动作，在 socket 编程中，任何一方执行 close() 操作即可产生挥手操作。

<div align="left">
    <img src="https://github.com/lazecoding/Note/blob/main/images/network/TCP四次挥手.png" width="600px">
</div>

- 第一次挥手(FIN=1，seq=x)：

假设客户端想要关闭连接，客户端发送一个 FIN 标志位置为 1 的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。

发送完毕后，客户端进入 `FIN_WAIT_1` 状态。

- 第二次挥手(ACK=1，ACKnum=x+1)：

服务器端确认客户端的 FIN 包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接。

发送完毕后，服务器端进入 `CLOSE_WAIT` 状态，客户端接收到这个确认包之后，`进入 FIN_WAIT_2` 状态，等待服务器端关闭连接。

- 第三次挥手(FIN=1，seq=y)：

服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为 1。

发送完毕后，服务器端进入 `LAST_ACK` 状态，等待来自客户端的最后一个 ACK。

- 第四次挥手(ACK=1，ACKnum=y+1)：

客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 TIME_WAIT状态，等待可能出现的要求重传的 ACK 包。

服务器端接收到这个确认包之后，关闭连接，进入 `CLOSED` 状态。

客户端等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 `CLOSED` 状态。


### UDP

#### UDP 报文段结构

#### UDP 校验和


### TCP






