# 传输层

- 目录
    - [套接字](#套接字)
    - [传输层协议](#传输层协议)
        - [UDP 协议](#UDP-协议)
            - [UDP 报文段结构](#UDP-报文段结构)
            - [UDP 校验和](#UDP-校验和)
        - [TCP 协议](#TCP-协议)
            - [TCP 报文段结构](#TCP-报文段结构)
            - [建立 TCP 连接](#建立-TCP-连接)
            - [通过 TCP 发送数据](#通过-TCP-发送数据)
            - [断开 TCP 连接](#断开-TCP-连接)
            - [SYN 攻击](#SYN-攻击)
            - [TCP 可靠传输](#TCP-可靠传输)
            - [TCP 滑动窗口](#TCP-滑动窗口)
            - [TCP KeepAlive](#TCP-KeepAlive)

传输层位于应用层和网络层之间，主要负责向两个主机中进程之间的通信提供服务。传输层协议是在端系统中而不是在路由器中实现的。在发送端，传输层将发送应用程序接收到的报文转换成传输层分组，即`报文段`，每个报文段都包含一个传输层首部标识。然后，在发送端系统中，传输层将这些报文段传递给网络层，网络层将其封装成网络层分组（即数据报），并向目的地发送。在接收端，网络层从数据报中提取传输层报文段，并将该报文段向上交给传输层。传输层则处理接收到的报文段，使该报文段中数据可以由接收应用进程使用。

### 套接字

传输层协议将由网络层提供的主机到主机的服务延申到主机上进程到进程的交付服务。一个进程可以拥有一个或者多个套接字（socket），它相当于从网络向进程传递数据和向网络传递数据的门户。进程与进程通信，其实并不是直接将数据交付给对方进程，而且通过一个中间的套接字进行交付数据的。每个套接字都有唯一的标识，标识符的格式取决于它是 UDP 还是 TCP 套接字。

socket 并不是一种协议，而是为方便直接使用更底层协议而存在的一个抽象层。socket 和 TCP/IP 协议也没有必然联系，只是用 TCP/IP 协议栈更方便而已。所以 socket 是对 TCP/IP 协议的封装，它是一组接口，把复杂的 TCP/IP 协议族隐藏在 socket 接口后面。

以 UDP 和 TCP 为例，这两种协议的套接字也是有区别的。

一个 UDP 套接字是由一个二元组标识的，该二元组包含一个目的 IP 地址和一个目的端口号。因此，如果两个 UDP 报文段有不同的源 IP 地址或源端口号，但具有相同的目的 IP 地址和目的端口号，那么这两个报文段将通过相同的套接字被定向到相同的进程。

一个 TCP 套接字是由一个四元组标识的，该四元组包含源 IP 地址、源端口号、目的 IP 地址、目的端口号。这样，当一个 TCP 报文段从网络到达一个主机时，该主机使用四元组来将报文定向到对应的套接字。

### 传输层协议

传输层中最为常见的两个协议分别是 UDP（User Datagram Protocol，用户数据报协议） 和 TCP（Transmission Control Protocol，传输控制协议 ）。UDP 提供的是一种不可靠、面向无连接的服务，TCP 为应用程序提供了一种可靠的、面向连接的服务。UDP 和 TCP 的最基本责任是，将两个端系统间 IP 交付服务扩展为运行在端系统上的两个进程之间的交付服务。

网络层为传输层提供服务，网络层的 IP （即网际协议）协议与传输层联系比较紧密。IP 为主机之间提供了逻辑通信，IP 的服务模型是尽力而为的交付服务，这意味着 IP 尽它最大努力在通信主机之间交付报文段，但不做任何确保。如不确保报文段是否交付，不保证报文段按序交付，不保证报文段中数据的完整性。因此，IP 被称为不可靠服务。

socket 是对传输层协议（如 UDP、TCP）的封装，而传输层协议无非就是对网络层协议增加分解和聚合功能而已（分解、聚合就从 IP 维度细化到端口的维度，网络层只提供了 IP 协议，传输层细化到端口）。

#### UDP 协议

UDP 是面向无连接的协议，它只做了运输协议最基本的工作，处理聚合/分解功能以及少量的差错检测外，它基本没有对 IP 增加别的东西。基本上，应用进程使用 UDP 差不多就直接和 IP 打交道。即使是出现网络拥堵的情况，UDP 也无法进行浏览控制等避免网络阻塞的行为，发送丢包 UDP 也不会负责重发，数据包乱序也不负责纠正。

UDP 从应用进程得到数据，附加上源和目的 IP、端口，以及其他两个小字段，形成报文段交给网络层。网络层将传输层报文封装到一个 IP 数据报中，然后尽力而为地将报文段中数据交付给目的应用程序。一个 UDP 请求是不需要建立连接地，发送端和目的端也不需要进行 "握手"，也因此 UDP 被称为面向无连接的协议。

UDP 面向无连接，可以随时发送数据，而且 UDP 没有复杂的机制，往往用于以下几个方面：

- 包总量较少的通信（DNS、SNMP 等）。
- 视频、音频等多媒体通信（即时通讯）。
- 限定于 LAN 等特定网络中的应用通信。
- 广播通信（广播、多播）

##### UDP 报文段结构

UDP 报文段结构：

<div align="left">
    <img src="https://github.com/lazecoding/Note/blob/main/images/network/UDP报文段结构.png" width="600px">
</div>

- `源端口号`：发送端端口号，16 位。
- `目标端口号`：接收端端口号，16 位。
- `包长度`：8 位，保存了 UDP 首部长度和数据长度之和。
- `校验和`：校验接收的数据数据释放正确。
- `数据`：数据实体，除去 UDP 首部的部分。

##### UDP 校验和

为了计算校验和，设计了一个伪首部。伪首部是一个虚拟的数据结构，其中的信息是从数据报所在IP分组头的分组头中提取的，既不向下传送也不向上递交，而仅仅是为计算校验和。

在发送方，首先是先把全零放入检验和字段。再把伪首部以及 UDP 用户数据报看成是由许多 16 位的字串接起来。若 UDP 用户数据报的数据部分不是偶数个字节，则要填入一个全零字节（但此字节不发送）。然后按二进制反码计算出这些 16 位字的和。将此和的二进制反码写入检验和字段后，就发送这样的 UDP 用户数据报。在接收方，把收到的 UDP 用户数据报连同伪首部（以及可能的填充全零字节）一起，按二进制反码求这些16位字的和。当无差错时其结果应为全 1（"二进制反码求和" 等价于 "二进制求和再取反"）。

这样的检验和，既检查了 UDP 用户数据报的源端口号和目的端口号以及 UDP 用户数据报的数据部分，又检查了 IP 数据报的源 IP 地址和目的地址。

但是相等只代表我们没有检测出错误，但其实可能有错误，比如有 2 个位发生翻转的情况就检测不出来。

#### TCP 协议

TCP 是面向连接的协议，这是因为一个应用程序在向另一个应用程序发送数据之前，两个应用程序必须先相互 "握手"，即它们必须互相发送某些预备报文段，以建立确保数据传输的参数。作为 TCP 连接建立的一部分，连接双方都将初始化与 TCP 连接的相关状态变量。

为什么说 TCP 是面向连接，是因为 TCP 的 "连接" 并不像电路交换一样真正地建立了一条端到端的连接。TCP 协议只是在端系统中运行，中间网络设备并不维持 TCP 连接状态。实际上，路由器对 TCP 连接毫无反应，他们看到的只是数据报，而不是连接。

TCP 提供的是全双工服务，即两个端系统建立 TCP 连接，他们可以同时互相收发数据。TCP 连接总是`点对点`的，即单一发送端和单一接收端之间的连接。

##### TCP 报文段结构

TCP 报文段结构：

<div align="left">
    <img src="https://github.com/lazecoding/Note/blob/main/images/network/TCP报文段结构.png" width="600px">
</div>

- `源端口号`：发送端端口号，16 位。
- `目标端口号`：接收端端口号，16 位。
- `序列号`：32 位，指发送数据的位置，每发送一次数据回家累加一次该数据字节数大小。
- `确认应答号`：32 位，指下一次应该收到的数据的序列号。
- `数据偏移`：4 位，表示该报文段数据部分应该从哪一位开始计算，其实就是首部的大小。
- `保留`：未用。
- `控制位`：8 位，存储控制标识，从左到右分别是 CWR、ECE、URC、ACK、PSH、RST、SYN、FIN。
- `窗口大小`：16 位，用于通知从相同 TCP 首部的确认应答号所指位置开始能接收的数据大小。
- `校验和`：接收端接收到 TCP 数据包，从 IP 首部获取 IP 信息构造 TCP 伪首部，再进行校验和计算。由于校验和字段里保存着除本字段外其他部分的和的补码，因此计算校验和字段在内的所有数据的 16 位的结构是 "16 位全是 1" 说明数据是正确的。
- `紧急指针`：16 位，只有在 URG 控制位为 1 时有效，表示本报文段中紧急数据的指针。
- `选项`：该字段用于发送端和接收端协商报文段属性。
- `填充`：即填充。
- `数据`：数据实体，除去 TCP 首部的部分。

<!-- 
控制标识含义：

CWR、ECE、URC、ACK、PSH、RST、SYN、FIN
-->

##### 建立 TCP 连接

建立 TCP 连接需要经过 "三次握手" 的过程，三次握手是指建立一个 TCP 连接时，需要客户端和服务器总共发送三个包，目的是连接服务器指定端口，建立 TCP 连接，并同步连接双方的序列号和确认号，交换 TCP 窗口大小信息。

<div align="left">
    <img src="https://github.com/lazecoding/Note/blob/main/images/network/TCP三次握手.png" width="600px">
</div>

- 第一次握手(SYN=1, seq=x):

客户端发送一个 TCP 的 SYN 标志位置 1 的包，指明客户端打算连接的服务器的端口，以及初始序号 X,保存在包头的序列号(Sequence Number)字段里。

发送完毕后，客户端进入 `SYN_SEND` 状态。

- 第二次握手(SYN=1, ACK=1, seq=y, ACKnum=x+1):

服务器发回确认包(ACK)应答。即 SYN 标志位和 ACK 标志位均为 1。服务器端选择自己 ISN 序列号，放到 Seq 域里，同时将确认序号(Acknowledgement Number)设置为客户的 ISN 加 1，即 X+1。 发送完毕后，服务器端进入 `SYN_RCVD` 状态。

- 第三次握手(ACK=1，ACKnum=y+1)

客户端再次发送确认包(ACK)，SYN 标志位为 0，ACK 标志位为 1，并且把服务器发来 ACK 的序号字段 +1，放在确定字段中发送给对方，并且在数据段放写 ISN 的 +1

发送完毕后，客户端进入 `ESTABLISHED` 状态，当服务器端接收到这个包时，也进入 `ESTABLISHED` 状态，TCP 握手结束。

##### 通过 TCP 发送数据

一旦建立起一条 TCP 连接，两个应用进程之间就可以互相发送数据了。

发送端通过套接字传递数据流，TCP 将这些数据引导入该连接的`发送缓存`，TCP 从缓存中取出数据组织报文段。TCP 为每个报文段都配上了一个 TCP 首部，从而形成 `TCP 报文段`。这些报文段被下传给网络层，网络层将其封装在网络层 IP 数据包中，然后这些数据包被发送到网络中。当接收端接收到报文段，该 TCP 报文段就会被放入该 TCP 连接的`接收缓存`中,应用程序从缓存中读取数据流。

##### 断开 TCP 连接

断开 TCP 连接需要发送四个包，因此称为四次挥手(Four-way handshake)。客户端或服务器均可主动发起挥手动作，在 socket 编程中，任何一方执行 close() 操作即可产生挥手操作。

<div align="left">
    <img src="https://github.com/lazecoding/Note/blob/main/images/network/TCP四次挥手.png" width="600px">
</div>

- 第一次挥手(FIN=1，seq=x)：

假设客户端想要关闭连接，客户端发送一个 FIN 标志位置为 1 的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。

发送完毕后，客户端进入 `FIN_WAIT_1` 状态。

- 第二次挥手(ACK=1，ACKnum=x+1)：

服务器端确认客户端的 FIN 包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接。

发送完毕后，服务器端进入 `CLOSE_WAIT` 状态，客户端接收到这个确认包之后，`进入 FIN_WAIT_2` 状态，等待服务器端关闭连接。

- 第三次挥手(FIN=1，seq=y)：

服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为 1。

发送完毕后，服务器端进入 `LAST_ACK` 状态，等待来自客户端的最后一个 ACK。

- 第四次挥手(ACK=1，ACKnum=y+1)：

客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 TIME_WAIT状态，等待可能出现的要求重传的 ACK 包。

服务器端接收到这个确认包之后，关闭连接，进入 `CLOSED` 状态。

客户端等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 `CLOSED` 状态。

##### SYN 攻击

在三次握手过程中，服务器发送 SYN-ACK 之后，收到客户端的 ACK 之前的 TCP 连接称为半连接(half-open connect)。此时服务器处于 SYN_RCVD 状态。当收到 ACK 后，服务器才能转入 ESTABLISHED 状态.

SYN 攻击指的是，攻击客户端在短时间内伪造大量不存在的 IP 地址，向服务器不断地发送 SYN 包，服务器回复确认包，并等待客户的确认。由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造的 SYN 包将长时间占用未连接队列，正常的 SYN 请求被丢弃，导致目标系统运行缓慢，严重者会引起网络堵塞甚至系统瘫痪。SYN 攻击是一种典型的 DoS/DDoS 攻击。

检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源 IP 地址是随机的，基本上可以断定这是一次 SYN 攻击。在 Linux/Unix 上可以使用系统自带的 netstats 命令来检测 SYN 攻击。

SYN 攻击不能完全被阻止，我们所做的是尽可能的减轻 SYN 攻击的危害，常见的防御 SYN 攻击的方法有如下几种：

- 缩短超时（SYN Timeout）时间
- 增加最大半连接数
- 过滤网关防护
- SYN cookies 技术

##### TCP 可靠传输

在 TCP 中，当发送端的数据到达接收端主机时，接收端主机会返回一个已收到的消息通知，这个消息叫确认应答（ACK）。TCP 通过 ACK 机制实现可靠数据传输。当发送端将数据发出会等待接收端的确认应答，如果有确认应答说明数据成功到达接收端，反之，数据很可能（是可能，如 ACK 丢失）丢失。在一定时间内没有等到 ACK，发送端就认为数据已经丢失，并进行重发。故即使产生了丢包，仍然能够保证数据到达对接收端，实现数据的可靠传输。

##### TCP 滑动窗口

如果 TCP 以报文段为单位进行数据传输，每发一个段进行一次确认应答。这样的传输方式有一个缺点，即包的往返时间越长，通信性能越差，网络的吞吐量越低。

<div align="left">
    <img src="https://github.com/lazecoding/Note/blob/main/images/network/TCP每段ACK缺点.png" width="600px">
</div>

为了解决上述问题，TCP 引入了`滑动窗口`。引入了滑动窗口，确认应答不再是以段为单位，而是以更大的单位进行确认，这个单位是`窗口大小`。

<div align="left">
    <img src="https://github.com/lazecoding/Note/blob/main/images/network/TCP滑动窗口ACK.png" width="600px">
</div>

窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。

发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。

接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。

<div align="left">
    <img src="https://github.com/lazecoding/Note/blob/main/images/network/TCP滑动窗口案例.png" width="600px">
</div>

举几类例子：

- 正常滑动窗口通信

<div align="left">
    <img src="https://github.com/lazecoding/Note/blob/main/images/network/正常滑动窗口通信.png" width="600px">
</div>

- 窗口大小的动态调整

<div align="left">
    <img src="https://github.com/lazecoding/Note/blob/main/images/network/窗口大小的动态调整.png" width="600px">
</div>

- 0大小窗口通信

<div align="left">
    <img src="https://github.com/lazecoding/Note/blob/main/images/network/0大小窗口通信.png" width="600px">
</div>

##### TCP KeepAlive

TCP 的连接，实际上是一种纯软件层面的概念，在物理层面并没有“连接”这种概念。TCP 通信双方建立交互的连接，但是并不是一直存在数据交互，有些连接会在数据交互完毕后，主动释放连接，而有些不会。在长时间无数据交互的时间段内，交互双方都有可能出现掉电、死机、异常重启等各种意外，当这些意外发生之后，这些 TCP 连接并未来得及正常释放，在软件层面上，连接的另一方并不知道对端的情况，它会一直维护这个连接，长时间的积累会导致非常多的半打开连接，造成端系统资源的消耗和浪费，为了解决这个问题，在传输层可以利用 TCP 的 KeepAlive 机制实现来实现。主流的操作系统基本都在内核里支持了这个特性。

TCP KeepAlive 的基本原理是，隔一段时间给连接对端发送一个探测包，如果收到对方回应的 ACK，则认为连接还是存活的，在超过一定重试次数之后还是没有收到对方的回应，则丢弃该 TCP 连接。

TCP-Keepalive-HOWTO 有对 TCP KeepAlive 特性的详细介绍，有兴趣的同学可以参考。这里主要说一下，TCP KeepAlive 的局限。首先 TCP KeepAlive 监测的方式是发送一个 probe 包，会给网络带来额外的流量，另外 TCP KeepAlive 只能在内核层级监测连接的存活与否，而连接的存活不一定代表服务的可用。例如当一个服务器 CPU 进程服务器占用达到 100%，已经卡死不能响应请求了，此时 TCP KeepAlive 依然会认为连接是存活的。因此 TCP KeepAlive 对于应用层程序的价值是相对较小的。需要做连接保活的应用层程序，例如 QQ，往往会在应用层实现自己的心跳功能。





