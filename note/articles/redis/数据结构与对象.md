# 数据结构与对象

Redis 是 NoSQL 数据库，它的每个键值对都是由对象组成的，其中键总是一个字符串对象（string object），值的可选类型有很多，其中比较常见有字符串对象、列表对象（list object）、哈希对象（hash object）、集合对象（set object）、有序集合对象（softed set object），此外还有一些后加入的对象类型。

### 数据结构

Redis 丰富的对象类型离不开底层数据结构的支持，本文将从数据结构开始分析。

#### 简单动态字符串

Redis 没有采用 C 语言传统的字符串，而是自己构建了一种名为简单动态字符串（SDS）的抽象结构。在 Redis 中包含字符串值的键值对在底层都是由 SDS 实现的，此外 SDS 还被用作缓冲区（buffer）：AOF缓冲区、客户端输入缓冲区。

SDS 结构：

```C
struct sdshdr {

    // 记录 buf 数组中已使用字节的数量, 不包括 '\0' 的长度
    // 等于 SDS 所保存字符串的长度
    int len;

    // 记录 buf 数组中未使用字节的数量
    int free;

    // 字节数组，用于保存字符串
    // 　buf[] 除了保存字符串的字符外, 还会在末尾保存一个空字符 '\0' , 空字符不计算在 len 属性之中
    char buf[];

};
```

SDS 和 C 字符串相比，C 字符串不记录自身长度，所以获取一个 C 字符串长度需要遍历整个字符串，而 SDS 长度信息保存在 len 属性中，由 SDS API 自身维护，可以快速获取字符串长度。C 字符串不记录自身长度带来的另一个问题是容易造成缓冲区溢出，但 SDS 记录了字符串长度和空闲长度，SDS 修改 API 会先检查 SDS 空间是否满足修改要求，因此杜绝了缓冲区溢出问题。
还是由于 C 字符串不记录长度，C 字符串底层实现总是一个 N+1 个字符长度的数组，所以每次增长或缩短一个 C 字符串程序总要对这个 C 字符串数组内存再分配。SDS 因为存储了字符长度，所以可以实现空间预分配，避免了内存空间频繁再分配，而且 SDS 字符串缩短操作空间是惰性释放的，程序不会立即回收内存，也在一定程度上避免内存频繁再分配。
SDS 还有一个重要的特性是二进制安全，SDS 所有的 API 都会以处理二进制的方式来处理 SDS 存放在 buf 数组里的数据，程序不会对其中的数据做任何限制、过滤、或者假设，数据在写入时是什么样的，它被读取时就是什么样。

#### 链表
#### 字典
#### 跳跃表
#### 整数集合
#### 压缩列表


### 对象类型