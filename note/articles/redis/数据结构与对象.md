# 数据结构与对象

Redis 是 NoSQL 数据库，它的每个键值对都是由对象组成的，其中键总是一个字符串对象（string object），值的可选类型有很多，其中比较常见有字符串对象、列表对象（list object）、哈希对象（hash object）、集合对象（set object）、有序集合对象（softed set object），此外还有一些后加入的对象类型。

### 数据结构

Redis 丰富的对象类型离不开底层数据结构的支持，本文将从数据结构开始分析。

#### 简单动态字符串

Redis 没有采用 C 语言传统的字符串，而是自己构建了一种名为简单动态字符串（SDS）的抽象结构。在 Redis 中包含字符串值的键值对在底层都是由 SDS 实现的，此外 SDS 还被用作缓冲区（buffer）：AOF缓冲区、客户端输入缓冲区。

SDS 结构：

```C
struct sdshdr {

    // 记录 buf 数组中已使用字节的数量, 不包括 '\0' 的长度
    // 等于 SDS 所保存字符串的长度
    int len;

    // 记录 buf 数组中未使用字节的数量
    int free;

    // 字节数组，用于保存字符串
    // 　buf[] 除了保存字符串的字符外, 还会在末尾保存一个空字符 '\0' , 空字符不计算在 len 属性之中
    char buf[];

};
```

SDS 和 C 字符串相比，C 字符串不记录自身长度，所以获取一个 C 字符串长度需要遍历整个字符串，而 SDS 长度信息保存在 len 属性中，由 SDS API 自身维护，可以快速获取字符串长度。C 字符串不记录自身长度带来的另一个问题是容易造成缓冲区溢出，但 SDS 记录了字符串长度和空闲长度，SDS 修改 API 会先检查 SDS 空间是否满足修改要求，因此杜绝了缓冲区溢出问题。
还是由于 C 字符串不记录长度，C 字符串底层实现总是一个 N+1 个字符长度的数组，所以每次增长或缩短一个 C 字符串程序总要对这个 C 字符串数组内存再分配。SDS 因为存储了字符长度，所以可以实现空间预分配，避免了内存空间频繁再分配，而且 SDS 字符串缩短操作空间是惰性释放的，程序不会立即回收内存，也在一定程度上避免内存频繁再分配。
SDS 还有一个重要的特性是二进制安全，SDS 所有的 API 都会以处理二进制的方式来处理 SDS 存放在 buf 数组里的数据，程序不会对其中的数据做任何限制、过滤、或者假设，数据在写入时是什么样的，它被读取时就是什么样。

#### 链表

链表提供顺序访问和高效的节点重排能力，Redis 自己实现了一套双向链表。

链表节点（listNode）：

```C
typedef struct listNode {

    // 前置节点
    struct listNode *prev;

    // 后置节点
    struct listNode *next;

    // 节点的值
    void *value;

} listNode;
```

多个链表节点通过 prev 和 next 指针组成双向链表。

<div align="left">
    <img src="https://github.com/lazecoding/Note/blob/main/images/redis/多个listNode组成的双向链表.png" width="600px">
</div>

为了方便使用，Redis 通过 list 结构方便操作：

```C
typedef struct list {

    // 表头节点
    listNode *head;

    // 表尾节点
    listNode *tail;

    // 链表所包含的节点数量
    unsigned long len;

    // 节点值复制函数
    void *(*dup)(void *ptr);

    // 节点值释放函数
    void (*free)(void *ptr);

    // 节点值对比函数
    int (*match)(void *ptr, void *key);

} list;
```

<div align="left">
    <img src="https://github.com/lazecoding/Note/blob/main/images/redis/list结构和listNode结构组成的链表.png" width="600px">
</div>

Redis 链表实现的特性如下：
- 双端：链表节点带有 prev 和 next 指针， 获取某个节点的前置节点和后置节点的复杂度都是 O(1) 。
- 无环：表头节点的 prev 指针和表尾节点的 next 指针都指向 NULL ， 对链表的访问以 NULL 为终点。
- 带表头指针和表尾指针：通过 list 结构的 head 指针和 tail 指针， 程序获取链表的表头节点和表尾节点的复杂度为 O(1) 。
- 带链表长度计数器：程序使用 list 结构的 len 属性来对 list 持有的链表节点进行计数， 程序获取链表中节点数量的复杂度为 O(1) 。
- 多态：链表节点使用 void* 指针来保存节点值， 并且可以通过 list 结构的 dup 、 free 、 match 三个属性为节点值设置类型特定函数， 所以链表可以用于保存各种不同类型的值。

#### 字典

字典，又称映射（map），是一种存储键值对的抽象结构，再字典里，一个键可以和一个值关联，每个建在字典中都是独一无二的，Redis 也构建了自己的字典实现。Redis 的字典实现是哈希表，一个哈希表中包含多个哈希节点，每个节点保存着字典中的键值对。

哈希表（dictht）:

```C
typedef struct dictht {

    // 哈希表数组
    dictEntry **table;

    // 哈希表大小
    unsigned long size;

    // 哈希表大小掩码，用于计算索引值
    // 总是等于 size - 1
    unsigned long sizemask;

    // 该哈希表已有节点的数量
    unsigned long used;

} dictht;
```

table 是一个数组，数组中的每个元素都是一个指向 dictEntry 结构的指针，每个 dictEntry 结构保存着键值对。size 属性记录了哈希表的大小，即 table 数组的大小，used 属性则记录了哈希表目前已有节点（键值对）的数量。sizemask 属性的值总是等于 size - 1 ，这个属性和哈希值一起决定一个键应该被放到 table 数组的哪个索引上面。

哈希表节点（dictEntry）：

```C
typedef struct dictEntry {

    // 键
    void *key;

    // 值
    union {
        void *val;
        uint64_t u64;
        int64_t s64;
    } v;

    // 指向下个哈希表节点，形成链表
    struct dictEntry *next;

} dictEntry;
```

key 属性保存着键值对中的键，而 v 属性则保存着键值对中的值，其中键值对的值可以是一个指针，或者是一个 uint64_t 整数，又或者是一个 int64_t 整数。next 属性是指向另一个哈希表节点的指针，这个指针可以将多个哈希值相同的键值对连接在一次，以此来解决键冲突（collision）的问题。

<div align="left">
    <img src="https://github.com/lazecoding/Note/blob/main/images/redis/字典哈希表实现.png" width="600px">
</div>

字典（dict）：

```C
typedef struct dict {

    // 类型特定函数
    dictType *type;

    // 私有数据
    void *privdata;

    // 哈希表
    dictht ht[2];

    // rehash 索引
    // 当 rehash 不在进行时，值为 -1
    int rehashidx; /* rehashing not in progress if rehashidx == -1 */

} dict;
```

type 属性是一个指向 dictType 结构的指针，每个 dictType 结构保存了一簇用于操作特定类型键值对的函数，Redis 会为用途不同的字典设置不同的类型特定函数。privdata 属性则保存了需要传给那些类型特定函数的可选参数。ht 属性是一个包含两项的数组，数组中的每个项都是一个 dictht 哈希表，一般情况下，字典只使用 ht[0] 哈希表，ht[1] 哈希表只会在对 ht[0] 哈希表进行 rehash 时使用。

当一个新的键值对添加到字典中，需要根据键计算出哈希值和索引值，然后根据索引值将包含新键值对的哈希表节点放到哈希表数组的指定索引上。

```C
# 使用字典设置的哈希函数，计算键 key 的哈希值
hash = dict->type->hashFunction(key);

# 使用哈希表的 sizemask 属性和哈希值，计算出索引值
# 根据情况不同， ht[x] 可以是 ht[0] 或者 ht[1]
index = hash & dict->ht[x].sizemask;
```

<div align="left">
    <img src="https://github.com/lazecoding/Note/blob/main/images/redis/空字典.png" width="600px">
</div>

比上图字典来说将 <k0,v0> 添加到字典中，先会计算键 k0 的哈希值。

```C
hash = dict->type->hashFunction(k0);
```

假设计算得出的哈希值为 8 ，程序会继续使用语句：

```C
index = hash & dict->ht[0].sizemask = 8 & 3 = 0;
```

计算出键 k0 的索引值 0 ，这表示包含键值对 k0 和 v0 的节点应该被放置到哈希表数组的索引 0 位置上，如下图所示。

<div align="left">
    <img src="https://github.com/lazecoding/Note/blob/main/images/redis/添加键值对后的字典.png" width="600px">
</div>

将 Redis 发生键冲突，即哈希冲突，使用链地址法来解决键冲突：每个哈希表节点都有一个 next 指针，多个哈希表节点可以用 next 指针构成一个单向链表，被分配到同一个索引上的多个节点通过这个 next 指针连接起来。

前面提到 rehash，这是由于随着操作不断进行，哈希表存储的键值对或多或少，为了保证哈希的效率需要对哈希表进行扩容或收缩。扩展和收缩哈希表的工作可以通过执行 rehash （重新散列）操作来完成，Redis 对字典的哈希表执行 rehash 的步骤如下：
- 为字典的 ht[1] 哈希表分配空间，这个哈希表的空间大小取决于要执行的操作，以及 ht[0] 当前包含的键值对数量：
    - 如果执行的是扩展操作，那么 ht[1] 的大小为第一个大于等于 ht[0].used * 2 的 2^n（2 的 n 次方幂）；
    - 如果执行的是收缩操作，那么 ht[1] 的大小为第一个大于等于 ht[0].used 的 2^n 。
- 将保存在 ht[0] 中的所有键值对 rehash 到 ht[1] 上面：rehash 指的是重新计算键的哈希值和索引值，然后将键值对放置到 ht[1] 哈希表的指定位置上。
- 当 ht[0] 包含的所有键值对都迁移到了 ht[1] 之后（ht[0] 变为空表），释放 ht[0] ， 将 ht[1] 设置为 ht[0]，并在 ht[1] 新创建一个空白哈希表， 为下一次 rehash 做准备。

扩容或收缩哈希表需要将 ht[0] 里面的所有键值对 rehash 到 ht[1] 里面，这个 rehash 动作不是一次性、集中式地完成的，而是分多次、渐进式地完成的。
- 为 ht[1] 分配空间，让字典同时持有 ht[0] 和 ht[1] 两个哈希表。
- 在字典中维持一个索引计数器变量 rehashidx，并将它的值设置为 0，表示 rehash 工作正式开始。
- 在 rehash 进行期间，每次对字典执行添加、删除、查找或者更新操作时，程序除了执行指定的操作以外，还会顺带将 ht[0] 哈希表在 rehashidx 索引上的所有键值对 rehash 到 ht[1] ，当 rehash 工作完成之后，程序将 rehashidx 属性的值增一。
- 随着字典操作的不断执行，最终在某个时间点上，ht[0] 的所有键值对都会被 rehash 至 ht[1] ，这时程序将 rehashidx 属性的值设为 -1，表示 rehash 操作已完成。

在进行渐进式 rehash 的过程中，字典会同时使用 ht[0] 和 ht[1] 两个哈希表，所以在渐进式 rehash 进行期间，字典的删除（delete）、查找（find）、更新（update）等操作会在两个哈希表上进行：比如说，要在字典里面查找一个键的话，程序会先在 ht[0] 里面进行查找，如果没找到的话， 就会继续到 ht[1] 里面进行查找。
另外，在渐进式 rehash 执行期间，新添加到字典的键值对一律会被保存到 ht[1] 里面， 而 ht[0] 则不再进行任何添加操作：这一措施保证了 ht[0] 包含的键值对数量会只减不增，并随着 rehash 操作的执行而最终变成空表。

#### 跳跃表

跳跃表（skiplist）又称跳表，是一种有序的数据结构，它通过在每个节点中维持多个指向其他节点的指针实现快速访问，大部分情况下跳跃表效率可以媲美平衡，Redis 内部也提供了跳表实现，Redis 跳表由 zskiplistNode 和 zskiplist 两个结构定义，zskiplistNode 结构是跳表节点，zskiplist 结构用户保存跳表节点信息。

跳表节点（zskiplistNode）：

```C
typedef struct zskiplistNode {

    // 后退指针
    struct zskiplistNode *backward;

    // 分值
    double score;

    // 成员对象
    robj *obj;

    // 层
    struct zskiplistLevel {

        // 前进指针
        struct zskiplistNode *forward;

        // 跨度
        unsigned int span;

    } level[];

} zskiplistNode;
```

<div align="left">
    <img src="https://github.com/lazecoding/Note/blob/main/images/redis/zskiplistNode.png" width="600px">
</div>

跳表节点的 level[] 数组意味着一个调表节点可以包含多个元素，每个元素都包含一个指向其他节点的前进指针，一般来说，层数越多，访问其他节点的速度就越快（后续版本层高上限为 64）。

跳表（zskiplist）：

```C
typedef struct zskiplist {

    // 表头节点和表尾节点
    struct zskiplistNode *header, *tail;

    // 表中节点的数量
    unsigned long length;

    // 表中层数最大的节点的层数
    int level;

} zskiplist;
```

<div align="left">
    <img src="https://github.com/lazecoding/Note/blob/main/images/redis/带有zskiplist结构的跳跃表.png" width="600px">
</div>

为了更好管理调表节点，通过一个 zskiplist 结构来持有这些节点。header 和 tail 指针分别指向跳跃表的表头和表尾节点，通过这两个指针定位表头节点和表尾节点的复杂度为 O(1)。通过使用 length 属性来记录节点的数量，可以在 O(1) 复杂度内返回跳跃表的长度。level 属性则用于在 O(1) 复杂度内获取跳跃表中层高最大的那个节点的层数量（头节点的层高不计算在内）。

#### 整数集合

整数集合（intset）是集合键的底层实现之一，当一个集合只包含整数类型元素，并且元素数量不多，Redis 就会使用整数集合作为集合键的底层实现。

整数集合（intset）：
```C
typedef struct intset {

    // 编码类型
    uint32_t encoding;

    // 集合包含的元素数量
    uint32_t length;

    // 保存元素的数组
    int8_t contents[];

} intset;
```

<div align="left">
    <img src="https://github.com/lazecoding/Note/blob/main/images/redis/整数集合.png" width="400px">
</div>

encoding 决定存储整数的编码类型，可选值 INTSET_ENC_INT16、INTSET_ENC_INT32、INTSET_ENC_INT64，其实相当于控制整数类型的大小范围。
length 存储了整数集合存储的元素个数。contents 数组按从小到达存储这整数元素。当存放一个非整数的值，存储形式立刻从 intset 转变为 hash。

#### 压缩列表


### 对象类型