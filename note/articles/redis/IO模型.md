# IO 模型

我们经常听到 Reids 是单线程的，严格来说这是不准确的。Redis 是单线程，主要是指 Redis 的网络 IO 和键值对读写是由一个线程来完成的，这也是 Redis 对外提供键值存储服务的主要流程。但 Redis 的其他功能，比如持久化、异步删除、集群数据同步等是由额外的线程执行的。甚至从 Redis 6.0 开始网络 IO 处理模块也变成多线程了。

从另一个角度上，Reids 事件驱动模型中的使用的文件事件处理器是单线程的，所以 Reids 被叫做单线程的模型，这也是 Redis 可以支撑起高并发的缘由。

### 非阻塞IO

当我们调用套接字的读写方法，默认它们是阻塞的。当用户线程发起 IO 请求，进程会从用户态切换为内核态，当发现数据准备就绪，内核会将数据拷贝到用户线程，这个过程用户线程是阻塞的，用户线程会让出 CPU，直到将数据返回给用户线程。

非阻塞 IO 在套接字对象上提供 Non_Blocking 选项，它表示读写方法不会阻塞，而是能读多少读多少，能写多少写多少。能读/写多少取决于内核为套接字分配的读/写缓冲区内部的数据字节数，读方法和写方法都会通过返回值来告知程序实际读写了多少字节。用户线程需要不断地询问内核数据是否就绪，也就说非阻塞IO不会交出CPU，一直占用CPU。

有了非阻塞 IO 意味着线程在读写 IO 时不必阻塞线程，线程可以继续干别的事情。
