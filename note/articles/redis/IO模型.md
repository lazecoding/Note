# IO 模型

我们经常听到 Reids 是单线程的，严格来说这是不准确的。Redis 是单线程，主要是指 Redis 的网络 IO 和键值对读写是由一个线程来完成的，这也是 Redis 对外提供键值存储服务的主要流程。但 Redis 的其他功能，比如持久化、异步删除、集群数据同步等是由额外的线程执行的。甚至从 Redis 6.0 开始网络 IO 处理模块也变成多线程了。

从另一个角度上，Reids 事件驱动模型中的使用的文件事件处理器是单线程的，所以 Reids 被叫做单线程的模型，这也是 Redis 可以支撑起高并发的缘由。

### 非阻塞IO

当我们调用套接字的读写方法，默认它们是阻塞的。当用户线程发起 IO 请求，进程会从用户态切换为内核态，当发现数据准备就绪，内核会将数据拷贝到用户线程，这个过程用户线程是阻塞的，用户线程会让出 CPU，直到将数据返回给用户线程。

非阻塞 IO 在套接字对象上提供 Non_Blocking 选项，它表示读写方法不会阻塞，而是能读多少读多少，能写多少写多少。能读/写多少取决于内核为套接字分配的读/写缓冲区内部的数据字节数，读方法和写方法都会通过返回值来告知程序实际读写了多少字节。用户线程需要不断地询问内核数据是否就绪，也就说非阻塞IO不会交出CPU，一直占用CPU。

有了非阻塞 IO 意味着线程在读写 IO 时不必阻塞线程，线程可以继续干别的事情。

### 多路复用

非阻塞 IO 存在一个问题，就是线程读取一部分数据就返回了，那么线程如何知道应该何时继续读写数据。

事件轮询 API 就是用来解决这个问题的，这是一种多路复用机制。常见的事件轮询 API 有 select、poll、epoll，它们是操作系统提供给用户线程的 API，用于取代用户线程轮询。如果是用户线程轮询就要涉及用户态和内核态的频繁切换，这部分开销是巨大的。

#### select

最简单事件轮询 API 是 select，下面是 select 函数：

```C
int select(int maxfdp1,fd_set *readset,fd_set *writeset,fd_set *exceptset,const struct timeval *timeout);
```

select() 的机制中提供一种 fd_set 的数据结构，实际上是一个 long 类型的数组，每一个数组元素都能与一打开的文件句柄（不管是 Socket 句柄,还是其他文件或命名管道或设备句柄）建立联系，当调用 select() 时，由内核根据 IO 状态修改 fd_set 的内容，由此来通知执行了 select() 的进程哪一 socket 或文件可读写。

使用 select() 最大的优势是可以在一个线程内同时处理多个 socket 的 IO 请求。用户可以注册多个 socket，然后不断地调用 select() 读取被激活的 socket，即可达到在同一个线程内同时处理多个 IO 请求的目的。但 select 存在三个问题：一是为了减少数据拷贝带来的性能损坏，内核对被监控的 fd_set 集合大小做了限制，并且这个是通过宏控制的，大小不可改变(限制为 1024)；二是每次调用 select()，都需要把 fd_set 集合从用户态拷贝到内核态，如果 fd_set 集合很大时，那这个开销很大；三是每次调用 select() 都需要在内核遍历传递进来的所有 fd_set，如果 fd_set 集合很大时，那这个开销也很大。

#### poll

poll 的机制与 select 类似，与 select 在本质上没有多大差别，管理多个描述符也是进行轮询，根据描述符的状态进行处理，只是 poll 没有最大文件描述符数量的限制。