# IO 模型

我们经常听到 Reids 是单线程的，严格来说这是不准确的。Redis 是单线程，主要是指 Redis 的网络 IO 和键值对读写是由一个线程来完成的，这也是 Redis 对外提供键值存储服务的主要流程。但 Redis 的其他功能，比如持久化、异步删除、集群数据同步等是由额外的线程执行的。甚至从 Redis 6.0 开始网络 IO 处理模块也变成多线程了。

从另一个角度上，Reids 事件驱动模型中的使用的文件事件处理器是单线程的，所以 Reids 被叫做单线程的模型，这也是 Redis 可以支撑起高并发的缘由。

### 非阻塞IO

当我们调用套接字的读写方法，默认它们是阻塞的。当用户线程发起 IO 请求，进程会从用户态切换为内核态，当发现数据准备就绪，内核会将数据拷贝到用户线程，这个过程用户线程是阻塞的，用户线程会让出 CPU，直到将数据返回给用户线程。

非阻塞 IO 在套接字对象上提供 Non_Blocking 选项，它表示读写方法不会阻塞，而是能读多少读多少，能写多少写多少。能读/写多少取决于内核为套接字分配的读/写缓冲区内部的数据字节数，读方法和写方法都会通过返回值来告知程序实际读写了多少字节。用户线程需要不断地询问内核数据是否就绪，也就说非阻塞IO不会交出CPU，一直占用CPU。

有了非阻塞 IO 意味着线程在读写 IO 时不必阻塞线程，线程可以继续干别的事情。

### 多路复用

非阻塞 IO 存在一个问题，就是线程读取一部分数据就返回了，那么线程如何知道何时应该继续读数据————即当数据到来时候，线程如何得到继续读的通知；当写缓冲区空余了，线程如何得到继续写的通知。

事件轮询 API 就是用来解决这个问题的，这是一种多路复用机制。常见的事件轮询 API 有 select、poll、epoll，它们是操作系统提供给用户线程的 API，用于取代用户线程轮询。如果是用户线程轮询就要涉及用户态和内核态的频繁切换，这部分开销是巨大的。

最简单事件轮询 API 是 select，它的输入是读写描述符列表，输出是与之对应的可读可写事件。同时还提供一个 timeout 参数，如果没有任何事件到来，那么就最多等待 timeout 规定的时间，一旦期间有任何事件到来，就可以立即返回结果，时间过了还没有任何事件到来，也会立即返回。

select 维护了一个文件描述符列表，它的每个循环周期会遍历所有文件描述符，如果描述符特别多时性能会变得很差。poll 和 select 机制是一致的，只不过 poll 没有 select 最大文件描述符的限制。
epoll 和它们区别较大，是性能更高的事件轮询 API，它额外维护一个活跃的事件队列，里面只存储了触发事件的文件描述符。epoll采用了零拷贝技术，使用 mmap 系统函数将内核缓冲区与应用程序共享，减少了 read 和 write 系统调用，从而减少了内核态和用户态切换。