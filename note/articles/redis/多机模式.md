# 多机模式

生产环境中很少会使用单机数据库，主要问题是：内存容量限制、硬件性能限制、单点问题。为了解决这些问题，Redis 提供了三种多机模式：
- 复制（Replication）
- 哨兵（Sentinel）
- 集群（Cluster）

### 复制

通过执行 ALAVEOF 命令或设置 slaveof 选项，可以让一个服务器去复制另一个服务器的数据，被复制的服务器称为主服务器（master），进行复制的服务器叫从服务器（slave）。

从服务器可以有多个，但主服务器有且只有一个。主服务器可以进行读写操作，从服务器只能进行只读操作，进行复制的主从服务器双方的数据库保存相同的数据。

#### 旧版复制功能实现

旧版复制功能分为同步和命令传播两个操作：
- 同步操作用于将从服务器的数据库状态更新至主服务器当前所处的数据库状态。
- 命令传播操作则用于在主服务器的数据库状态被修改，导致主从服务器的数据库状态出现不一致时，让主从服务器的数据库重新回到一致状态。

从服务器对主服务器的同步操作需要通过向主服务器发送 SYNC 命令来完成，以下是 SYNC 命令的执行步骤：
- 从服务器向主服务器发送 SYNC 命令。
- 收到 SYNC 命令的主服务器执行 BGSAVE 命令，在后台生成一个 RDB 文件，并使用一个缓冲区记录从现在开始执行的所有写命令。
- 当主服务器的 BGSAVE 命令执行完毕时，主服务器会将 BGSAVE 命令生成的 RDB 文件发送给从服务器，从服务器接收并载入这个 RDB 文件，将自己的数据库状态更新至主服务器执行 BGSAVE 命令时的数据库状态。
- 主服务器将记录在缓冲区里面的所有写命令发送给从服务器，从服务器执行这些写命令，将自己的数据库状态更新至主服务器数据库当前所处的状态。

<div align="left">
    <img src="https://github.com/lazecoding/Note/blob/main/images/redis/主从SYNC命令通信过程.png" width="400px">
</div>

在同步操作执行完毕之后，每当主服务器执行客户端发送的写命令时，主服务器的数据库就有可能会被修改，从而导致主从服务器状态不一致。为了让主从服务器再次回到一致状态，主服务器需要对从服务器执行命令传播操作：主服务器会将自己执行的写命令，发送给从服务器执行，当从服务器执行了相同的写命令之后，主从服务器将再次回到一致状态。

网络是不可靠的，可能因为各种因素导致主从断线，当发生主从断线后从服务器重新连接上的主服务器，会重新发起 SYNC 命令请求。虽然可以继续回到一致性状态，但是通过生成 RBD 文件重新同步代价是巨大的，如果从服务器能够执行断线期间的命令请求也可以达到一致性状态。

#### 新版复制功能实现

为了解决旧版复制功能断线重新复制的问题，Redis 从 2.8 版本开始使用 PSYNC 命令代替 SYNC 来实现复制时的同步操作。

PSYNC 命令具有完整重同步和部分重同步两种模式：
- 完整重同步用于处理初次复制情况：完整重同步的执行步骤和 SYNC 命令的执行步骤基本一样，通过让主服务器创建并发送 RDB 文件，以及向从服务器发送保存在缓冲区里面的写命令来进行同步。
- 部分重同步则用于处理断线后重复制情况：当从服务器在断线后重新连接主服务器时，如果条件允许，主服务器可以将主从服务器连接断开期间执行的写命令发送给从服务器，从服务器只要接收并执行这些写命令，就可以将数据库更新至主服务器当前所处的状态。

<div align="left">
    <img src="https://github.com/lazecoding/Note/blob/main/images/redis/主从部分重同步过程.png" width="400px">
</div>

部分重同步由三个部分组成：
- 服务器的运行ID（run ID）。
- 主服务器的复制偏移量（replication offset）和从服务器的复制偏移量。
- 主服务器的复制积压缓冲区（replication backlog）。

每个服务器都有自己的运行 ID，从服务器初次复制会将自己的 ID 传递给 主服务器，用于标识自己。

主从服务器都会维护一个复制偏移量：主服务器每次向从服务器传播 N 个字节的数据时，就将自己的复制偏移量的值加上 N；从服务器每次收到主服务器传播来的 N 个字节的数据时，就将自己的复制偏移量的值加上 N。通过比对偏移量就可以知道主从服务器是否处于一致性状态。

主服务器还维护者一个复制积压缓冲区，是一个固定长度先进先出的队列，用于保存最近传播的写命令，并且会为队列中每个字节记录相应的复制偏移量。当从服务器重新连接上主服务器时候，从服务器通过 PSYNC 命令将自己的复制偏移量 offset 发送给主服务器，主服务器会根据这个复制偏移量来决定采用何种同步操作（取决于断线时的操作是否都存在于复制挤压缓冲区）。

通过复制，我们可以实现服务器的主从同步，如果主服务器出现问题，切换从服务器来提供服务，但这需要人工介入，并不具备高可用。

### 哨兵

哨兵（Sentinel）是一个 Redis 高可用的解决方案，通过构建一个 Sentinel 系统监控一组服务器。

Sentinel 往往是一个集群，是高可用的心脏，负责持续监控主从节点的健康，当主服务器挂掉会自动选择一个最优的从服务器切换为主服务器。当客户端接入集群，首先会连接 Sentinel，通过 Sentinel 获取主服务器地址进行数据交互。

<div align="left">
    <img src="https://github.com/lazecoding/Note/blob/main/images/redis/服务器与Sentinel系统.png" width="600px">
</div>

当主服务器挂掉，原先的主从复制也会断开，客户端和损坏的主服务器也会断开。一个从服务器被提升为主服务器，其他从服务器和新的主服务器建立复制关系，客户端也与新的主服务器进行数据交互。

<div align="left">
    <img src="https://github.com/lazecoding/Note/blob/main/images/redis/Sentinel切换主从服务器.png" width="600px">
</div>

当之前挂掉的主服务器恢复服务后，会成为从服务器，与新的主服务器建立复制关系。

<div align="left">
    <img src="https://github.com/lazecoding/Note/blob/main/images/redis/Sentinel服务器恢复服务.png" width="600px">
</div>

哨兵模式解决了主从复制不能自动故障转移，达不到高可用的问题，但还是存在难以在线扩容，Redis 容量受限于单机配置的问题。

### 集群

集群（Cluster）是 Redis 的分布式数据库方案，Cluster 通过分片（sharding）来进行数据共享，并提供复制和故障迁移功能。

Cluster 一般由多个节点组成，每个节点都是一个 Redis 服务器，Cluster 将所有数据划分到 16384 个槽位中，每个节点负责其中一部分槽位。

Cluster 采用去中心化结构，所有节点彼此互联，每个节点都会记录集群的配置信息：如信息版本号 Epoch、集群状态 State、槽位配置等数据。每个节点都保存着 Node 视角的集群结构,它描述了数据的分片方式，节点主备关系，并通过 Epoch 作为版本号实现集群结构信息的一致性，同时控制着数据迁移和故障转移的过程。客户端与 Cluster 相连不需要中间代理层，也不需要连接所有节点，只要连接任意一个可用节点即可。

<div align="left">
    <img src="https://github.com/lazecoding/Note/blob/main/images/redis/Cluster结构.png" width="600px">
</div>

客户端为了可以直接定位某个 key 所在节点，会缓存节点关系表，用于记录槽位相关信息，当客户端要查找某个 key 时，可以直接定位到目标节点。

#### 数据分片

节点使用以下算法来计算给定键 key 属于哪个槽：

```C
def slot_number(key):
    return CRC16(key) & 16383
```

#### 数据迁移

Cluster 提供了工具 redis-trib 用于槽位数据分配。当有新主节点加入集群中、从集群中移除节点或者因数据分布不均衡时需要数据重新分布时，就会通过 redis-trib 进行数据迁移。

Cluster 迁移的单位是槽，Redis 一个槽一个槽地进行迁移，当一个槽正在迁移时，这个槽就处于中间过渡状态，原节点的状态为 migrating，目标节点的状态为 importing，表示数据正在从源流向目标。

<div align="left">
    <img src="https://github.com/lazecoding/Note/blob/main/images/redis/redis-trib迁移过程.png" width="600px">
</div>

迁移工具 redis-trib 首先会在源和目标节点设置好中间过渡状态，然后一次性获取源节点槽位的所有 key 列表，再逐个 key 进行迁移。
每个 key 的迁移过程是以原节点作为目标节点的「客户端」，原节点对当前的 key 执行 dump 指令得到序列化内容，然后通过「客户端」向目标节点发送指令 restore 携带序列化的内容作为参数，目标节点再进行反序列化就可以将内容恢复到目标节点的内存中，然后返回「客户端」OK，原节点「客户端」收到后再把当前节点的 key 删除掉就完成了单个 key 迁移的整个过程。

在目标节点执行 restore 指令到原节点删除 key 之间，原节点的主线程会处于阻塞状态，直到 key 被成功删除。
如果迁移过程中突然出现网络故障，整个 slot 的迁移只进行了一半。这时两个节点依旧处于中间过渡状态。待下次迁移工具重新连上时，会提示用户继续进行迁移。

当 Cluster 正在进行或已经完成槽位迁移，Cluster 提供两条命令来处理来自客户端的请求：
- MOVED：MOVED 指令用来纠正槽位。当客户端指令到达错误节点，该节点会将目标节点的地址随同 MOVED 指令返回给客户端，客户端收到通知会刷新节点关系表并向目标节点重新发起请求。
- ASKING：ASKING 指令用来临时纠正槽位，客户端并不刷新节点关系表。如果当前槽位正在迁移，指令会到达原节点，如果该 key 还在原节点直接返回，如果不在则将目标节点的地址随同 ASKING 指令返回给客户端，客服端只会尝试从目标节点获取数据，并不刷新节点关系表。

#### 高可用

Cluster 保证集群高可用的思路和实现和 Sentinel 是一样的。Cluster 中每个节点都存有集群中所有节点的信息。它们之间通过互相 PING - PONG 判断节点是否可以连接。如果有一半以上的节点去 PING 一个节点的时候没有回应，集群就认为这个节点宕机。
当主节点被集群公认为 fail 状态，那么它的从节点就会发起竞选，如果存在多个从节点，数据越新的节点越有可能发起竞选，集群中其他主节点返回响应信息。当竞选从节点收到过半主节点同意，便会成为新的主节点。此时会以最新的 Epoch 通过 PONG 消息广播，让 Cluster 的其他节点尽快的更新集群信息，当原主节点恢复加入后会降级为从节点。

当集群中某节点中的所有从实例宕机时，Cluster 会将其他节点的非唯一从实例进行副本迁移，成为此节点的从节点。这样集群中每个主节点至少有一个从节点e，使得 Cluster 具有高可用。
集群 fail 条件：
- 某个主节点和所有从节点全部挂掉，则集群进入 fail 状态。
- 如果集群超过半数以上主节点挂掉，无论是否有从节点，集群进入 fail 状态。
- 如果集群任意主节点挂掉,且当前主节点没有从节点，集群进入 fail 状态。

当服务器节点变更，客户端发出请求会得到提示以刷新客服端缓存的节点关系表。

### 未解决的问题

Redis 的多机模式逐步实现了高性能、高可用的目标，但对于数据的一致性始终难以保障。Redis 主从采用的是异步复制，意味着主节点挂掉，从节点可能没有收到全部的复制消息，这部分消息就丢失了。