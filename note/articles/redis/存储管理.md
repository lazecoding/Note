# 内存管理

### 键空间

Redis 是一个键值对数据库，每个数据库都由一个 redisDb 结构表示，redisDb 结构中的 dict 字典保存了数据库中的所有键值对，我们将这个字典称为键空间（key space）：

```C
typedef struct redisDb {

    // ...

    // 数据库键空间，保存着数据库中的所有键值对
    dict *dict;

    // ...

} redisDb;
```

用户可以根据 API 读写数据库中的键值对，在读写命令进行时，服务器还会执行额外的维护操作：
- 在读取一个键之后（读操作和写操作都要对键进行读取），服务器会根据键是否存在，以此来更新服务器的键空间命中（hit）次数或键空间不命中（miss）次数，这两个值可以在 INFO stats 命令的 keyspace_hits 属性和 keyspace_misses 属性中查看。
- 在读取一个键之后，服务器会更新键的 LRU （最后一次使用）时间，这个值可以用于计算键的闲置时间，使用命令 OBJECT idletime <key> 命令可以查看键 key 的闲置时间。
- 如果服务器在读取一个键时，发现该键已经过期，那么服务器会先删除这个过期键，然后才执行余下的其他操作。
- 如果有客户端使用 WATCH 命令监视了某个键，那么服务器在对被监视的键进行修改之后，会将这个键标记为脏（dirty），从而让事务程序注意到这个键已经被修改过。
- 服务器每次修改一个键之后，都会对脏（dirty）键计数器的值增一，这个计数器会触发服务器的持久化以及复制操作执行。
- 如果服务器开启了数据库通知功能，那么在对键进行修改之后，服务器将按配置发送相应的数据库通知。

### 过期时间

通过 EXPIRE 命令或 PEXPIRE 命令，客户端可以为数据库中某个键设置生存时间（Time To Live），在经过指定的时间后，服务器就会根据自动过期策略删除生存时间为 0 的键。

与 EXPIRE 命令和 PEXPIRE 命令类似，客户端可以通过 EXPIREAT 命令 或者 PEXPIREAT 命令对某个键设置过期时间。过期时间是个 UNIX 时间戳，当键的过期时间来临时，服务器就会根据自动过期策略删除过期键。

Redis 有四种不同的命令可以用于设置键的生存时间和过期时间：
- `EXPlRE <key> <ttl>`：用于将键key 的生存时间设置为ttl 秒。
- `PEXPIRE <key> <ttl>`：用于将键key 的生存时间设置为ttl 毫秒。
- `EXPIREAT <key> <timestamp>`：用于将键key 的过期时间设置为timestamp所指定的秒数时间戳。
- `PEXPIREAT <key> <timestamp>`：用于将键key 的过期时间设置为timestamp所指定的毫秒数时间戳。

虽然命令不同，但实际上 EXPlRE、PEXPIRE 和 EXPIREAT 命令都是通过 PEXPIREAT 命令实现的。

### 过期键

redisDb 结构中的 expires 字典保存了数据库中所有的键的过期时间（UNIX 时间戳）。

```C
typedef struct redisDb {

    // ...

    // 过期字典，保存着数据库中的所有键的过期时间
    dict *expires;

    // ...

} redisDb;
```

过期字典和键空间中的相同键都指向同一个键对象，并不会产生空间浪费。

过期键判定
1. 检查给定键是否存在于过期字典，如果存在取得过期时间，否则未过期（无过期时间，永不过期）。
2. 检查当前 UNIX 时间是否大于键的过期时间，如果大于则过期，否则未过期。

### 过期删除策略

过期键删除策略有三种，分别是定时删除、定期删除和惰性删除。

`定时删除` 在设置键的过期时间的同时会创建一个定时器用于删除过期键，定时删除策略会尽可能快地删除过期键，并是否内存。

定时删除是对内存最友好的方式，但对 CPU 最不友好。在过期键比较多的情况下，定时器删除过期键会占用一部分 CPU 时间，会降低服务器响应时间和吞吐量。此外，定时器还依赖于 Redis 服务器中的时间事件，而当前事件事件的实现方式是无序链表，查找一个事件的时间复杂度是 O(N)，不能高效地实现定时删除。

`惰性删除` 在每次获取键值对时检查过期时间，如果过期则删除。

惰性删除是对 CPU 最为友好的，但对内存很不友好，过期键如果未被使用将永远存活在数据库中。甚至，有些临时使用的标志性缓存，以后再也不会使用，这可以看作是内存泄漏的一种。

`定期删除` 每隔一段时间服务器对过期键进行检查，根据定期删除策略来决定删除行为。

定时删除和惰性删除在 CPU 和内存处于两个极端，定期删除策略是他们的折中。定期删除每隔一段时间执行一次过期键删除任务，并通过限制执行时长和频率来减少对 CPU 的影响，并有效减少内存浪费。

### 内存淘汰

Redis 是内存数据库，当内存占用达到物理阈值，内存的数据就会和磁盘发生频繁交换，这会导致 Redis 性能极具下降，对于高并发应用，基本等于不可用。

Redis 提供了 `maxmemory` 参数来限制内存期望大小，当超过 maxmemory 的值时，Redis 提高了几种内存淘汰策略：
- `noeviction`：不淘汰任何键，接收读请求，拒绝写请求（del 请求正常）。
- `volatile-lru`：在设置过期时间的键中淘汰最近最少使用的键。
- `allkeys-lru`：在所有键中淘汰最近最少使用的键。
- `volatile-ttl`：在设置过期时间的键中淘汰生存时间最短的键。
- `volatile-random`：在设置过期时间的键中随机淘汰。
- `allkeys-random`：在所有键中随机淘汰。
- `volatile-lfu`：在设置过期时间的键中淘汰使用频率最小的键。
- `allkeys-lfu`：在所有键中淘汰使用频率最小的键。

#### LRU 算法

LRU（Least Recently Used，最近最少使用）算法维护一个 LRU 列表，当某个元素被访问会被移动到表头，当列表满的时候会剔除链表尾部的元素，所有 LRU 队列的顺序是最近被访问的时间顺序。

Redis 使用的是近似 LRU 算法，在现有数据结构的基础上采用随机采用法淘汰元素，达到 LRU 类似的效果。
Redis 为了是实现 LRU 算法给每个键添加了一个长度 24 bit 的字段，用于存储最后一次被访问的时间戳（内部时钟），当 Redis 淘汰数据时会根据淘汰策略从目标中随机采用出 N（可配置） 个键，淘汰最旧的键。

采用近似 LRU 算法，一方面可以避免维护 LRU 队列链表的开销，另一个方面可以减少内存的占用，而且实际效果和 LRU 队列相当，但拥有更高的效率。

#### LFU 算法

LFU（least frequently used,最不经常使用）算法把键中的内部时钟的 24 bit 分成两部分，前 16 bit 还代表时钟，后 8 bit 代表一个计数器。