# 雪崩、击穿、穿透

当我们使用缓存的时候，我们不得不面对三个问题：雪崩、击穿、穿透。

### 雪崩

缓存雪崩是缓存中大量数据（近乎）同时到达过期时间，导致所有请求落到数据库，数据库压力过大甚至宕机。

最简单的处理方式是给不同业务的缓存设置不同的过期时间，并且给每个过期时间都加上一个的随机时间让过期时间尽可能分散。还可以预见性的 reload，在可能发生大量请求的时间段之前或定期重载缓存。

复杂点的处理方式可以通过加锁或者队列的方式读数据库写缓存，但我个人不是很推荐，无论是加锁还是队列都增加了系统的复杂度，而且加锁还降低了并发能力。另一种方式是做二级缓存，一级缓存作为短期缓存，二级缓存作为持久缓存，但这不仅增加了复杂度，而且造成内存浪费。

### 击穿

缓存击穿是指缓存中某一热点数据在大量查询的情况下缓存过期（或被删除、内存淘汰等原因导致的消失），导致所有请求落到数据库，数据库压力过大甚至宕机。

和缓存雪崩不同，缓存雪崩是无差别过期，大量不同查询落到数据库上，而缓存击穿是某个热点数据过期导致相同查询落到数据库上。

最简单的处理方式就是热点数据永不过期，而且定期重载热点缓存。还要注意的是对于热点数据的更新，不要直接 del 缓存，需要 set 缓存。

比较复杂的处理方式是（双重检查）加锁，保障同时只会有一个线程可以查询数据库和更新缓存。使用 Java 提供了 Lock 或者 synchronized 存在两个问题：一是只有一个线程可以获取对象锁，即使不是查询该缓存也会被阻塞，这会降低并发能力，而且并没有必要阻塞它们；二是 Java 的锁机制都是单机的，对于多机部署的环境需要采用分布式锁才可以保障只有一个线程去查询数据库。

如果我们采用了分布式锁，我们可以设计的灵活点，不仅解决了多机问题，第一个问题也可以解决，将请求参数加到锁中。但是采取分布式锁也是存在缺陷的，需要引入其他中间件依赖。比如基于 zookeeper 的分布式锁，如果 zookeeper 出现了问题会影响到业务系统，为了保障 zookeeper 高可用需要增加多台机器保障高可用，自然增加了成本。如果采用基于 Redis 的分布式锁，本身就是 Redis 倒是不需要再引入其他中间件，但是基于 Redis 的分布式锁存在一致性问题，主从切换可以导致重复获取锁。

### 穿透

缓存穿透是指查询一个一定不存在的数据，该查询必然会查询数据库。如果被人利用在流量高峰发起这样的请求可以导致数据库压力过大甚至宕机。