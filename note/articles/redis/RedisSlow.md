# Redis 怎么慢了

Redis 具有极高性能和吞吐量，但有的时候操作 Redis 响应却很慢，这时候我们要逐步排查。响应变慢存在两方面可能：

- 客户端与服务器之间的存在网络问题，如网络数据包在传输时存在延迟、丢包等情况。
- 服务器自身问题。

当排除网络问题的情况下，我们主要分析服务器自身可能存在的问题。

### 执行复杂度高的命令

首先查看一下 Redis 的慢日志。Redis 提供了慢日志命令的统计功能，通过以下设置可以查看有哪些命令在执行时延迟比较大。

```C
# 命令执行超过 5 毫秒记录慢日志（单位是微妙）
CONFIG SET slowlog-log-slower-than 5000
# 只保留最近 1000 条慢日志
CONFIG SET slowlog-max-len 1000
```

通过慢日志记录，可以知道在什么时间执行哪些命令比较耗时。如果你的服务请求量并不大，但 Redis 实例的 CPU 使用率很高，很有可能是使用了复杂度高的命令导致的。

建议：
- 避免使用复杂度较高的命令。
- 数据少量多次地取，让 Redis 可以及时处理返回。

### 存储大key

如果查询慢日志发现，并不是复杂度较高的命令导致的，例如是 SET、DELETE 操作出现在慢日志记录中，那么就可能存在写入了大 key 的情况。

Redis 在写入数据时，需要为新的数据分配内存，当从 Redis 中删除数据时，它会释放对应的内存空间。如果一个 key 写入的数据非常大，Redis 在分配内存时也会比较耗时。同样的，当删除这个 key 的数据时，释放内存也会耗时比较久。

Redis 也提供了扫描大key的方法：

```C
redis-cli -h $host -p $port --bigkeys -i 0.01
```

建议：
- 避免写入大 key。
- Redis 4.0 以上版本，用 UNLINK 命令替代 DEL，此命令可以把释放 key 内存的操作，放到后台线程中去执行，从而降低对 Redis 的影响。
- Redis 6.0 以上版本，可以开启 lazy-free 机制（lazyfree-lazy-user-del = yes），在执行 DEL 命令时，释放内存也会放到后台线程中执行。
- 即便如此，依然不建议写入大 key,在很多场景下，大 key 会产生性能问题。例如，在分片集群模式下，对于数据的迁移也会有性能影响，以及数据过期、数据淘汰。

### 集中过期

### 内存达到上限

### fork耗时严重

### 绑定CPU

### 开启AOF

### 使用Swap

### 网卡负载过高
