# RabbitMQ

RabbitMQ 是实现了高级消息队列协议（AMQP）的开源消息代理软件（亦称面向消息的中间件）。RabbitMQ 服务器是用 Erlang 语言编写的，而聚类和故障转移是构建在开放电信平台框架上的。所有主要的编程语言均有与代理接口通讯的客户端库。

RabbitMQ 的特点：

- 可靠性：支持持久化，传输确认，发布确认等保证了MQ的可靠性。
- 灵活的消息分发策略，RabbitMQ 支持多种工作模式分发消息。
- 支持集群，多个 RabbitMQ 实例可以组成一个集群，形成一个逻辑 Broker。
- 多种协议，RabbitMQ 支持多种消息队列协议，比如 STOMP、MQTT 等等。
- 支持多种语言客户端，RabbitMQ 几乎支持所有常用编程语言，包括 Java、.NET、Ruby 等等。
- 可视化管理界面，RabbitMQ 提供了一个易用的用户界面，使得用户可以监控和管理消息 Broker。
- 插件机制，RabbitMQ 提供多种插件进行扩展，也可以自行编写插件。

RabbitMQ 是 AMQP 协议的一个开源实现，所以其内部实际上也是 AMQP 中的基本概念，可以参考上文——[AMQP](https://github.com/lazecoding/Note/blob/main/note/articles/rabbitmq/AMQP.md) ，本文不做赘述。

### 工作模式

RabbitMQ 一共有六种工作模式，分别为简单模式、工作队列模式、发布/订阅模式、路由模式、主题模式和RPC模式，RPC 模式并不常用，本文只介绍前面五种工作模式。

- 简单模式(Simple)

    交换机类型：direct。

    指定队列，绑定默认路由，一对一消费。

- 工作队列模式(Work)

    交换机类型：direct。

    指定队列，绑定默认路由，一对多消费，每个消息者只会被其中一个消费者消费。

- 发布/订阅模式(publish/subscribe)

    交换机类型：fanout。

    指定交换机广播，所有绑定该交换机的队列都将收到消息。

- 路由模式(routing)

    交换机类型：direct。

    指定交换机，将消息发送到路由完全匹配的队列上，每个消息者只会被其中一个消费者消费。

- 主题模式(topic)

    交换机类型：topic。

    指定交换机，根据路由模糊匹配，*、#代表通配符，*代表多个单词，#代表一个单词，将消息发送到路由模糊匹配的队列上，每个消息者只会被其中一个消费者消费。

### RabbitMQ 集群

RabbitMQ 集群的目标是允许生产者和消费者在部分 Rabbit 节点崩溃的情况下可以继续运行和添加节点可以线性扩展消息通信吞吐量。它的实现是基于主从的，非分布式的，不具备高可用。

如果在集群中创建队列，只会在单个节点上创建完整的队列信息(元数据、状态、内容)，只有队列的所有者节点知道有关队列所有信息，其他节点只知道队列的元数据和指向该队列存在的节点。消费者消费消息时随机连接某个节点，然后根据队列元数据定位并拉取数据。当某个节点崩溃了，该节点的队列和关联绑定都消失了，附加在那些队列上的消费者丢失其订阅信息，而且任何匹配该队列的新信息也都丢失了，即使是开启了持久化也需要等这个节点重启才能拉去数据。

<div align="left">
    <img src="https://github.com/lazecoding/Note/blob/main/images/rabbitmq/RabbitMQ集群架构.png" width="600px">
</div>

RabbitMQ 的集群模式并不是高可用架构，它将数据分布到各个节点并没用做高可用保证。虽然 RabbitMQ 也提供了镜像集群模式，数据会同步到所有节点，每个节点都是完整的数据拷贝，但是并不推荐这样使用。一是出于存储空间的考虑，如果每个节点都是数据的完全拷贝，这样会产生很多冗余数据，占用大量内存、磁盘空间。二是出于性能的考虑，如果每条消息的完成拷贝到每个节点，这样并不会提升单个节点的性能，也不能起到线性扩展的作用，反而会带来更多的网络开销和磁盘负载。

每个 RabbitMQ 节点要么是内存节点，要么是磁盘节点，至少有一个磁盘节点。内存节点提供出色的性能，磁盘节点能够保证集群配置信息的可靠性。当所有磁盘节点都崩溃的时候，集群只能提供路由功能，无法完成元数据信息和集群信息的更改。如：创建队列、交换、绑定，添加用户、更改权限、增删节点等。

### 作用和不足

RabbitMQ是一个典型的消息队列，可以用于系统解耦、异步编程、流量消费等场景。但同时也会降低系统可用性、增加系统复杂度、产生一致性问题。

- 系统可用性：系统的外部依赖越多，系统越可能挂掉。
- 系统复杂度：引入MQ就需要处理消息可靠投递、消息重复消费、消息顺序性等问题。
- 一致性问题：可能存在一部分消费者写入成功，一部分消费者写入失败，导致数据不一致的问题。

