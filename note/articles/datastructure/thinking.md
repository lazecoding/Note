# 对于数据结构的思考

数据结构是编程最重要的基本功，它的意义在于，将现实问题转化为计算机语言的表示，本文都是些个人见解。

---

`数组`，在内存上是一片连续的内存区，长度固定，存在索引，故此数组的查询效率高。但是，定长的特点让数组长度的改变必须重新创建一个新数组来实现，增删效率低。

---

`链表` 是一种以节点对象组织的数据结构，空间上不连续，长度不固定。常见的链表形式有 `单链表`、`双链表`、`环形链表`。

`单链表` 的节点是由值和后继节点的引用组成的，每次增加、删除节点只需要修改后继节点的引用即可。单链表的问题也很明显，一是获取数据必须从头遍历，二是节点无法获取其前驱节点的属性，必须要从头遍历获取。

`双链表` 的节点是由前驱节点的引用、值和后驱节点的引用组成，节点可以随意的访问其前驱节点、后驱节点，但是相对于单链表多出了一个节点引用，在插入效率低于单链表。

`环形链表`，就是普通链表的尾指针指向了头节点，用的真的很少，我只在约瑟夫问题看到过。

总的说，`链表解决了增删效率的问题，但其查询效率又不行了`。

---

中庸之道是中国古代唯心主义哲学观点论, ,待人接物采取不偏不倚,调和折中的态度。对于数组和链表亦可。

`哈希表` 是数组和链表的结合，它的基本实现是一层数组，数组的每个值都是一个桶，里面存储的是一个链表。哈希表是一种用于 KV 查询的数据结构，用 hash 函数来让key映射到对应的桶中，当出现 hash 碰撞在以头插法进行链表追加。如此设计，在查找和增删上都具有极高的效率。但是，也还是存在问题，当数据量过大，桶数一定，桶长就很很差，链表查询效率低就会暴露，所以根据数据量数组存在扩容，而扩容的消耗是很大的，需要对每个数据再 hash。(先思考一下，还有没有可以优化的。)

---

为了摆脱扩容问题，我们坚决的和数组说了再见，树是一个以节点组织的数据结构。树的种类，总的分 `二叉树` 和 `多叉树`。

`二叉树` 顾名思义每个节点有两个叉。二叉树节点的构成是值、左节点引用和右节点引用。对于一个普通的二叉树，其实使用意义不大的，想要查询我们需要遍历整个树，所以我们讨论的树是基于排序——遵循的是 `左节点>根节点>右节点`。

当一个树排序了，根据与根节点的大小比较可以判断节点在哪个子树或是根节点本身。但是，一个普通的 `排序树` 会存在退化问题——一个排序树，按序插入值，如：1、2、3 … 可以想象，这颗二叉树将退化成链表。这与我们设计的初衷相违背，我们不能让树退化，我们需要保持左右子树的平衡。`AVL 树` 要求左右子树最大高度差不能超过 1，每次插入通过 "旋转" 来实现平衡，旋转是一个消耗相对大的操作，有时候需要一次旋转，有时候需要两次旋转。想一想我们为什么要设计平衡树，我们是为了防止退化，是为了提高平均查询时间。`红黑树` 应运而生，这是一种特化的平衡树，弱平衡。红黑树引入了红黑节点、红黑树通过变色和旋转实现平衡，最多只会产生一次旋转，所以在插入效率上大于AVL树。当一个树平衡了，查找数据时就类似于二分查找，效率高而稳定。这里只提及了查找树，其他还要其他使用角度的树，如用于压缩的最优二叉树、暴力数据的珂朵莉树等，本文不做展开。

在数据量大的时候，二叉树的高度会很高，`多叉树` 就来了。最常见的多叉树是 `B 树` 和 `B+ 树`，它们都是排序树。它们的区别主要在于，B 树像传统二叉树一样，每个节点既存数据又存节点引用(为了方便，称之为 "索引")，而 B+ 树非叶子节点只存索引，所有数据都在叶子节点上。如果仅仅如此，似乎 B+ 树没啥优势，但是，思考一波 B+ 树所有数据都在叶子节点，我们把所有叶子节点像链表一样链接起来，那么我们将得到一个有序的链表，十分擅长范围查找。想想一下 B 树用于范围查找要咋样，要递归。而 B+ 树查找，只需要找到临界值，就可以通过链表查询。所有 B+ 树是往往在关系型数据库实现索引的数据结构，当然这并不是说 B 树一无是处。B+ 树的每个数据的访问效率是一样的，但是 B 树的平均访问效率更低，对于非关系型数据库，如 MongoDB，B 树往往更合适，本文也不做展开。

---

讲到这里，有木有觉得哈希表和树有点像。啊？不觉得，哦，我收拾收拾现在就走。我个人认为他们是相似的，`当然不是说他们结构相似，是解决的问题相似`。都是把数据分块来提高查询效率。哈希表是通过哈希分桶，树是通过排序分叉，他们的思想的是分解全量。那么他们到底谁更快呢，其实往往是哈希表查询更快点，一个设计合理的哈希表通常和桶数会维持一个相对合理的关系，hash 计算出桶的位置之后遍历链表的查询次数，往往低于树的查询深度，主要是 hash 计算桶位置大大提高了哈希表的效率。哈希表还可以优化的，当桶长大于一定长度可以将其实现改成红黑树，加快检索，至于为啥不开始就用红黑树，也很简单。哈希表要扩容，扩容就要再哈希，再哈希就要重新构建桶，红黑树构建复杂度高，当桶长到一定程度才采用红黑树。

你不会觉得现在就完了吧，怎么可能，对于二叉树来说查找指定数据很快，但是范围查找很慢的。B+ 树？不行不行，那个很复杂的，小数据量不合适。跳表，是一种具有索引链表的有序链表，最底层是全量数据，上层的链表起到的索引左右，可以具有多层索引，不仅查找指定值快，而且擅长范围查找。

---

至此，本文告一段落，本文仅仅是抛砖引玉，数据结构的体量与深度大的很。以有涯随无涯，殆已！
