# Spring Boot 启动流程

- 目录
  - [启动类](#启动类)
  - [SpringApplication 构造方法](#SpringApplication-构造方法)
  - [run 方法](#run-方法)
    - [StopWatch](#StopWatch)
    - [异常记录](#异常记录)
    - [加载监听器实例](#加载监听器实例)
    - [准备环境变量](#准备环境变量)
    - [打印 bannner](#打印-bannner)
    - [准备 ApplicationContext 容器](#准备-ApplicationContext-容器)
    - [刷新 ApplicationContext 容器](#刷新-ApplicationContext-容器)
    - [刷新后的后置处理](#刷新后的后置处理)
    - [callRunners](#callRunners)
    - [报告异常](#报告异常)
    - [返回容器对象](#返回容器对象)
  - [prepareContext](#prepareContext) 
    - [流程](#流程)
    - [load](#load)
  - [refreshContext](#refreshContext)
    - [prepareRefresh](#prepareRefresh)
    - [prepareBeanFactory](#prepareBeanFactory)
    - [postProcessBeanFactory](#postProcessBeanFactory)
    - [invokeBeanFactoryPostProcessors](#invokeBeanFactoryPostProcessors)
    - [registerBeanPostProcessors](#registerBeanPostProcessors)
    - [initMessageSource](#initMessageSource)
    - [initApplicationEventMulticaster](#initApplicationEventMulticaster)
    - [onRefresh](#onRefresh)
    - [registerListeners](#registerListeners)
    - [finishBeanFactoryInitialization](#finishBeanFactoryInitialization)
    - [finishRefresh](#finishRefresh)
    - [resetCommonCaches](#resetCommonCaches)
  - [小结](#小结)
  
Spring Boot 的启动流程（基于 Spring Boot 2.2.X）。

### 启动类

想要运行一个 Spring Boot 项目，引入相关 starter 和相关依赖后，再编写一个启动类，并在这个启动类上使用 @SpringBootApplication 注解，就可以启动运行项目了，示例如下：

```java
// MainApplication.java

@SpringBootApplication
public class MainApplication {
    public static void main(String[] args) {
        SpringApplication.run(MainApplication.class, args);
    }
}
```

Spring Boot 的启动类是 Spring Boot 启动的入口，可以看到的是 @SpringBootApplication 和 main 方法中的 SpringApplication.run(BootApplication.class, args)。@SpringBootApplication标识该类是SpringBoot 的启动类，这是后话，本文的重点是 **SpringApplication.run(BootApplication.class, args)**。

SpringApplication.run(BootApplication.class, args) 调用的是 SpringApplication 类中的静态 run 方法，这个方法会创建一个 SpringApplication 实例并调用实例的 run 方法。

```java
// SpringApplication.java#run
public static ConfigurableApplicationContext run(Class<?>[] primarySources, String[] args) {
    return new SpringApplication(primarySources).run(args);
}
```

### SpringApplication 构造方法

SpringApplication 构造方法如下：

```java
// SpringApplication.java#SpringApplication
@SuppressWarnings({ "unchecked", "rawtypes" })
public SpringApplication(ResourceLoader resourceLoader, Class<?>... primarySources) {
    this.resourceLoader = resourceLoader;
    Assert.notNull(primarySources, "PrimarySources must not be null");
    // 主配置源类,也就是启动类
    this.primarySources = new LinkedHashSet<>(Arrays.asList(primarySources));
    // 根据 classpath 下是否有相应的类确定 Spring 容器类型,如：REACTIVE、SERVLET
    this.webApplicationType = WebApplicationType.deduceFromClasspath();
    // getSpringFactoriesInstances 获取工厂实例方法，他涉及两个是重要的方法，loadSpringFactories 和 createSpringFactoriesInstances
    // loadSpringFactories 作用：从 META-INF/spring.factories 中加载类的全路径，而且存储到 cache 中。
    // createSpringFactoriesInstances 作用：根据类的全路径通过反射创建类的实例
    // 加载 ApplicationContextInitializer 初始化类
    setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));
    // 加载 ApplicationListener 初始化类
    setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));
    // main 方法所在的类
    this.mainApplicationClass = deduceMainApplicationClass();
}
```

SpringApplication 构造函数除了配置启动类和 Spring 容器类型，还会加载 ApplicationContextInitializer 和 ApplicationListener 初始化类。

ApplicationContextInitializer 和 ApplicationListener 都是通过 getSpringFactoriesInstances 方法获取实例的，getSpringFactoriesInstances 方法里面两个关键的方法是 loadFactoryNames 方法和 createSpringFactoriesInstances 方法。

```java
// SpringApplication.java#getSpringFactoriesInstances
private <T> Collection<T> getSpringFactoriesInstances(Class<T> type, Class<?>[] parameterTypes, Object... args) {
    ClassLoader classLoader = getClassLoader();
    // Use names and ensure unique to protect against duplicates
    Set<String> names = new LinkedHashSet<>(SpringFactoriesLoader.loadFactoryNames(type, classLoader));
    List<T> instances = createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names);
    AnnotationAwareOrderComparator.sort(instances);
    return instances;
}
```

loadFactoryNames 方法作用是从 META-INF/spring.factories 中加载类的全路径，并存储到常量 cache 中。

```java
// SpringFactoriesLoader.java$cache
private static final Map<ClassLoader, MultiValueMap<String, String>> cache = new ConcurrentReferenceHashMap<>();
``` 

createSpringFactoriesInstances 方法是利用反射，根据全路径名和类型获取对象实例。

### run 方法

SpringApplication 实例的 run 方法，包含整个 Spring Boot 启动流程。

```java
// SpringApplication.java#run
public ConfigurableApplicationContext run(String... args) {
    // 创建计时器 StopWatch，用于统计 run 启动过程花费时间
    StopWatch stopWatch = new StopWatch();
    // 开始计时
    stopWatch.start();
    // 容器对象
    ConfigurableApplicationContext context = null;
    // exceptionReporters 集合中存储异常报告器，用来报告 SpringBoot 启动过程的异常
    Collection<SpringBootExceptionReporter> exceptionReporters = new ArrayList<>();
    // 配置 headless 属性，即 "java.awt.headless" 属性，默认为 ture
    // 设置该应用程序,即使没有检测到显示器,也允许其启动
    configureHeadlessProperty(); 
    // 从 spring.factories 配置文件中加载 EventPublishingRunListener 对象并赋值给 SpringApplicationRunListeners
    // EventPublishingRunListener对象主要用来发布 SpringBoot 启动过程中内置的一些生命周期事件，标志不同的启动阶段
    // 和 SpringApplication 构造中 setInitializers、setListeners 方法类似，getRunListeners 方法调用了 getSpringFactoriesInstances 方法。
    SpringApplicationRunListeners listeners = getRunListeners(args);
    // 发布 ApplicationStartingEvent 事件，表示 SpringApplication 开始启动
    listeners.starting();
    try {
        // 创建 ApplicationArguments 对象，封装了 args 参数
        ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);
        // 准备环境变量，包括系统变量、环境变量、命令行参数、默认变量、servlet 相关配置变量、随机值、JNDI 属性值，以及配置文件（比如 application.properties）等
        // 发布 ApplicationEnvironmentPreparedEvent 事件
        ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments);
        // 配置 spring.beaninfo.ignore 属性，默认为 true，配置忽略的 BeanInfo 即跳过搜索 BeanInfo classes.
        configureIgnoreBeanInfo(environment);
        // 控制台打印 SpringBoot 的 bannner 标志
        Banner printedBanner = printBanner(environment);
        // 根据不同类型创建不同类型的 Spring ApplicationContext 容器
        // 这里是 servlet 环境，所以创建的是 AnnotationConfigServletWebServerApplicationContext 容器对象
        context = createApplicationContext();
        // 从 spring.factories 配置文件中加载异常报告期实例，这里加载的是 FailureAnalyzers
        // 注意 FailureAnalyzers 的构造器要传入 ConfigurableApplicationContext，因为要从 context 中获取 beanFactory 和 environment
        exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class,
                new Class[] { ConfigurableApplicationContext.class }, context);
        // 为刚创建的 AnnotationConfigServletWebServerApplicationContext 容器对象进行初始化工作
        prepareContext(context, environment, listeners, applicationArguments, printedBanner);
        // 刷新容器，这一步至关重要
        refreshContext(context);
        // 执行刷新容器后的后置处理逻辑，注意这里为空方法
        afterRefresh(context, applicationArguments);
        // 停止 StopWatch 计时
        stopWatch.stop();
        // 打印日志
        if (this.logStartupInfo) {
            new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);
        }
        // 发布 ApplicationStartedEvent 事件，标志spring容器已经刷新完毕，所有的 bean 实例都已经加载完毕
        listeners.started(context);
        // 调用 ApplicationRunner 和 CommandLineRunner 的 run 方法，实现 Spring 容器启动后需要做的一些东西，如加载一些业务数据等
        callRunners(context, applicationArguments);
    }
    catch (Throwable ex) {
        // 若启动过程中抛出异常，此时用 FailureAnalyzers 来报告异常
        // 发布 ApplicationFailedEvent 事件，标志 SpringBoot 启动失败
        handleRunFailure(context, ex, exceptionReporters, listeners);
        throw new IllegalStateException(ex);
    }

    try {
        // 发布 ApplicationReadyEvent 事件，标志 SpringApplication 已经正在运行即已经成功启动，可以接收服务请求了。
        listeners.running(context);
    }
    catch (Throwable ex) {
        // 若出现异常，此时仅仅报告异常，而不会发布任何事件
        handleRunFailure(context, ex, exceptionReporters, null);
        throw new IllegalStateException(ex);
    }
    // 最终返回容器
    return context;
}
```

run 方法主要流程：

#### StopWatch

创建计时器并用于统计启动过程耗时。

```java
// SpringApplication.java#run
StopWatch stopWatch = new StopWatch();
stopWatch.start();
// ...
stopWatch.stop();
```

#### 异常记录

创建异常报告容器并记录和报告启动过程中的异常。

```java
// SpringApplication.java#run
Collection<SpringBootExceptionReporter> exceptionReporters = new ArrayList<>();
// ...
exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class,
                new Class[] { ConfigurableApplicationContext.class }, context);

// 出现异常则报告异常
handleRunFailure(context, ex, exceptionReporters, listeners);
handleRunFailure(context, ex, exceptionReporters, null);

// FailureAnalyzers.java
final class FailureAnalyzers implements SpringBootExceptionReporter {
// ...
}
```

#### 加载监听器实例

加载监听器实例，并在启动流程的不同阶段发布事件

```java
// SpringApplication.java#run
SpringApplicationRunListeners listeners = getRunListeners(args);
```

和 SpringApplication 构造函数获取 ApplicationContextInitializer 和 ApplicationListener 实例类似，getRunListeners 方法也通过 getSpringFactoriesInstances 方法获取实例的，getSpringFactoriesInstances 方法里面两个关键的方法是 loadFactoryNames 方法和 createSpringFactoriesInstances 方法。

```java
// SpringApplication.java#getSpringFactoriesInstances
private <T> Collection<T> getSpringFactoriesInstances(Class<T> type, Class<?>[] parameterTypes, Object... args) {
    ClassLoader classLoader = getClassLoader();
    // Use names and ensure unique to protect against duplicates
    Set<String> names = new LinkedHashSet<>(SpringFactoriesLoader.loadFactoryNames(type, classLoader));
    List<T> instances = createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names);
    AnnotationAwareOrderComparator.sort(instances);
    return instances;
}
```

loadFactoryNames 方法作用是从 META-INF/spring.factories 中加载类的全路径，并存储到常量 cache 中。

```java
// SpringFactoriesLoader.java$cache
private static final Map<ClassLoader, MultiValueMap<String, String>> cache = new ConcurrentReferenceHashMap<>();
``` 

createSpringFactoriesInstances 方法是利用反射，根据全路径名和类型获取对象实例。

事件的发布是遍历所有监听器，并调用对应的事件方法。以发布 ApplicationStartingEvent 事件为例。

```java
// SpringApplication.java#run
listeners.starting();

// SpringApplicationRunListeners.java#starting
void starting() {
    for (SpringApplicationRunListener listener : this.listeners) {
        listener.starting();
    }
}

// EventPublishingRunListener.java#starting（为例）
@Override
public void starting() {
    this.initialMulticaster.multicastEvent(new ApplicationStartingEvent(this.application, this.args));
}
```

#### 准备环境变量

准备环境变量，包括系统变量、环境变量、命令行参数、默认变量、servlet 相关配置变量、随机值、JNDI 属性值，以及配置文件（比如 application.properties）等，并发布 ApplicationEnvironmentPreparedEvent 事件。

```java
// SpringApplication.java#run
ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments);

// SpringApplication.java#prepareEnvironment
private ConfigurableEnvironment prepareEnvironment(SpringApplicationRunListeners listeners,
			ApplicationArguments applicationArguments) {
    // Create and configure the environment
    ConfigurableEnvironment environment = getOrCreateEnvironment();
    configureEnvironment(environment, applicationArguments.getSourceArgs());
    ConfigurationPropertySources.attach(environment);
    listeners.environmentPrepared(environment);
    bindToSpringApplication(environment);
    if (!this.isCustomEnvironment) {
        environment = new EnvironmentConverter(getClassLoader()).convertEnvironmentIfNecessary(environment,
                deduceEnvironmentClass());
    }
    ConfigurationPropertySources.attach(environment);
    return environment;
}
```

### 打印 bannner

打印 bannner，可自定义。

```java
// SpringApplication.java#run
Banner printedBanner = printBanner(environment);
```

#### 创建 ApplicationContext 容器

创建 ApplicationContext 容器，此处是 servlet 环境，所以创建的是 AnnotationConfigServletWebServerApplicationContext 容器对象。

AnnotationConfigServletWebServerApplicationContext 构造函数会实例化 AnnotatedBeanDefinitionReader 和 ClassPathBeanDefinitionScanner。

- AnnotatedBeanDefinitionReader：注解配置读取器，加了特定注解（如 @Service、@Repository）的类进行读取转化成 BeanDefinition 对象（BeanDefinition 是 Spring 中极其重要的一个概念，它存储了 bean 对象的所有特征信息，如是否单例，是否懒加载，factoryBeanName 等）。
- ClassPathBeanDefinitionScanner：路径扫描器，对用户指定的包目录进行扫描查找 bean 对象。

AnnotatedBeanDefinitionReader 构造函数会执行 registerAnnotationConfigProcessors 方法，为容器添加一些内置组件了，其中最主要的组件便是 ConfigurationClassPostProcessor 和 AutowiredAnnotationBeanPostProcessor ，前者是一个 beanFactory 后置处理器，用来完成 bean 的扫描与注入工作，后者是一个 bean 后置处理器，用来完成 @AutoWired 自动注入。

```java
// SpringApplication.java#run
ConfigurableApplicationContext context = null;
// ...
context = createApplicationContext();

// SpringApplication.java#createApplicationContext
protected ConfigurableApplicationContext createApplicationContext() {
    Class<?> contextClass = this.applicationContextClass;
    if (contextClass == null) {
        try {
            switch (this.webApplicationType) {
            case SERVLET:
                contextClass = Class.forName(DEFAULT_SERVLET_WEB_CONTEXT_CLASS);
                break;
            case REACTIVE:
                contextClass = Class.forName(DEFAULT_REACTIVE_WEB_CONTEXT_CLASS);
                break;
            default:
                contextClass = Class.forName(DEFAULT_CONTEXT_CLASS);
            }
        }
        catch (ClassNotFoundException ex) {
            throw new IllegalStateException(
                    "Unable create a default ApplicationContext, please specify an ApplicationContextClass", ex);
        }
    }
    return (ConfigurableApplicationContext) BeanUtils.instantiateClass(contextClass);
}

# AnnotationConfigServletWebServerApplicationContext.java#AnnotationConfigServletWebServerApplicationContext
public AnnotationConfigServletWebServerApplicationContext() {
    this.reader = new AnnotatedBeanDefinitionReader(this);
    this.scanner = new ClassPathBeanDefinitionScanner(this);
}

# AnnotatedBeanDefinitionReader.java#AnnotatedBeanDefinitionReader
public AnnotatedBeanDefinitionReader(BeanDefinitionRegistry registry, Environment environment) {
    Assert.notNull(registry, "BeanDefinitionRegistry must not be null");
    Assert.notNull(environment, "Environment must not be null");
    this.registry = registry;
    this.conditionEvaluator = new ConditionEvaluator(registry, environment, null);
    AnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry);
}
```

#### 准备 ApplicationContext 容器

为刚创建的容器对象做一些初始化工作，准备一些容器属性值等，对 ApplicationContext 应用一些相关的后置处理和调用各个 ApplicationContextInitializer 的初始化方法来执行一些初始化逻辑等。（未完待续，[prepareContext](#prepareContext) ）

#### 刷新 ApplicationContext 容器

这一步至关重要。如调用 beanFactory 的后置处理器，注册 BeanPostProcessor 后置处理器，初始化事件广播器且广播事件，初始化剩下的单例 bean 和 Spring Boot 创建内嵌的 Tomcat 服务器等重要且复杂的逻辑都在这里实现。（未完待续，[refreshContext](#refreshContext)）

#### 刷新后的后置处理

执行刷新 ApplicationContext 容器后的后置处理逻辑，注意这里为空方法，用于扩展。

```java
// SpringApplication.java#run
afterRefresh(context, applicationArguments);
```

#### callRunners

调用 ApplicationRunner 和 CommandLineRunner 的 run 方法，我们实现这两个接口可以在 spring 容器启动后需要的一些东西比如加载一些业务数据等。

#### 报告异常

若启动过程中抛出异常，此时用 FailureAnalyzers 来报告异常。

#### 返回容器对象

若启动过程正常，最终返回容器对象。

### prepareContext

```java
// SpringApplication.java#run
prepareContext(context, environment, listeners, applicationArguments, printedBanner);

// SpringApplication.java#prepareContext
private void prepareContext(ConfigurableApplicationContext context, ConfigurableEnvironment environment,
        SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments, Banner printedBanner) {
    // 为 AnnotationConfigServletWebServerApplicationContext 的属性 AnnotatedBeanDefinitionReader 和 ClassPathBeanDefinitionScanner 设置 environgment 属性
    context.setEnvironment(environment);
    // 对 ApplicationContext 应用一些相关的后置处理，比如设置 resourceLoader 属性等
    postProcessApplicationContext(context);
    // 在容器刷新前调用各个 ApplicationContextInitializer 的初始化方法
    applyInitializers(context);
    // 发布 ApplicationContextInitializedEvent 事件，标志 Context 容器被创建且已准备好
    listeners.contextPrepared(context);
    if (this.logStartupInfo) {
        logStartupInfo(context.getParent() == null);
        logStartupProfileInfo(context);
    }
    // 从 context 容器中获取 beanFactory，并向 beanFactory 中注册一些单例 bean，比如 applicationArguments，printedBanner
    ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();
     beanFactory.registerSingleton("springApplicationArguments", applicationArguments);
    if (printedBanner != null) {
        // 设置 banner
        beanFactory.registerSingleton("springBootBanner", printedBanner);
    }
    if (beanFactory instanceof DefaultListableBeanFactory) {
        ((DefaultListableBeanFactory) beanFactory)
                .setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding);
    }
    if (this.lazyInitialization) {
        context.addBeanFactoryPostProcessor(new LazyInitializationBeanFactoryPostProcessor());
    }
    // 获取所有启动类指定的参数，可以是多个
    Set<Object> sources = getAllSources();
    Assert.notEmpty(sources, "Sources must not be empty");
    // 加载启动类，将启动类注入容器
    load(context, sources.toArray(new Object[0]));
    // 发布 ApplicationPreparedEvent 事件，标志 Context 容器已经准备完成
    listeners.contextLoaded(context);
}
```

#### 流程

prepareContext 方法是为刚创建的 AnnotationConfigServletWebServerApplicationContext 容器对象做一些初始化工作，准备一些容器属性值等。如：
- 为 AnnotationConfigServletWebServerApplicationContext 的属性 AnnotatedBeanDefinitionReader 和 ClassPathBeanDefinitionScanner 设置 environgment 属性。
- postProcessApplicationContext(context) 对 ApplicationContext 应用一些相关的后置处理，比如设置 resourceLoader 属性等。
- applyInitializers(context) 在容器刷新前调用各个 ApplicationContextInitializer 的初始化方法。
- listeners.contextPrepared(context) 发布 ApplicationContextInitializedEvent 事件，标志 Context 容器被创建且已准备好。
- context.getBeanFactory() 从 Context 容器中获取 beanFactory，并向 beanFactory 中注册一些单例 bean，比如 applicationArguments，printedBanner。 
- getAllSources() 获取所有启动类参数，可以是多个。
- load(context, sources.toArray(new Object[0])) 加载启动类，将启动类注入容器。
- listeners.contextLoaded(context) 发布 ApplicationPreparedEvent 事件，标志 Context 容器已经准备完成。

#### load

load 方法负责加载启动类，将启动类注入容器。这里会遍历判断启动类是否被 Component 注解，如果是就注册到 beanDefinition 中，添加到容器的 beanDefinitionMap 中，如此一来，我们的启动类就被包装成 AnnotatedGenericBeanDefinition 了，后续启动类的处理都基于该对象了。注意：启动类的注解 @SpringBootApplication 包含了 @SpringBootConfiguration，亦包含了 @Configuration，亦包含了 @Component。

这里比较关键的流程是 AnnotatedBeanDefinitionReader.java#doRegisterBean 方法，这里用来解析 Spring 配置类，最终解析成 BeanDefinition 注册到容器中。

```java
// SpringApplication.java#prepareContext
load(context, sources.toArray(new Object[0]));

// BeanDefinitionLoader.java#load
private int load(Class<?> source) {
    if (isGroovyPresent() && GroovyBeanDefinitionSource.class.isAssignableFrom(source)) {
        // Any GroovyLoaders added in beans{} DSL can contribute beans here
        GroovyBeanDefinitionSource loader = BeanUtils.instantiateClass(source, GroovyBeanDefinitionSource.class);
        load(loader);
    }
    if (isComponent(source)) {
        this.annotatedReader.register(source);
        return 1;
    }
    return 0;
}

// AnnotatedBeanDefinitionReader.java#doRegisterBean    
private <T> void doRegisterBean(Class<T> beanClass, @Nullable String name,
        @Nullable Class<? extends Annotation>[] qualifiers, @Nullable Supplier<T> supplier,
        @Nullable BeanDefinitionCustomizer[] customizers) {
    // 解析传入的配置类，实际上这个方法既可以解析配置类，也可以解析 Spring bean 对象
    AnnotatedGenericBeanDefinition abd = new AnnotatedGenericBeanDefinition(beanClass);
    // 判断是否需要跳过，判断依据是此类上有没有 @Conditional 注解
    if (this.conditionEvaluator.shouldSkip(abd.getMetadata())) {
        return;
    }

    abd.setInstanceSupplier(supplier);
    ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(abd);
    abd.setScope(scopeMetadata.getScopeName());
    String beanName = (name != null ? name : this.beanNameGenerator.generateBeanName(abd, this.registry));

    // 处理类上的通用注解
    AnnotationConfigUtils.processCommonDefinitionAnnotations(abd);
    if (qualifiers != null) {
        for (Class<? extends Annotation> qualifier : qualifiers) {
            if (Primary.class == qualifier) {
                abd.setPrimary(true);
            }
            else if (Lazy.class == qualifier) {
                abd.setLazyInit(true);
            }
            else {
                abd.addQualifier(new AutowireCandidateQualifier(qualifier));
            }
        }
    }
    if (customizers != null) {
        // 封装成一个 BeanDefinitionHolder
        for (BeanDefinitionCustomizer customizer : customizers) {
            customizer.customize(abd);
        }
    }

    BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(abd, beanName);
    definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);
    // 将 BeanDefinitionHolder 作为 beanDefinition 注册到给定的 bean factory(this.registry) 中
    BeanDefinitionReaderUtils.registerBeanDefbean factory 中tion(definitionHolder, this.registry);
}
```

### refreshContext

refreshContext 是 Spring Boot 启动流程的核心，负责刷新容器。

```java
// SpringApplication.java#run
refreshContext(context);

// AbstractApplicationContext.java#refresh
public void refresh() throws BeansException, IllegalStateException {
    synchronized (this.startupShutdownMonitor) {
        // 为刷新容器做准备：记录启动事件、标记容器为激活、初始化上下文环境、验证必填属性等
        prepareRefresh();

        // 这步比较重要,通知子类创建 beanFactory 并获取子类创建的 beanFactory。
        // 这步完成后配置文件就被解析成一个个 bean 定义，注册到 BeanFactory（但是未被初始化，仅将信息写到了 beanDefination 的 map 中）
        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();

        // ApplicationContext 获取 beanFactory 之后，开始为 Context 准备的 beanFactory，即配置 beanFacotry 属性。
        // 1. 设置类加载器
        // 2. 设置 EL 表达式解析器（bean 创建完成填充属性时使用）和属性注册解析器 
        // 3. 利用 beanPostProcessor 的特性给各种 Aware 接口的实现类注入 ApplicationContext 中对应的属性
        // 4. 设置各种 Aware 接口的实现类为忽略自动装配 
        // 5. 设置自动装配类（BeanFactory，ResourceLoader，ApplicationEventPublisher，ApplicationContext）
        // 6. 如果 BeanFactory 中存在 loadTimeWeaver 的 bean，那么需要添加动态织入功能 
        // 7. 注册各种可用组件（environment，systemProperties，systemEnvironment）
        prepareBeanFactory(beanFactory);

        try {
            // 为 ApplicationContext 的子类(第二次)设置 BeanPostProcessor 实现类 WebApplicationContextServletContextAwareProcessor。
            postProcessBeanFactory(beanFactory);

            // Invoke factory processors registered as beans in the context.
            // 实例化并执行 context 中 bean 中注册的 BeanFactoryPostProcessor 中的 postProcessBeanFactory() 方法。。
            invokeBeanFactoryPostProcessors(beanFactory);

            // 再次（第三次）设置 BeanPostProcessor。
            registerBeanPostProcessors(beanFactory);

            // Initialize message source for this context.
            // 实例化并注册 MessageSource 类，MessageSource 是国际化相关的接口。
            initMessageSource();

            // Initialize event multicaster for this context.
            // 初始化 ApplicationEventMulticaster（事件广播器），首先判断 beanFactory 容器中是否存在 applicationEventMulticaster；
            // 如果存在，则用 beanFactory 中的 applicationEventMulticaster；如果不存在则使用新建 SimpleApplicationEventMulticaster。
            // ApplicationContext 会通过广播器发送事件，负责监听事件的 listener 会负责处理事件。
            initApplicationEventMulticaster();

            // Initialize other special beans in specific context subclasses.
            // 在一些特殊的 ApplicationContext子类中实例化一些特殊的 bean. 是个空方法
            // 例如 ServletWebServerApplicationContext（AnnotationConfigServletWebServerApplicationContext的父类）会初始化 TomcatWebServer，并启动这个 server。
            onRefresh();

            // Check for listener beans and register them.
            // 为 ApplicationEventMulticaster 注册监听 listener(ApplicationListener)。
            registerListeners();

            // Instantiate all remaining (non-lazy-init) singletons.
            // 实例化所有剩余的非惰性加载的单例 bean。
            //
            // 虽然此时 java bean已经实例化，但是其依赖自动注入的 bean却不再此时注入，而是等到用到的时候再去获取，
            // 所以这里不会出现循环依赖的问题。
            // 一个 spring bean 的初始化过程如下：
            //        1. 执行构造器
            //        2. BeanPostProcessor的postProcessBeforeInitialization方法
            //        3. InitializingBean的afterPropertiesSet方法
            //        4，@Bean注解的initMethod方法
            //        5，BeanPostProcessor的postProcessAfterInitialization方法
            //        6，DisposableBean的destroy方法
            //        7，@Bean注解的destroyMethod方法
            finishBeanFactoryInitialization(beanFactory);

            // Last step: publish corresponding event.
            // 实例化LifecycleProcessor并执行其 onRefresh()方法，刷新上下文，启动一些需要在初始化阶段启动的类（实现了Lifecycle接口的类）
            // 发布ContextRefreshedEvent事件，这个应该是表示上下文启动完成的事件
            /**
             * 通过spring的事件发布机制发布ContextRefreshedEvent事件，以保证对应的监听器做进一步的处理
             * 即对那种在spring启动后需要处理的一些类，这些类实现了ApplicationListener<ContextRefreshedEvent>，
             * 这里就是要触发这些类的执行(执行onApplicationEvent方法)
             * 另外，spring的内置Event有ContextClosedEvent、ContextRefreshedEvent、ContextStartedEvent、ContextStoppedEvent、RequestHandleEvent
             * 完成初始化，通知生命周期处理器lifeCycleProcessor刷新过程，同时发出ContextRefreshEvent通知其他人
             */
            finishRefresh();
        }

        catch (BeansException ex) {
            if (logger.isWarnEnabled()) {
                logger.warn("Exception encountered during context initialization - " +
                        "cancelling refresh attempt: " + ex);
            }

            // Destroy already created singletons to avoid dangling resources.
            destroyBeans();

            // Reset 'active' flag.
            cancelRefresh(ex);

            // Propagate exception to caller.
            throw ex;
        }

        finally {
            // Reset common introspection caches in Spring's core, since we
            // might not ever need metadata for singleton beans anymore...
            // 清理单例 bean 的元数据缓存。
            resetCommonCaches();
        }
    }
}
```

#### prepareRefresh

prepareRefresh 方法为刷新容器做准备：记录启动事件、标记容器为激活、初始化上下文环境、验证必填属性等。

```java
// AbstractApplicationContext.java#refresh
prepareRefresh();
```

- obtainFreshBeanFactory

这步比较重要,通知子类创建 beanFactory 并获取子类创建的 beanFactory。

这步完成后配置文件就被解析成一个个 bean 定义，注册到 BeanFactory。但是这些 bean 未被初始化，仅将信息写到了 beanDefination 的 map 中。

```java
// AbstractApplicationContext.java#refresh
ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();

// AbstractApplicationContext.java#obtainFreshBeanFactory
protected ConfigurableListableBeanFactory obtainFreshBeanFactory() {
    // 子类创建 beanFactory
    refreshBeanFactory();
    // 获取子类创建的 beanFactory
    return getBeanFactory();
}

// AbstractRefreshableApplicationContext.java#refreshBeanFactory
protected final void refreshBeanFactory() throws BeansException {
    // 如果 beanFactory 已经存在,就销毁 context 管理的所有 bean,并关闭 BeanFactory,之后会重新初始化一个新的 beanFactory
    if (hasBeanFactory()) {
        destroyBeans();
        closeBeanFactory();
    }
    try {
        // 为上下文创建一个 beanFactory 作为其内部的实例变量
        DefaultListableBeanFactory beanFactory = createBeanFactory();
        beanFactory.setSerializationId(getId());
        customizeBeanFactory(beanFactory);
        loadBeanDefinitions(beanFactory);
        synchronized (this.beanFactoryMonitor) {
            this.beanFactory = beanFactory;
        }
    }
    catch (IOException ex) {
        throw new ApplicationContextException("I/O error parsing bean definition source for " + getDisplayName(), ex);
    }
}
```

#### prepareBeanFactory

ApplicationContext 获取 beanFactory 之后，开始为 Context 准备的 beanFactory，即配置 beanFacotry 属性。

1. 设置类加载器
2. 设置 EL 表达式解析器（bean 创建完成填充属性时使用）和属性注册解析器 
3. （第一次）设置 beanPostProcessor 实现类 ApplicationContextAwareProcessor 给各种 Aware 接口的实现类注入 ApplicationContext 中对应的属性
4. 设置各种 Aware 接口的实现类为忽略自动装配 
5. 设置自动装配类（BeanFactory，ResourceLoader，ApplicationEventPublisher，ApplicationContext）
6. 如果 BeanFactory 中存在 loadTimeWeaver 的 bean，那么需要添加动态织入功能 
7. 注册各种可用组件（environment，systemProperties，systemEnvironment）
 
```java
// AbstractApplicationContext.java#refresh
prepareBeanFactory(beanFactory);

// AbstractApplicationContext.java#prepareBeanFactory
protected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) {
    // 设置类加载器
    beanFactory.setBeanClassLoader(getClassLoader());
    // 设置 BeanExpressionResolver 表达式解析器,主要用来解析 EL 表达式：Bean 初始化完成后填充属性时会用到
    beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));
    // 添加一个属性编辑注册器,该接口有一个方法 registerCustomEditors,用来设置自定义转换器
    beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment()));

    // 设置一个 bean 的后置处理器 ApplicationContextAwareProcessor,用来处理并回调实现了各种 Aware 接口的 Bean，比如获取 ApplicationContext 的 ApplicationContextAware 接口。
    beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));

    // beanFactory.ignoreDependencyInterface(XXX)指定的接口不会被自动注入进去。
    beanFactory.ignoreDependencyInterface(EnvironmentAware.class);
    beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);
    beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);
    beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);
    beanFactory.ignoreDependencyInterface(MessageSourceAware.class);
    beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);

    // 设置几个自动装配规则，例如 beanFactory 则注入 beanFactory;ResourceLoader、ApplicationEventPublisher 和 ApplicationContext 则注入当前对象
    beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);
    beanFactory.registerResolvableDependency(ResourceLoader.class, this);
    beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);
    beanFactory.registerResolvableDependency(ApplicationContext.class, this);

    // 早期注册的 post-processor 将会被添加作为检测内部的应用监听器
    beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));

    // 如果当前 beanFactory 包含 loadTimeWeaver Bean，说明存在类加载期织入 AspectJ
    // 则把当前 beanFactory 交给类加载期 BeanPostProcessor 实现类 LoadTimeWeaverAwareProcessor 来处理，从而实现类加载期织入 AspectJ 的目的。
    if (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {
        beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));
        // Set a temporary ClassLoader for type matching.
        beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));
    }

    // 注册当前容器环境 environment 组件 Bean
    if (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) {
        beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());
    }
    // 注册系统配置 systemProperties 组件 Bean 
    if (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) {
        beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());
    }
    // 注册系统环境 systemEnvironment 组件 Bean
    if (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) {
        beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());
    }
}
```

#### postProcessBeanFactory

为 ApplicationContext 的子类(第二次)设置 BeanPostProcessor 实现类 WebApplicationContextServletContextAwareProcessor。

```java
// AbstractApplicationContext.java#refresh
postProcessBeanFactory(beanFactory);

// ServletWebServerApplicationContext.java#postProcessBeanFactory
@Override
protected void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {
    beanFactory.addBeanPostProcessor(new WebApplicationContextServletContextAwareProcessor(this));
    beanFactory.ignoreDependencyInterface(ServletContextAware.class);
    registerWebApplicationScopes();
}
```

#### invokeBeanFactoryPostProcessors

实例化并执行 context 中 bean 中注册的 BeanFactoryPostProcessor 中的 postProcessBeanFactory() 方法。

invokeBeanFactoryPostProcessors 方法主要用于处理 BeanFactoryPostProcessor 接口。BeanFactoryPostProcessor 接口是 Spring 初始化 Bean 时对外暴露的扩展点，Spring IoC 容器允许 BeanFactoryPostProcessor 在容器实例化任何 Bean 之前读取Bean 的定义，并可以修改它。

```java
// AbstractApplicationContext.java#refresh
postProcessBeanFactory(beanFactory);
```

#### registerBeanPostProcessors

再次（第三次）设置 BeanPostProcessor。

```java
// AbstractApplicationContext.java#refresh
registerBeanPostProcessors(beanFactory);
```

#### initMessageSource

实例化并注册 MessageSource 类，MessageSource 是国际化相关的接口。

```java
// AbstractApplicationContext.java#refresh
initMessageSource();
```

#### initApplicationEventMulticaster

初始化 ApplicationEventMulticaster（事件广播器），首先判断 beanFactory 容器中是否存在 applicationEventMulticaster；如果存在，则用 beanFactory 中的 applicationEventMulticaster；如果不存在则使用新建 SimpleApplicationEventMulticaster。

ApplicationContext 会通过广播器发送事件，负责监听事件的 listener 会负责处理事件。

```java
// AbstractApplicationContext.java#refresh
initApplicationEventMulticaster();

// AbstractApplicationContext.java#initApplicationEventMulticaster
protected void initApplicationEventMulticaster() {
    ConfigurableListableBeanFactory beanFactory = getBeanFactory();
    if (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) {
        this.applicationEventMulticaster =
                beanFactory.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class);
        if (logger.isTraceEnabled()) {
            logger.trace("Using ApplicationEventMulticaster [" + this.applicationEventMulticaster + "]");
        }
    }
    else {
        this.applicationEventMulticaster = new SimpleApplicationEventMulticaster(beanFactory);
        beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, this.applicationEventMulticaster);
        if (logger.isTraceEnabled()) {
            logger.trace("No '" + APPLICATION_EVENT_MULTICASTER_BEAN_NAME + "' bean, using " +
                    "[" + this.applicationEventMulticaster.getClass().getSimpleName() + "]");
        }
    }
}
```

#### onRefresh

onRefresh 方法是个空方法，用于在一些特殊的 ApplicationContext 子类中实例化一些特殊的 bean。

例如 ServletWebServerApplicationContext（AnnotationConfigServletWebServerApplicationContext的父类）会初始化 TomcatWebServer，并启动这个 server。

```java
// AbstractApplicationContext.java#onRefresh        
onRefresh();

// ServletWebServerApplicationContext.java#refresh
@Override
protected void onRefresh() {
    super.onRefresh();
    try {
        createWebServer();
    }
    catch (Throwable ex) {
        throw new ApplicationContextException("Unable to start web server", ex);
    }
}
```

#### registerListeners

为 ApplicationEventMulticaster 注册监听 listener(ApplicationListener)。

```java
// AbstractApplicationContext.java#refresh        
registerListeners();
```

#### finishBeanFactoryInitialization

这个阶段会实例化所有剩余的非惰性加载的单例 bean。

beanFactory.preInstantiateSingletons() 是 finishBeanFactoryInitialization 方法的关键行为，这块进入的是 DefaultListableBeanFactory 类。DefaultListableBeanFactory 就是我们的 beanFactory，preInstantiateSingletons 方法负责实例化非惰性加载的单例 bean。该方法遍历 beanDefinitionNames 实例化 bean，其中需要区别 factoryBean 和普通 bean。

factoryBean 是一种特殊的 bean，它是个工厂 bean，可以自己创建 bean 实例，如果一个类实现了 factoryBean 接口，则该类可以自己定义创建实例对象的方法，只需要实现它的 getObject() 方法。为了区分 factoryBean 和 factoryBean 创建的 bean 实例，Spring 通过 “&” 前缀区分。假设我们的 beanName 为 apple，则 getBean("apple") 获得的是 AppleFactoryBean 通过 getObject() 方法创建的 bean 实例；而 getBean("&apple") 获得的是 AppleFactoryBean 本身。

下面中点是 getBean 方法，他调用的 doGetBean 方法是真正进行实例化 bean 的地方。（未完待续，[Bean 的实例化]()）

```java
// AbstractApplicationContext.java#refresh        
finishBeanFactoryInitialization(beanFactory);

// AbstractApplicationContext.java#finishBeanFactoryInitialization        
protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) {
    // Initialize conversion service for this context.
    // 初始化上下文的转换服务，ConversionService 是一个类型转换接口
    if (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &&
            beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) {
        beanFactory.setConversionService(
                beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));
    }

    // Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.
    // 初始化 LoadTimeWeaverAware Bean，以便尽早注册其转换器。
    String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false);
    for (String weaverAwareName : weaverAwareNames) {
        getBean(weaverAwareName);
    }

    // Stop using the temporary ClassLoader for type matching.
    // 停止使用临时的 ClassLoader 进行类型匹配。
    beanFactory.setTempClassLoader(null);

    // Allow for caching all bean definition metadata, not expecting further changes.
    // 设置 beanDefinition 元数据 不可以再修改
    beanFactory.freezeConfiguration();

    // Instantiate all remaining (non-lazy-init) singletons.
    // 实例化所有的非懒加载单例。
    beanFactory.preInstantiateSingletons();
}

// DefaultListableBeanFactory.java#preInstantiateSingletons
@Override
public void preInstantiateSingletons() throws BeansException {
    if (logger.isTraceEnabled()) {
        logger.trace("Pre-instantiating singletons in " + this);
    }

    // Iterate over a copy to allow for init methods which in turn register new bean definitions.
    // While this may not be part of the regular factory bootstrap, it does otherwise work fine.
    // 将 beanDefinitionNames 放到集合中
    List<String> beanNames = new ArrayList<>(this.beanDefinitionNames);

    // Trigger initialization of all non-lazy singleton beans...
    // 遍历 beanDefinitionNames 集合
    for (String beanName : beanNames) {
        // 获取beanName对应的 MergedBeanDefinition,MergedBeanDefinition 来表示 "合并的 bean 定义"。
        RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);
        // MergedBeanDefinition 不是抽象 & 是单例 & 不是懒加载
        if (!bd.isAbstract() && bd.isSingleton() && !bd.isLazyInit()) {
            // 是否为 factoryBean
            if (isFactoryBean(beanName)) {
                // 通过 beanName 获取 factoryBean 实例
                // 通过 getBean(&beanName) 拿到的是 factoryBean 本身；通过 getBean(beanName) 拿到的是 factoryBean 创建的 bean 实例
                Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);
                if (bean instanceof FactoryBean) {
                    FactoryBean<?> factory = (FactoryBean<?>) bean;
                    // 判断这个 factoryBean 是否希望急切的初始化
                    boolean isEagerInit;
                    if (System.getSecurityManager() != null && factory instanceof SmartFactoryBean) {
                        isEagerInit = AccessController.doPrivileged(
                                (PrivilegedAction<Boolean>) ((SmartFactoryBean<?>) factory)::isEagerInit,
                                getAccessControlContext());
                    }
                    else {
                        isEagerInit = (factory instanceof SmartFactoryBean &&
                                ((SmartFactoryBean<?>) factory).isEagerInit());
                    }
                    // 如果希望急切的初始化，则通过 beanName 获取 bean 实例
                    if (isEagerInit) {
                        getBean(beanName);
                    }
                }
            }
            else {
                // 如果 beanName 对应的 bean 不是 FactoryBean，只是普通 bean，通过 beanName 获取 bean 实例
                getBean(beanName);
            }
        }
    }

    // Trigger post-initialization callback for all applicable beans...
    // 遍历 beanDefinitionNames 集合，触发所有 SmartInitializingSingleton 的后初始化回调
    for (String beanName : beanNames) {
        // 拿到 beanName 对应的 bean 实例
        Object singletonInstance = getSingleton(beanName);
        // 判断 singletonInstance 是否实现了 SmartInitializingSingleton 接口
        if (singletonInstance instanceof SmartInitializingSingleton) {
            SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;
            if (System.getSecurityManager() != null) {
                // 触发 SmartInitializingSingleton 实现类的 afterSingletonsInstantiated 方法
                AccessController.doPrivileged((PrivilegedAction<Object>) () -> {
                    smartSingleton.afterSingletonsInstantiated();
                    return null;
                }, getAccessControlContext());
            }
            else {
                smartSingleton.afterSingletonsInstantiated();
            }
        }
    }
}

// FactoryBean.java
public interface FactoryBean<T> {

    String OBJECT_TYPE_ATTRIBUTE = "factoryBeanObjectType";

    // 该 factory 生产的 bean 实例
    @Nullable
    T getObject() throws Exception;

    // 该 factory 生产的 bean class
    @Nullable
    Class<?> getObjectType();

    // 该Factory生产的Bean是否为单例
    default boolean isSingleton() {
        return true;
    }

}

# AbstractBeanFactory.java#getBean
@Override
public Object getBean(String name) throws BeansException {
    return doGetBean(name, null, null, false);
}

# AbstractBeanFactory.java#doGetBean

```

#### finishRefresh

完成容器的刷新,调用 LifecycleProcessor.onRefresh(),以及发布 ContextRefreshedEvent 事件。

```java
// AbstractApplicationContext.java#refresh        
finishRefresh();

// AbstractApplicationContext.java#finishRefresh        
protected void finishRefresh() {
   // 清空上下文级别的源信息缓存(比如扫描的ASM元数据)
   clearResourceCaches();

   // 初始化上下文的生命周期处理器
   initLifecycleProcessor();

   // 首先获取一个生命周期处理器,然后调用它的onRefresh方法
   getLifecycleProcessor().onRefresh();

   // 发布最后的事件ContextRefreshedEvent
   publishEvent(new ContextRefreshedEvent(this));

   // 如果配置了MBeanServer,就完成在MbeanServer上的注册
   LiveBeansView.registerApplicationContext(this);
}
```

#### resetCommonCaches

最后清理单例 bean 的元数据缓存。

```java
// AbstractApplicationContext.java#refresh        
resetCommonCaches();

// AbstractApplicationContext.java#resetCommonCaches        
protected void resetCommonCaches() {
    ReflectionUtils.clearCache();
    AnnotationUtils.clearCache();
    ResolvableType.clearCache();
    CachedIntrospectionResults.clearClassLoader(getClassLoader());
}
```

### 小结

设计一个 IOC 容器至少拥有分为 3 个基本组成：

- 为了生成 bean，需要 beanFactory（DefaultListableBeanFactory）。
- 读取并解析 bean 的注解，转化成 bean 定义信息，需要注解配置读取器（AnnotatedBeanDefinitionReader）。
- 对指定路径的 bean 进行扫描读取，需要路径扫描器（ClassPathBeanDefinitionScanner）。

AnnotationConfigApplicationContext 是 Spring Boot IOC 容器的入口，具体实现是 AnnotationConfigReactiveWebApplicationContext 类。
在 createApplicationContext 阶段创建容器的时候会创建一个 beanFactory 是 DefaultListableBeanFactory 的 AnnotationConfigServletWebServerApplicationContext 实例，它的构造函数会实例化 AnnotatedBeanDefinitionReader（注解配置读取器） 和 ClassPathBeanDefinitionScanner（路径扫描器），为后续 refreshContext 做准备。