# 使用消息队列需要考虑的问题

对于大部分应用我们使用消息队列进行解耦、削峰、异步，但这也伴随着降低系统可用性和增加系统复杂度的问题，在一些严格的业务场景下我们必须要采取相应的处理措施。

引入消息队列带来的问题：

- 消息的可靠性
- 消息的幂等消费
- 消息的顺序消费

### 消息的可靠性

大多数消息队列都提供了 ACK 机制来保证信息的可靠性，但消息队列是基于网络进行通信的，而网络通信是不可靠的，上下游可能因为各种原因导致通信异常。

<div align="left">
    <img src="https://github.com/lazecoding/Note/blob/main/images/mq/消息队列ACK流程.png" width="600px">
</div>

消息队列交互流程中可能出现的问题：

- 生产者未成功 Send 消息到消息队列。
- 生产者 Send 消息成功，但是接收消息队列 ACK 失败。
- 消息队列未成功 Push 消息到消费者。
- 消息队列 Push 消息成功，但是接收消费者 ACK 失败。

解决方案：

- 为了保证消息的可靠性，我们可以将消息持久化到可靠的关系型数据库后再投递消息。生产者将想要 Send 的消息先持久化到数据库，设置投递状态为 "未投递" 再 Send 消息到消息队列，消息队列收到消息后，
先向生产者响应 ACK。如果响应失败，生产者设置投递状态为 "结束" 并放弃后续业务，如果响应成功，设置本地的持久化消息标志状态为 "已发送"，执行后续的业务处理。
- 消息队列 Push 消息后，可能因为各种原因而导致消费失败。默认情况 ACK 机制是自动应答的，即消息队列发送消息后立即从消息队列中删除消息。为了确保消息的可靠传递，需要采用手动 ACK 来确保消息传递的可靠性。
消费者处理完相关业务后通过手动 ACK 通知消息队列，然后从消息队列中删除该持久化消息。如果消息队列因消费者宕机、网络异常等原因未接收到 ACK 响应，就会将消息重新发送。
- 此外，消费者消费成功后需要向消息队列发送一个通知消息，主业务服务收到通知消息后，把本地的持久化消息状态修改为 "完成"。
而且还需要通过定时任务从本地数据库中扫描未完成的消息并重新投递和清除已经完成的一定时间外的历史记录，防止数据量太大导致慢 SQL。

上述方案理想状态下可以保证消息的可靠投递，但是也带了另一个问题：`消息的幂等消费`。

### 消息的幂等消费

原则上一个消息只应该被消费一次，多次消费同一条消息可能会导致数据的不一致。我们在接口设计时往往需要考虑幂等，
幂等是系统设计中十分重要的概念：`对同一个系统，使用同样的条件，一次请求和重复的多次请求对系统资源的影响是一致的`。

为了保证消费的幂等性，这要求我们唯一地标识一条消息，如果不是很严格的场景可以使用 UUID 作为消息标识，如果需要严格保证唯一性就需要引入分布式 ID，分布式 ID 可以保证一条消息的全局唯一。

保证消费的幂等性与保证接口幂等性是类似的，常见方案有引入同步机制的业务校验、数据增加 version 实现乐观锁、基于唯一键去重、token 机制等。

### 消息的顺序消费

消息队列本身是无法保证消息的顺序消费的，例如在 RabbitMQ 中一个队列可以存在多个生产者和消费者，多个生产者难以保证消息队列中消息顺序和多个生产者的操作顺序一致，
多个消费者难以保证消息队列中消息顺序和业务操作顺序一致。要实现严格的顺序消息，简单且可行的办法就是：保证生产者、消息队列、消费者是一对一对一的关系。