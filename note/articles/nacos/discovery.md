# 服务发现

- 目录
  - [数据模型](#数据模型)
  - [临时实例和持久化实例](#临时实例和持久化实例)
  - [负载均衡](#负载均衡)
  - [健康检查](#健康检查)
  - [Service 和 Instance](#Service-和-Instance)
    - [定义 Service](#定义-Service)
    - [Service 元数据](#Service-元数据)
    - [定义 Instance](#定义-Instance)
    - [Instance 元数据](#Instance-元数据)
    - [持久化属性](#持久化属性)
  - [Cluster](#Cluster)
  - [生命周期](#生命周期)
    - [Service 的⽣命周期](#Service-的⽣命周期)
    - [Instance 的⽣命周期](#Instance-的⽣命周期)
    - [Cluster 的⽣命周期](#Cluster-的⽣命周期)
    - [元数据的⽣命周期](#元数据-的⽣命周期)

服务发现是⼀个古老的话题，当应用开始脱离单机运行和访问时，服务发现就诞生了。目前的网络架构是每个主机都有⼀个独立的 IP 地址，那么服务发现基本上都是通过某种方式获取到服务所部 署的 IP 地址。DNS 协议是最早将⼀个网络名称翻译为网络 IP 的协议，在最初的架构选型中， DNS+LVS+Nginx 基本可以满足所有的 RESTful 服务的发现，此时服务的 IP 列表通常配置在 nginx 或者 LVS。后来出现了 RPC 服务，服务的上下线更加频繁，人们开始寻求⼀种能够支持动态上下线并且推送 IP 列表变化的注册中心产品。

Zookeeper 是⼀款经典的服务注册中心产品（虽然它最初的定位并不在于此），在很长⼀段时间里， 它是国人在提起 RPC 服务注册中心时心里想到的唯⼀选择，这很大程度上与 Dubbo 在中国的普及程度有关。Consul 和 Eureka 都出现于 2014 年，Consul 在设计上把很多分布式服务治理上要用到的功能都包含在内，可以支持服务注册、健康检查、配置管理、Service Mesh 等。而 Eureka 则借着微服务概念的流行，与 SpringCloud 生态的深度结合，也获取了大量的用户。Nacos，则携带着阿里巴巴大规模服务生产经验，试图在服务注册和配置管理这个市场上，提供给用户⼀个新的选择。

### 数据模型

Nacos 针对服务发现提炼出 "服务 - 集群 - 实例" 的分层模型。

<div align="left">
    <img src="https://github.com/lazecoding/Note/blob/main/images/nacos/Nacos服务发现分级模型.png" width="600px">
</div>

微服务互相访问时，尽可能访问同集群实例，因为本地访问速度更快。当本集群内不可用时，才访问其它集群。例如：杭州机房内的 order-service 应该优先访问同机房的 user-service。

另外⼀个需要考虑的是数据的隔离模型，作为⼀个共享服务型的组件，需要能够在多个用户或者业务方使用的情况下，保证数据的隔离和安全。

Nacos 中，⼀个用户账号可以新建多个 Namespace（命名空间），每个 Namespace 对应⼀个客户端实例，这个命名空间对应的注册中心物理集群是可以根据规则进行路由的，这样可以让注册中心内部的升级和迁移对用户是无感知的，同时可以根据用户的级别，为用户提供不同服务级别的物理集群。再往下是服务分组和服务名组成的二维服务标识，可以满足接口级别的服务隔离。

<div align="left">
    <img src="https://github.com/lazecoding/Note/blob/main/images/nacos/Nacos服务发现数据模型.png" width="600px">
</div>

> Namespace 默认是空串，公共命名空间（public），分组默认是 DEFAULT_GROUP。

### 临时实例和持久化实例

在定义上区分临时实例和持久化实例的关键是健康检查的方式 —— `临时实例使用客户端上报模式，而持久化实例使用服务端反向探测模式`。临时实例需要能够自动摘除不健康实例，而且无需持久化存储实例，那么这种实例就适用于类 Gossip 的协议；右边的持久化实例使用服务端探测的健康检查方式，因为客户端不会上报心跳，那么自然就不能去自动摘除下线的实例。

### 数据一致性

数据⼀致性是分布式系统永恒的话题，不过从协议层面上看，⼀致性的选型已经很长时间没有新的成员加入了。目前来看基本可以归为两家：⼀种是 `基于 Leader 的非对等部署的单点写⼀致性`，⼀种是 `对等部署的多写⼀致性`。当我们选用服务注册中心的时候，并没有⼀种协议能够覆盖所有场景，例如当注册的服务节点不会定时发送心跳到注册中心时，强⼀致协议看起来是唯⼀的选择，因为无法通过心跳来进行数据的补偿注册，第⼀次注册就必须保证数据不会丢失。而当客户端会定时发送心跳来汇报健康状态时，第⼀次的注册的成功率并不是非常关键（当然也很关键，只是相对来说我们容忍数据的少量写失败），因为后续还可以通过心跳再把数据补偿上来，此时 Paxos 协议的单点瓶颈就会不太划算了，这也是 Eureka 为什么不采用 Paxos 协议而采用自定义的 Renew 机制的原因。

这两种数据⼀致性协议有各自的使用场景，对服务注册的需求不同，就会导致使用不同的协议。在 这里可以发现，Zookeeper 在 Dubbo 体系下表现出的行为，其实采用 Eureka 的 Renew 机制更 加合适，因为 Dubbo 服务往 Zookeeper 注册的就是临时节点，需要定时发心跳到 Zookeeper 来续约节点，并允许服务下线时，将 Zookeeper 上相应的节点摘除。Zookeeper 使用 ZAB 协议 虽然保证了数据的强⼀致，但是它的机房容灾能力的缺乏，无法适应⼀些大型场景。

Nacos 支持 AP 和 CP 两种⼀致性协议并存：⼀个是基于简化的 Raft 的 CP ⼀致性，⼀个是基于自研协议 Distro 的 AP ⼀致性。

### 负载均衡

负载均衡严格的来说，并不算是传统注册中心的功能。⼀般来说服务发现的完整流程应该是先从注册中心获取到服务的实例列表，然后再根据自身的需求，来选择其中的部分实例或者按照⼀定的流量分配机制来访问不同的服务提供者，因此注册中心本身⼀般不限定服务消费者的访问策略。

服务消费者往往并不关心所访问的服务提供者的负载均衡，它们只关心以最高效和正确的访问服务提供者的服务。而服务提供者，则非常关注自身被访问的流量的调配，这其中的第⼀个原因是，如果内部服务访问流量巨大，稍有不慎就会导致流量异常压垮服务提供者的服务。因此服务提供者需要能够完全掌控服务的流量调配，并可以动态调整。但如果给服务提供者更强的流量控制权，又无法满足不同的消费者希望使用不同负载均衡策略的需求。而不同负载均衡策略的场景，确实是存在的。而客户端的负载均衡则提供了这种灵活性，并对用户扩展提供更加友好的支持。但是客户端负载均衡策略如果配置不当，可能会导 致服务提供者出现热点，或者压根就拿不到任何服务提供者。

TODO：负载均衡

### 健康检查

Nacos 既支持客户端的健康检查，也支持服务端的健康检查，同⼀个服务可以切换健康检查模式。我们认为这种健康检查方式的多样性非常重要，这样可以支持各种类型的服务，让这些服务都可以 使用到 Nacos 的负载均衡能力。Nacos 下⼀步要做的是实现健康检查方式的用户扩展机制，不管是服务端探测还是客户端探测。这样可以支持用户传入⼀条业务语义的请求，然后由 Nacos 去执行，做到健康检查的定制。

### Service 和 Instance

`Nacos/nɑ:kəʊs/` 是 `Dynamic Naming and Configuration Service` 的首字母简称：`⼀个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台`。可见，Service（服务）是 Nacos 的核心。

在服务发现领域中，Service 指的是由应用程序提供的⼀个或⼀组软件功能的⼀种抽象概念（例如上述 例子的登陆或支付）。它和应用有所不同，应用的范围更广，和服务属于包含关系，即⼀个应用可能会提供多个服务。Instance（服务实例）是某个服务的具体提供能力的节点，⼀个 Instance 仅从属于⼀个 Service，而⼀个 Service 可以包含⼀个或多个 Instance。在许多场景下，Instance 又被称为 Provider（服务提供者），而使用该服务的实例被称为 Consumer（服务消费者）。

#### 定义 Service

在 Nacos 中，Service 的定义包括以下几个内容：

- 命名空间（Namespace）：Nacos 数据模型中最顶层、也是包含范围最广的概念，用于在类似环境或租户等需要强制隔离的场景中定义。
- 分组（Group）：Nacos 数据模型中次于命名空间的⼀种隔离概念，区别于命名空间的强制隔离属性，分组属于⼀个弱隔离概念，主要用于逻辑区分⼀些服务使用场景或不同应用的同名服务，最常用的情况主要是同⼀个服务的测试分组和生产分组、或者将应用名作为分组以防止不同应用提供的服务重名。
- 服务名（Name）：该服务实际的名字，⼀般用于描述该服务提供了某种功能或能力。

之所以 Nacos 将服务的定义拆分为 Namespace、Group 和 Name，除了方便隔离使用场景外，还有方便用户发现唯⼀服务的优点。在注册中心的实际使用场景上，同个公司的不同开发者可能会开发出 类似作用的服务，如果仅仅使用服务名来做服务的定义和表示，容易在⼀些通用服务上出现冲突，比如登陆服务等。

#### Service 元数据

服务的定义只是为服务设置了⼀些基本的信息，用于描述服务以及方便快速的找到服务，而服务的元数据是进⼀步定义了 Nacos 中服务的细节属性和描述信息。主要包含：

- 健康保护阈值（ProtectThreshold）：为了防止因过多实例故障，导致所有流量全部流入剩余实例，继而造成流量压力将剩余实例被压垮形成的雪崩效应。应将健康保护阈值定义为⼀个 0 到 1 之间的浮点数。当域名健康实例数占总服务实例数的比例小于该值时，无论实例是否健康，都会将这个实例返回给客户端。这样做虽然损失了⼀部分流量，但是保证了集群中剩余健康实例能正常工作。
- 实例选择器（Selector）：用于在获取服务下的实例列表时，过滤和筛选实例。该选择器也被称为路由器，目前 Nacos 支持通过将实例的部分信息存储在外部元数据管理 CMDB 中，并在发现服务时使用 CMDB 中存储的元数据标签来进行筛选的能力。
- 拓展数据(extendData)：用于用户在注册实例时自定义扩展的元数据内容，形式为 K-V 。可以在服务中拓展服务的元数据信息，方便用户实现自己的自定义逻辑。

#### 定义 Instance

由于服务实例是具体提供服务的节点，因此 Nacos 在设计实例的定义时，主要需要存储该实例的⼀些网络相关的基础信息，主要包含以下内容：

- 网络 IP 地址：该实例的 IP 地址，在 Nacos 2.0 版本后支持设置为域名。
- 网络端口：该实例的端口信息。
- 健康状态（Healthy）：用于表示该实例是否为健康状态，会在 Nacos 中通过健康检查的手段进行维护，具体内容将在 Nacos 健康检查机制章节中详细说明，读者目前只需要该内容的含义即可。
- 集群（Cluster）：用于标示该实例归属于哪个逻辑集群，有关于集群的相关内容，将在后文详细说明。
- 拓展数据(extendData)：用于用户自定义扩展的元数据内容，形式为 K-V。可以在实例中拓展该实例的元数据信息，方便用户实现自己的自定义逻辑和标示该实例。

#### Instance 元数据

和服务元数据不同，实例的元数据主要作用于实例运维相关的数据信息。主要包含：

- 权重（Weight）：实例级别的配置。权重为浮点数，范围为 0-10000。权重越大，分配给该实例 的流量越大。
- 上线状态（Enabled）：标记该实例是否接受流量，优先级大于权重和健康状态。用于运维人员 在不变动实例本身的情况下，快速地手动将某个实例从服务中移除。
- 拓展数据(extendData)：不同于实例定义中的拓展数据，这个拓展数据是给予运维人员在不变动 实例本身的情况下，快速地修改和新增实例的扩展数据，从而达到运维实例的作用。

#### 持久化属性

Nacos 提供两种类型的服务：持久化服务和非持久化服务，分别给类 DNS 的基础的服务组件场景和上层实际业务服务场景使用。为了标示该服务是哪种类型的服务，需要在创建服务时选择服务的持久化属性。考虑到目前大多数使用动态服务发现的场景为非持久化服务的类型（如 Spring Cloud，Dubbo，Service Mesh 等），Nacos 将缺醒值设置为了非持久化服务。

在 Nacos2.0 版本后，持久化属性的定义被抽象到服务中，⼀个服务只能被定义成持久化服务或非持久化服务，⼀旦定义完成，在服务生命周期结束之前，无法更改其持久化属性。持久化属性将会影响服务及实例的数据是否会被 Nacos 进行持久化存储，设置为持久化之后，实例将不会再被自动移除，需要使用者手动移除实例。

### Cluster

Cluster（集群是）Nacos 中⼀组服务实例的⼀个逻辑抽象的概念，它介于服务和实例之间，是⼀部分服务属性的下沉和实例属性的抽象。

<div align="left">
    <img src="https://github.com/lazecoding/Note/blob/main/images/nacos/Nacos服务和服务实例和集群.png" width="600px">
</div>

在 Nacos 中，集群中主要保存了有关健康检查的⼀些信息和数据：

- 健康检查类型（HealthCheckType）：使用哪种类型的健康检查方式，目前支持：TCP，HTTP， MySQL；设置为 NONE 可以关闭健康检查。
- 健康检查端口（HealthCheckPort）：设置用于健康检查的端口。
- 是否使用实例端口进行健康检查（UseInstancePort）：如果使用实例端口进行健康检查，将会 使用实例定义中的网络端口进行健康检查，而不再使用上述设置的健康检查端口进行。
- 拓展数据(extendData)：用于用户自定义扩展的元数据内容，形式为 K-V 。可以自定义扩展该集群的元数据信息，方便用户实现自己的自定义逻辑和标示该集群。

### 生命周期

在注册中心中，实例数据都和服务实例的状态绑定，因此服务实例的状态直接决定了注册中心中实例数据的生命周期。而服务作为实例的聚合抽象，生命周期也会由服务实例的状态来决定。

Nacos 各数据生命周期图：

<div align="left">
    <img src="https://github.com/lazecoding/Note/blob/main/images/nacos/Nacos各数据生命周期图.png" width="600px">
</div>

#### Service 的⽣命周期

服务的生命周期相对比较简单，是从用户向注册中心发起服务注册的请求开始。在 Nacos 中，发起服务注册有两种方式，⼀种是直接创建服务，⼀种是注册实例时自动创建服务；前者可以让发起者在创建时期就制定⼀部分服务的元数据信息，而后者只会使用默认的元数据创建服务。

在生命周期期间，用户可以向服务中新增，删除服务实例，同时也能够对服务的元数据进行修改。

当用户主动发起删除服务的请求或⼀定时间内服务下没有实例（无论健康与否）后，服务才结束其 生命周期，等待下⼀次的创建。

#### Instance 的⽣命周期

实例的生命周期开始于注册实例的请求。但是根据不同的持久化属性，实例后续的生命周期有⼀定的不同。

持久化的实例，会通过健康检查的状态维护健康状态，但是不会自动的终止该实例的生命周期；在生命周期结束之前，持久化实例均可以被修改数据，甚至主动修改其健康状态。唯⼀终止持久化实 例生命周期的方式就是注销实例的请求。

而非持久化的实例，会根据版本的不同，采用不同的方式维持健康状态：如果是 Nacos1.0 的版本， 会通过定时的心跳请求来进行续约，当超过⼀定时间内没有心跳进行续约时，该非持久化实例则终 止生命周期；如果是 Nacos2.0 的版本，会通过 gRPC 的长连接来维持状态，当连接发生中断时，该非持久化实例则终止生命周期。当然，非持久化实例也可以通过注销实例的请求，主动终止其生 命周期，但是由于长连接和心跳续约的存在，可能导致前⼀个实例数据的生命周期刚被终止移除，立刻又因为心跳和长连接的补偿请求，再次开启实例的生命周期，给人⼀种注销失败的假象。

#### Cluster 的⽣命周期

集群的生命周期则相对复杂，由于集群作为服务和实例的⼀个中间层，因此集群的生命周期与实例和服务的生命周期均有关。

集群的生命周期开始与该集群第⼀个实例的生命周期同时开始，因为⼀个实例必定归属于⼀个集群，哪怕是默认的集群，因此当第⼀个实例的生命周期开始时，也就是集群生命周期的开始；当⼀个集群下不存在实例时，集群的生命周期也不会立刻结束，而是会等到这个服务的生命周期结束时，才会⼀起结束生命周期。

#### 元数据的⽣命周期

由于元数据的其对应的数据模型是紧密关联的，所以元数据的生命周期基本和对应的数据模型保持⼀致。但是也如前文所说，元数据通常为运维人员的主动操作的数据，会被 Nacos 进行⼀段时间内的记忆，因此元数据的生命周期的终止相比对应的数据要滞后；若这滞后期间内，对应的数据又重新开始生命周期，则该元数据的生命周期将被立刻重置，不再终止。

