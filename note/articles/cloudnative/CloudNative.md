# 云原生

- 目录
    - [云原生的定义](#云原生的定义)
        - [最初定义](#最初定义)
        - [重新定义](#重新定义)
    - [云原生的设计理念](#云原生的设计理念)
        - [什么是云原生基础设施](#什么是云原生基础设施)
    - [云原生应用程序](#云原生应用程序)
        - [微服务](#微服务)
        - [健康报告](#健康报告)
        - [遥测数据](#遥测数据)
        - [弹性](#弹性)
            - [为失败设计](#为失败设计)
            - [优雅降级](#优雅降级)
        - [声明式，非反应式](#声明式，非反应式)
        - [云原生应用程序如何影响基础设施](#云原生应用程序如何影响基础设施)
    - [变革](#变革)
      - [文化变革](#文化变革)
        - [从信息孤岛到 DevOps](#从信息孤岛到-DevOps)
        - [从间断均衡到持续交付](#从间断均衡到持续交付)
        - [从集中治理到分散自治](#从集中治理到分散自治)
      - [组织变革](#组织变革)
        - [业务能力团队](#业务能力团队)
        - [平台运营团队](#平台运营团队)
      - [技术变革](#技术变革)
        - [分解单体应用](#分解单体应用)
        - [分解数据](#分解数据)
        - [容器化](#容器化)
        - [服务编排](#服务编排)

### 云原生的定义

云原生（Cloud Native）这个词汇由来已久，以致于何时出现已无据可考，我们现在谈到云原生，更多的指的是一种文化，而不具象为哪些技术体系。

#### 最初定义

2015 年，Google 主导成立了云原生计算基金会（CNCF），起初 CNCF 对云原生（Cloud Native）的定义包含以下三个方面：

- 应用容器化
- 面向微服务架构
- 应用支持容器的编排调度

#### 重新定义

到了 2018 年，随着近几年来云原生生态的不断壮大，所有主流云计算供应商都加入了该基金会，且从 Cloud Native Landscape 中可以看出云原生有意蚕食原先非云原生应用的部分。CNCF 基金会中的会员以及容纳的项目越来越多，该定义已经限制了云原生生态的发展，CNCF 为云原生进行了重新定位。

以下是 CNCF 对云原生的重新定义（中英对照）：

> Cloud native technologies empower organizations to build and run scalable applications in modern, dynamic environments such as public, private, and hybrid clouds. Containers, service meshes, microservices, immutable infrastructure, and declarative APIs exemplify this approach.

云原生技术有利于各组织在公有云、私有云和混合云等新型动态环境中，构建和运行可弹性扩展的应用。云原生的代表技术包括容器、服务网格、微服务、不可变基础设施和声明式 API。

> These techniques enable loosely coupled systems that are resilient, manageable, and observable. Combined with robust automation, they allow engineers to make high-impact changes frequently and predictably with minimal toil.

这些技术能够构建容错性好、易于管理和便于观察的松耦合系统。结合可靠的自动化手段，云原生技术使工程师能够轻松地对系统作出频繁和可预测的重大变更。

> The Cloud Native Computing Foundation seeks to drive adoption of this paradigm by fostering and sustaining an ecosystem of open source, vendor-neutral projects. We democratize state-of-the-art patterns to make these innovations accessible for everyone.

云原生计算基金会（CNCF）致力于培育和维护一个厂商中立的开源生态系统，来推广云原生技术。我们通过将最前沿的模式民主化，让这些创新为大众所用。

总的说，云原生是一种行为方式和设计理念，究其本质，凡是能够提高云上资源利用率和应用交付效率的行为或方式都是云原生的。云计算的发展史就是一部云原生化的历史。Kubernetes 开启了云原生的序幕，服务网格 Istio 的出现，引领了后 Kubernetes 时代的微服务，serverless 的再次兴起，使得云原生从基础设施层不断向应用架构层挺进，我们正处于一个云原生的新时代。

### 云原生的设计理念

云原生本身甚至不能称为是一种架构，它首先是一种基础设施，运行在其上的应用称作云原生应用，只有符合云原生设计哲学的应用架构才叫云原生应用架构。

云原生系统的设计理念如下:

- 面向分布式设计（Distribution）：容器、微服务、API 驱动的开发。
- 面向配置设计（Configuration）：一个镜像，多个环境配置。
- 面向韧性设计（Resistancy）：故障容忍和自愈。
- 面向弹性设计（Elasticity）：弹性扩展和对环境变化（负载）做出响应。
- 面向交付设计（Delivery）：自动拉起，缩短交付时间。
- 面向性能设计（Performance）：响应式，并发和资源高效利用。
- 面向自动化设计（Automation）：自动化的 DevOps。
- 面向诊断性设计（Diagnosability）：集群级别的日志、metric 和追踪。
- 面向安全性设计（Security）：安全端点、API Gateway、端到端加密。

以上的设计理念很多都是继承自 `分布式应用` 的设计理念。

#### 什么是云原生基础设施

云原生基础设施不等于在公有云上运行的基础设施。光是租用服务器并不会使您的基础设施云原生化。管理 IaaS 的流程与运维物理数据中心没什么两样，将现有架构迁移到云上也未必能获得回报。

云原生不是指在容器中运行应用程序。Netflix 率先推出云原生基础设施时，几乎所有应用程序部署在虚拟机中，而不是在容器中。改变应用程序的打包方式并不意味着就会增加自治系统的可扩展性和优势。即使应用程序是通过 CI/CD 渠道自动构建和部署的，也不意味着您就可以从增强 API 驱动部署的基础设施中受益。

这也并不意味着您只能运行容器编排器（例如 Kubernetes 和 Mesos）。容器编排器提供了云原生基础设施所需的许多平台功能，但并未按预期方式使用这些功能，这意味着您的应用程序会在一组服务器上运行，被动态调度。这是一个非常好的起步，但仍有许多工作要做。

云原生不是微服务或基础设施即代码。微服务意味着更快的开发周期和更小的独特功能，但是单体应用程序可以具有相同的功能，使其能够通过软件有效管理，并且还可以从云原生基础设施中受益。

云原生基础设施划分成四大类：

| 分类             | IaaS                      | CaaS                  | Serverless 容器      | fPaaS/FaaS                 |
| ---------------- | ------------------------- | --------------------- | -------------------- | -------------------------- |
| 代表产品         | 弹性计算 - ECS            | K8s服务 - ACK         | Serverless K8s - ASK | 函数计算 - FunctionCompute |
| 虚拟化技术       | 硬件虚拟化                | 操作系统虚拟化 - 容器 | MicroVM              | 容器或应用运行时虚拟化     |
| 应用交付         | 虚拟机镜像 配合自动化脚本 | 容器镜像              | 容器镜像             | 应用代码                   |
| 应用兼容性灵活性 | 高                        | 中                    | 中                   | 低                         |
| 扩容单位         | 虚拟机                    | Pod                   | Pod                  | 函数实例                   |
| 弹性效率         | 分钟级                    | 秒级                  | 秒级                 | 毫秒级                     |

我们可以看到这几类基础设施，计算单元的粒度越来越细，也越来越多体现的云原生的特质。

- `模块化程度越高`：自包含的应用打包方式，应用与底层物理基础设施解耦。
- `自动化运维程度越来越高`：自动化的资源调度和弹性伸缩能力，用户将关注点逐渐聚焦到应用自身。
- `弹性效率越来越高`：VM 可以实现分钟级扩容；容器可以实现秒级扩容；函数可以做到毫秒级扩容。
- `故障回复能力越来越高`：随着系统自愈性的增强，大大简化了应用架构容错的复杂性。

### 云原生应用程序

就像云改变了业务和基础设施之间的关系一样，云原生应用程序也改变了应用程序和基础设施之间的关系。我们需要了解与传统应用程序相比，云本身有什么不同，因此我们需要了解它们与基础设施的新关系。

云原生应用程序被设计为在平台上运行，并设计用于弹性，敏捷性，可操作性和可观察性。弹性包含失败而不是试图阻止它们；它利用了在平台上运行的动态特性。敏捷性允许快速部署和快速迭代。可操作性从应用程序内部控制应用程序生命周期，而不是依赖外部进程和监视器。可观察性提供信息来回答有关应用程序状态的问题。

云原生应用程序通过各种方法获取这些特征，它通常取决于应用程序的运行位置以及企业流程和文化。以下是实现云原生应用程序所需特性的常用方法：

- 微服务
- 健康报告
- 遥测数据
- 弹性
- 声明式的，而不是命令式的

#### 微服务

作为单个实体进行管理和部署的应用程序通常称为单体应用。最初开发应用程序时，单体有很多好处。它们更易于理解，并允许您在不影响其他服务的情况下更改主要功能。

随着应用程序复杂性的增长，单体应用的益处逐渐减少。它们变得更难理解，而且失去了敏捷性，因为工程师很难推断和修改代码。

对付复杂性的最好方法之一是将明确定义的功能分成更小的服务，并让每个服务独立迭代。这增加了应用程序的灵活性，允许根据需要更轻松地更改部分应用程序。每个微服务可以由单独的团队进行管理，使用适当的语言编写，并根据需要进行独立扩缩容。只要每项服务都遵守强有力的合约，应用程序就可以快速改进和改变。

拥有微服务并不意味着您拥有云原生基础设施，虽然微服务是实现您的应用程序灵活性的一种方式，但它们不是云原生应用程序的必需条件。

#### 健康报告

没有人比开发人员更了解应用程序需要什么才能以健康的状态运行。很长一段时间，基础设施管理员都试图从他们负责运行的应用程序中找出 "健康" 该怎么定义。如果不实际了解应用程序的健康状况，他们尝试在应用程序不健康时进行监控并发出警报，这往往是脆弱和不完整的。

为了提高云原生应用程序的可操作性，应用程序应该暴露健康检查。开发人员可以将其实施为命令或过程信号，以便应用程序在执行自我检查之后响应，或者更常见的是：通过应用程序提供 Web 服务，返回 HTTP 状态码来检查健康状态。

将健康责任转移到应用程序中使应用程序更容易管理和自动化。应用程序应该知道它是否正常运行以及它依赖于什么（例如，访问数据库）来提供业务价值。这意味着开发人员需要与产品经理合作来定义应用服务的业务功能并相应地编写测试。

应用程序不仅仅有健康或不健康的状态。它们将经历一个启动和关闭过程，在这个过程中它们应该通过健康检查，报告它们的状态。如果应用程序可以让平台准确了解它所处的状态，平台将更容易知道如何操作它。

一个很好的例子就是当平台需要知道应用程序何时可以接收流量。在应用程序启动时，如果它不能正确处理流量，它就应该表现为未准备好。此额外状态将防止应用程序过早终止，因为如果运行状况检查失败，平台可能会认为应用程序不健康，并且会反复停止或重新启动它。

应用程序健康只是能够自动化应用程序生命周期的一部分。除了知道应用程序是否健康之外，您还需要知道应用程序是否正在进行哪些工作，这些信息来自遥测数据。

#### 遥测数据

遥测数据是进行决策所需的信息。遥测数据可能与健康报告重叠，但它们有不同的用途。健康报告通知我们应用程序生命周期状态，而遥测数据通知我们应用程序业务目标。

测量的指标有时称为服务级指标（SLI）或关键性能指标（KPI）。这些是特定于应用程序的数据，可以确保应用程序的性能处于服务级别目标（SLO）内。

遥测和度量标准用于解决以下问题：

- 应用程序每分钟收到多少请求？
- 有没有错误？
- 什么是应用程序延迟？
- 订购需要多长时间？

遥测数据应该用于提醒而非健康监测。在动态的、自我修复的环境中，我们更少关注单个应用程序实例的生命周期，更多关注关于整体应用程序 SLO 的内容。健康报告对于自动应用程序管理仍然很重要，但不应该用于页面工程师。

警报也不应该与日志记录混淆。记录用于调试，开发和观察模式。它暴露了应用程序的内部功能。度量有时可以从日志（例如错误率）计算，但需要额外的聚合服务（例如 ElasticSearch）和处理。

#### 弹性

一旦你有遥测和监测数据，你需要确保你的应用程序对故障有适应能力。弹性是基础设施的责任，但云原生应用程序也需要承担部分工作。

基础设施被设计为抵制失败。硬件用于需要多个硬盘驱动器，电源以及全天候监控和部件更换以保持应用程序可用。使用云原生应用程序，应用程序有责任接受失败而不是避免失败。

设计具有弹性的应用程序可能是整本书本身。我们将在云原生应用程序中考虑弹性的两个主要方面：为失败设计和优雅降级。

###### 为失败设计

在任何复杂的系统中，都会有失败。您可以管理硬件中的某些故障（例如，RAID 和冗余电源），以及某些基础设施中的故障（例如负载平衡器）。但是因为应用程序知道他们什么时候健康，所以他们也应该尽可能地管理自己的失败。

设计一个以失败期望为目标的应用程序将比假定可用性的应用程序更具防御性。当故障不可避免时，将会有额外的检查，故障模式和日志内置到应用程序中。

知道应用程序可能失败的每种方式是不可能的。假设任何事情都可能并且可能会失败，这是一种云原生应用程序的模式。

您的应用程序的最佳状态是健康状态。第二好的状态是失败状态。其他一切都是非二进制的，难以监控和排除故障。 Honeycomb 首席执行官 CharityMajors 在她的文章 "Ops：现在每个人都在工作" 中指出："分布式系统永远不会起作用；它们处于部分退化服务的持续状态。接受失败，设计弹性，保护和缩小关键路径。"

无论发生什么故障，云原生应用程序都应该是可适应的。他们期望失败，所以他们在检测到时进行调整。

有些故障不能也不应该被设计到应用程序中（例如，网络分区和可用区故障）。该平台应自主处理未集成到应用程序中的故障域。

###### 优雅降级

云原生应用程序需要有一种方法来处理过载，无论它是应用程序还是负载下的相关服务。处理负载的一种方式是优雅降级。 "站点可靠性工程" 一书中描述了应用程序的优雅降级，因为它提供的响应在负载过重的情况下 "不如正常响应准确或含有较少数据的响应，但计算更容易"。

减少应用程序负载的某些方面由基础设施处理。智能负载平衡和动态扩展可以提供帮助，但是在某些时候，您的应用程序可能承受的负载比它可以处理的负载更多。云原生应用程序需要知道这种必然性并作出相应的反应。

优雅降级的重点是允许应用程序始终返回请求的答案。如果应用程序没有足够的本地计算资源，并且依赖服务没有及时返回信息，则这是正确的。依赖于一个或多个其他服务的服务应该可用于应答请求，即使依赖于服务不是。当服务退化时，返回部分答案或使用本地缓存中的旧信息进行答案是可能的解决方案。

尽管优雅的降级和失败处理都应该在应用程序中实现，但平台的多个层面应该提供帮助。如果采用微服务，则网络基础设施成为需要在提供应用弹性方面发挥积极作用的关键组件。

#### 声明式，非反应式

云原生应用程序被设计为在云环境中运行，它们与基础设施以及相关依赖应用程序的交互方式不同于传统应用程序。在云原生应用程序中，与任何事物的通信都需要通过网络来进行。很多时候，网络通信是通过 RESTful HTTP 调用完成的，但是也可以通过其他接口实现，比如远程过程调用 (RPC)。

声明式通信信任网络会将消息送达。它也相信应用程序将返回成功或错误。这并不是说让应用程序观察变化不重要。Kubernetes 的控制器对 API 服务器做的就是这个。但是，一旦发现变更，他们就会声明一个新的状态，并相信 API 服务器和 kubelets 会做必要的事情。

声明式通信模型由于多种原因而变得更加健壮。最重要的是，它规范了通信模型，并且它将（如何从某种状态到达期望状态的）功能实现从应用程序转移到远程 API 或服务端点。这有助于简化应用程序，并使它们彼此的行为更具可预测性。

#### 云原生应用程序如何影响基础设施

云原生应用程序与传统应用程序不同，云原生应用程序不能直接在 PaaS 上运行或与服务器的操作系统紧密耦合。它们期望在一个拥有大多数自治系统的动态环境中运行。

云原生基础设施在提供自主应用管理的 IaaS 之上创建了一个平台。该平台建立在动态创建的基础设施之上，以抽象出单个服务器并促进动态资源分配调度。

自动化与自治不一样，自动化使人类对他们所采取的行动产生更大的影响。

云原生是关于不需要人类做出决定的自治系统，它仍然使用自动化，但只有在决定了所需的操作之后。只有在系统不能自动确定正确的事情时才应该通知人。

具有这些特征的应用程序需要一个能够实际监控，收集度量标准并在发生故障时做出反应的平台。云原生应用程序不依赖于人员设置 ping 检查或创建 Syslog 规则，他们需要从选择基本操作系统或软件包管理器的过程中提取自助服务资源，并依靠服务发现和强大的网络通信来提供丰富的功能体验。

### 变革

企业 IT 组织采用云原生应用架构，需要接受作为这一转变所带来的部分的文化、组织和技术的变革。

#### 文化变革

企业 IT 采用云原生架构所需的变革根本不是技术性的，而是企业文化和组织的变革，围绕消除造成浪费的结构、流程和活动。

##### 从信息孤岛到 DevOps

企业IT通常被组织成以下许多孤岛：软件开发、质量保证、数据库管理、系统管理、IT 运营、发布管理、项目管理。

创建这些孤岛是为了让那些了解特定领域的人员来管理和指导那些执行该专业领域工作的人员。这些孤岛通常具有不同的管理层次，工具集、沟通风格、词汇表和激励结构。这些差异启发了企业IT目标的不同范式，以及如何实现这一目标。

但这里面存在很多矛盾，例如开发和运维分别对软件变更持有的观念就是个经常被提起的例子。开发的任务通常被视为通过开发软件功能为组织提供额外的价值。 这些功能本身就是向IT生态系统引入变更。所以开发的使命可以被描述为 "交付变化"，而且经常根据有多少次变更来进行激励。相反，IT运营的使命可以被描述为 "防止变更"。IT运营通常负责维护IT系统所需的可用性、弹性、性能和耐用性。因此，他们经常以维持关键绩效指标（KPI）来进行激励，例如平均故障间隔时间（MTBF）和平均恢复时间（MTTR）。与这些措施相关的主要风险因素之一是在系统中引入任何类型的变更。那么，不是设法将开发期望的变更安全地引入IT生态系统，而是通过将流程放在一起，使变更变得痛苦，从而降低了变化率。

企业 IT 通常通过创建基于单据的系统和委员会会议驱动的复杂流程来尝试 "修复" 这种情况，像这样的环境与云原生的速度思想背道而驰。

在其核心上，DevOps 代表着这样一种思想，即将这些信息孤岛构建成共享的工具集、词汇表和沟通结构，以服务于专注于单一目标的文化：快速、安全得交付价值。然后创建激励结构，强制和奖励领导组织朝着这一目标迈进的行为，官僚主义和流程被信任和责任所取代。在这个新的世界中，开发和IT运营部门向共同的直接领导者汇报，并进行合作，寻找能够持续提供价值并获得期望的可用性、弹性、性能和耐久性水平的实践。今天，这些对背景敏感的做法越来越多地包括采用云原生应用架构，提供完成组织的新的共同目标所需的技术支持。

> DevOps 是一组过程、方法与系统的统称，用于促进开发、技术运营和质量保障（QA）部门之间的沟通、协作与整合。
>
> 从目标来看，DevOps 就是让开发人员和运维人员更好地沟通合作，通过自动化流程来使得软件整体过程更加快捷和可靠。
>
> 在DevOps的流程下，运维人员会在项目开发期间就介入到开发过程中，了解开发人员使用的系统架构和技术路线，从而制定适当的运维方案。而开发人员也会在运维的初期参与到系统部署中，并提供系统部署的优化建议。
>
> DevOps的实施，促进开发和运维人员的沟通，增进彼此的理解。换言之，DevOps 考验的不仅是一家企业的技术，更是管理水平和企业文化。

##### 从间断均衡到持续交付

企业经常采用敏捷流程，但是只能作为开发团队内部的本地优化。

在这个行业中，我们实际上已经成功地将个别开发团队转变为更灵活的工作方式。 我们可以这样开始项目，撰写用户故事，并执行敏捷开发的所有例程，如迭代计划会议，日常站会，回顾和客户展示demo。 我们中的冒险者甚至可能会冒险进行工程实践，如结对编程和测试驱动开发。持续集成，这在以前是一个相当激进的概念，现在已经成为企业软件词典的标准组成部分。事实上，我已经是几个企业软件团队中的一部分，并建立了高度优化的 "故事到演示" 周期，每个开发迭代的结果在客户演示期间被热烈接受。

但是，这些团队会遇到可怕的问题：我们什么时候可以在生产环境中看到这些功能？

这个问题我们很难回答，因为它迫使我们考虑自己无法控制的力量：

- 我们需要多长时间才能浏览独立的质量保证流程？
- 我们什么时候可以加入生产发布的行列中？
- 我们可以让 IT 运营及时为我们提供生产环境吗？

我们的团队已经开始接受敏捷原则，但我们的组织却没有。所以，不是每次迭代产生一次生产部署（这是敏捷宣言的原始出发点），代码实际上是批量参与一个更传统的下游发布周期。这种操作风格产生直接的后果。我们不是每次迭代都将价值交付给客户，并将有价值的反馈回到开发团队，我们继续保持 "间断均衡" 的交付方式。

- 客户可能需要几周的时间才能看到软件带来的新价值。他们认为，这种新的敏捷工作方式只是 "像往常一样"，不会增强对开发团队的信任。因为他们没有看到可靠的交付节奏，他们回到了以前的套路将尽可能多的要求尽可能多地堆放到发布版上。为什么？因为他们对软件能够很快发布没有信心，他们希望尽可能多的价值被包括在最终交付时。
- 开发团队可能会好几周都没有得到真正的反馈。虽然演示很棒，但任何经验丰富的开发人员都知道，只有真实用户参与到软件之中才能获得最佳反馈。这些反馈能够帮助软件修正，使团队去做正确的事情。反馈推迟后，错误的可能性只能增加，并带来昂贵的返工。

获得云原生应用架构的好处需要我们转变为持续交付。我们拥抱端到端拥抱价值的原则，而不是 Water Scrum Fall 组织驱动的间断平衡。我们技术上支持这种使用连续交付的工程实践的方法，每次迭代（实际上是次每个源代码提交！）都被证明可以以自动化的方式部署。我们构建部署流水线，可自动执行每次测试，如果该测试失败，将会阻止生产部署。唯一剩下的决定是商业决策：现在部署可用的新功能有很好的业务意义吗？我们已经知道它已经如广告中的方式工作，但是我们要现在就把它们交给客户吗？因为部署管道是完全自动化的，所以企业能够通过点击按钮来决定是否采取行动。

##### 从集中治理到分散自治

企业通常采用围绕应用架构和数据管理的集中治理结构，负责维护指导方针和标准的委员会，以及批准个人设计和变更。集中治理旨在帮助解决以下几个问题：

- 可以防止技术栈的大范围不一致，降低组织的整体维护负担。
- 可以防止架构选型中的大范围不一致，从而形成组织的应用程序开发的共同观点。
- 整个组织可以一致地处理跨部门关切，例如合规性。
- 数据所有权可由具有全局视野的人来决定。

之所以创造这些结构，是因为我们相信它们将有助于提高质量、降低成本或两者兼而有之。然而，这些结构很少能够帮助我们提高质量节约成本，并且进一步妨碍了云原生应用架构寻求的交付速度。正如单体应用架构导致了限制技术创新速度的瓶颈一样，单一的治理结构同样如此。架构委员会经常只会定期召集，并且经常需要很长的等待时才能发挥工作。即使是很小的数据模型的变化——可能在几分钟或几个小时内完成的更改，即将被委员会批准的变更——将会把时间浪费在一个不断增长的待办事项中。

采用云原生应用架构时通常都会与分散式治理结合起来。建立云原生应用的团队拥有他们负责交付的能力的所有方面。他们拥有和管理数据、技术栈、应用架构、每个组件设计和 API 协议并将它们交付给组织的其余部分。如果需要对某事作出决策，则由团队自主制定和执行。

#### 组织变革

采用云原生应用架构的组织在创建团队时需要进行的变革，这个重组背后的理论是著名的康威定律。我们的解决方案是在长周期的产品开发中，创建一个包含了各方面专业员工的团队，而不是将他们分离在单一的团队中，例如测试人员。

##### 业务能力团队

作为转向DevOps文化的一部分，我们组织了跨职能、业务能力的团队，开发的是产品而不再是项目。开发产品需要长期的付出，直到它们不再为企业提供价值为止。（直到你的代码不再运行在生产上为止！）构建、测试、交付和运营提供业务能力的服务所需的所有角色都存在于一个团队中，该团队不会向组织的其他部分交接代码。

我们将从组织的领域模型开始，并寻求可以封装在有限环境中的业务能力。一旦我们确定了这些能力，我们就可以创建为这些业务能力的整个生命周期负责的团队，业务能力团队掌握其应用程序从开发到运营的整个生命周期。

##### 平台运营团队

业务能力团队需要依赖于我们前面提到的 "自助敏捷基础架构"。

事实上，我们可以这样来描述一种特殊的业务能力——开发、部署和运营业务的能力。这种能力应该是平台运营团队所具有的。

平台运营团队运营自助敏捷基础架构平台，并交付给业务能力团队使用。该团队通常包括传统的系统、网络和存储管理员角色。如果公司正在运营云平台，该团队也将拥有管理数据中心的团队或与他们紧密合作，并了解提供基础架构平台所需的硬件能力。

IT运营传统上通过各种基于单据的系统与客户进行互动。由于基于平台操作流来运行自助服务平台，因此必须提供不同形式的交互方式。正如业务能力团队之间通过定义好的API协议相互协作一样，平台运营团队也为该平台提供了API协议。业务能力团队不再需要排队申请应用环境和数据服务，而是采用更精简的方式构建按需申请环境和服务的自动化发布管道。

#### 技术变革

现在我们将问题转移到了云中的 DevOps 平台。

##### 分解单体应用

单体应用通常都部署在长期运行的基础设施中，并与其紧密结合。不幸的是，单体应用并不太适合弹性和短暂（非长期支持）生命周期的基础设施。

但是即使我们可以构建一个不需要这些假设的单体应用，我们依然有一些问题需要解决：

- 单体式应用的变更周期耦合，使独立业务能力无法按需部署，阻碍创新速度。
- 嵌入到单体应用中的服务不能独立于其他服务进行扩展，因此负载更难于优化。
- 新加入组织的开发人员必须适应新的团队，经常学习新的业务领域，并且一次就熟悉一个非常大的代码库，这样会增加 3 - 6 个月的适应时间，才能实现真正的生产力。
- 尝试通过堆积开发人员来扩大开发组织，增加了昂贵的沟通和协调成本。
- 技术栈需要长期承诺。引进新技术太过冒险，可能会对整体产生不利影响。

将组织分解为业务能力团队还要求我们将应用程序分解成微服务，只有这样，我们才能从云计算基础架构中获得最大的收益。

##### 分解数据

仅仅将单体应用分解为微服务还是远远不够的，数据模型必须要解耦。如果业务能力团队被认为是自主的，却被迫通过单一的数据存储进行协作，那么单体应用对创新的阻碍将依然存在。

事实上，产品架构必须从数据开始的说法是有争议的。由 Eric Evans（Addison-Wesley）在领域驱动设计（DDD）中提出的原理认为，我们的成功在很大程度上取决于领域模型的质量（以及支持它的普遍存在的语言）。要使领域模型有效，还必须在内部一致——我们不应该在同一模型内的一致定义中找到重复定义的术语或概念。

创建不具有这种不一致的联合领域模型是非常困难和昂贵的（可以说是不可能的）。Evans 将业务的整体领域模型的内部一致性子集称为有界上下文。有界上下文允许你在整个组织中保持单一概念的不一致定义，只要它们在有界上下文中一致地定义。因此，我们首先需要确定可以在内部保持一致的领域模型的细分。我们在这些细分上画出固定的边界，划分出有界上下文。然后，我们可以将业务能力团队与这些环境相匹配，这些团队将构建提供这些功能的微服务。

我们将有界上下文与每个服务模式的数据库结合，每个微服务封装、管理和保护自己的领域模型和持久存储。在每个服务模式的数据库中，只允许一个应用程序服务访问逻辑数据存储，逻辑数据存储可能是以多租户集群中的单个 schema 或专用物理数据库中存在。对这些概念的任何外部访问都是通过一个明确定义的业务协议来实现的，该协议的实现方式为 API（通常是REST，但可能是任何协议）。

##### 容器化

容器镜像（例如通过 LXC、Docker 或 Rocket 项目准备的镜像）正在迅速成为云原生应用架构的部署单元。然后通过诸如 Kubernetes、Marathon 或 Lattice 等各种调度解决方案实例化这样的容器镜像。亚马逊和 Google 等公有云供应商也提供一流的解决方案，用于容器化调度和部署。容器利用现代的Linux内核原语，如控制组（cgroups）和命名空间来提供类似的资源分配和隔离功能，这些功能与虚拟机提供的功能相比，具有更少的开销和更强的可移植性。应用程序开发人员将需要将应用程序包装成容器镜像，以充分利用现代云基础架构的功能。

##### 服务编排

不仅仅服务交付、数据建模和治理必须分散化，服务集成也是如此。企业服务集成传统上是通过企业服务总线（ESB）实现的。ESB 成为管理服务之间交互的所有路由、转换、策略、安全性和其他决策的所有者，我们将其称之为编排。ESB 和编排可以产生非常简单和令人愉快的架构图，但它们的简单性仅仅是表面性的，在 ESB 中隐藏的是复杂的网络。

诸如微服务这样的云原生架构更倾向于舞蹈，它们类似于芭蕾舞中的舞者。它们将心智放置在端点上，类似于 Unix 架构中的虚拟管道和智能过滤器，而不是放在集成机制中。当舞台上的情况与原来的计划有所不同时，没有导演告诉舞者该怎么做。相反，他们会自适应。同样，服务通过客户端负载均衡和断路器等模式，适应环境中不断变化的各种情况。

虽然架构图看起来像一个庞杂的网络，但它们的复杂性并不比传统的 SOA 大。编排简单地承认并暴露了系统原有的复杂性。再次，这种转变是为了支持从云原生架构中寻求速度所需的自治。团队能够适应不断变化的环境，而无需承担与其他团队协调的开销，并避免了在集中管理的 ESB 中协调变更所造成的开销。