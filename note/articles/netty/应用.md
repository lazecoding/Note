# Netty 应用

- 目录
    - [协议设计与解析](#入门案例)
      - [Redis 协议](#Redis-协议)
      - [HTTP 协议](#HTTP-协议)
      - [自定义协议](#自定义协议)
        - [Sharable 注解](#Sharable-注解)
    - [WebSocket 服务器](#WebSocket-服务器)
      - [WebSocket 协议](#WebSocket-协议)
        - [WebSocket frame](#WebSocket-frame)
      - [引导类](#引导类)
      - [心跳检测](#心跳检测)
    - [参数优化](#参数优化)

Netty 是基于 Java NIO 的异步事件驱动的网络应用框架，使用 Netty 可以快速开发网络应用，Netty 提供了高层次的抽象来简化 TCP 和 UDP 服务器的编程，同时仍然可以使用底层的 API。

### 协议设计与解析

TCP/IP 中消息传输基于流的方式，没有边界。协议的目的就是划定消息的边界，制定通信双方要共同遵守的通信规则。

#### Redis 协议

如果我们要向 Redis 服务器发送一条 `set name Nyima` 的指令，需要遵守如下协议：

```C
// 该指令一共有3部分，每条指令之后都要添加回车与换行符
*3\r\n
// 第一个指令的长度是3
$3\r\n
// 第一个指令是set指令
set\r\n
// 下面的指令以此类推
$4\r\n
name\r\n
$5\r\n
Nyima\r\n
```

客户端代码：

```java
public class RedisClient {
    static final Logger log = LoggerFactory.getLogger(StudyServer.class);
    public static void main(String[] args) {
        NioEventLoopGroup group =  new NioEventLoopGroup();
        try {
            ChannelFuture channelFuture = new Bootstrap()
                    .group(group)
                    .channel(NioSocketChannel.class)
                    .handler(new ChannelInitializer<SocketChannel>() {
                        @Override
                        protected void initChannel(SocketChannel ch) {
                            // 打印日志
                            ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));
                            ch.pipeline().addLast(new ChannelInboundHandlerAdapter() {
                                @Override
                                public void channelActive(ChannelHandlerContext ctx) throws Exception {
                                    // 回车与换行符
                                    final byte[] LINE = {'\r','\n'};
                                    // 获得ByteBuf
                                    ByteBuf buffer = ctx.alloc().buffer();
                                    // 连接建立后，向Redis中发送一条指令，注意添加回车与换行
                                    // set name Nyima
                                    buffer.writeBytes("*3".getBytes());
                                    buffer.writeBytes(LINE);
                                    buffer.writeBytes("$3".getBytes());
                                    buffer.writeBytes(LINE);
                                    buffer.writeBytes("set".getBytes());
                                    buffer.writeBytes(LINE);
                                    buffer.writeBytes("$4".getBytes());
                                    buffer.writeBytes(LINE);
                                    buffer.writeBytes("name".getBytes());
                                    buffer.writeBytes(LINE);
                                    buffer.writeBytes("$5".getBytes());
                                    buffer.writeBytes(LINE);
                                    buffer.writeBytes("Nyima".getBytes());
                                    buffer.writeBytes(LINE);
                                    ctx.writeAndFlush(buffer);
                                }

                            });
                        }
                    })
                    .connect(new InetSocketAddress("localhost", 6379));
            channelFuture.sync();
            // 关闭channel
            channelFuture.channel().close().sync();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            // 关闭group
            group.shutdownGracefully();
        }
    }
}
```

结果：

```C
1600 [nioEventLoopGroup-2-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x28c994f1, L:/127.0.0.1:60792 - R:localhost/127.0.0.1:6379] WRITE: 34B
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 2a 33 0d 0a 24 33 0d 0a 73 65 74 0d 0a 24 34 0d |*3..$3..set..$4.|
|00000010| 0a 6e 61 6d 65 0d 0a 24 35 0d 0a 4e 79 69 6d 61 |.name..$5..Nyima|
|00000020| 0d 0a                                           |..              |
+--------+-------------------------------------------------+----------------+
```

#### HTTP 协议

HTTP协议在请求行请求头中都有很多的内容，自己实现较为困难，可以使用 HttpServerCodec 作为服务器端的解码器与编码器，来处理 HTTP 请求。

```java
// HttpServerCodec 中既有请求的解码器 HttpRequestDecoder 又有响应的编码器 HttpResponseEncoder
// Codec(CodeCombine) 一般代表该类既作为 编码器 又作为 解码器
public final class HttpServerCodec extends CombinedChannelDuplexHandler<HttpRequestDecoder, HttpResponseEncoder>
        implements HttpServerUpgradeHandler.SourceCodec
```

服务端代码：

```java
public class HttpServer {
    static final Logger log = LoggerFactory.getLogger(StudyServer.class);

    public static void main(String[] args) {
        NioEventLoopGroup group = new NioEventLoopGroup();
        new ServerBootstrap()
                .group(group)
                .channel(NioServerSocketChannel.class)
                .childHandler(new ChannelInitializer<SocketChannel>() {
                    @Override
                    protected void initChannel(SocketChannel ch) {
                        ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));
                        // 作为服务器，使用 HttpServerCodec 作为编码器与解码器
                        ch.pipeline().addLast(new HttpServerCodec());
                        // 服务器只处理HTTPRequest
                        ch.pipeline().addLast(new SimpleChannelInboundHandler<HttpRequest>() {
                            @Override
                            protected void channelRead0(ChannelHandlerContext ctx, HttpRequest msg) {
                                // 获得请求uri
                                log.debug(msg.uri());

                                // 获得完整响应，设置版本号与状态码
                                DefaultFullHttpResponse response = new DefaultFullHttpResponse(msg.protocolVersion(), HttpResponseStatus.OK);
                                // 设置响应内容
                                byte[] bytes = "<h1>Hello, World!</h1>".getBytes(StandardCharsets.UTF_8);
                                // 设置响应体长度，避免浏览器一直接收响应内容
                                response.headers().setInt(CONTENT_LENGTH, bytes.length);
                                // 设置响应体
                                response.content().writeBytes(bytes);

                                // 写回响应
                                ctx.writeAndFlush(response);
                            }
                        });
                    }
                })
                .bind(8080);
    }
}
```

服务器负责处理请求并响应浏览器。所以只需要处理 HTTP 请求即可。

```java
// 服务器只处理HTTPRequest
ch.pipeline().addLast(new SimpleChannelInboundHandler<HttpRequest>()
```

获得请求后，需要返回响应给浏览器。需要创建响应对象 DefaultFullHttpResponse，设置 HTTP 版本号及状态码，为避免浏览器获得响应后，因为获得 CONTENT_LENGTH 而一直空转，
需要添加 CONTENT_LENGTH 字段，表明响应体中数据的具体长度。

```java
// 获得完整响应，设置版本号与状态码
DefaultFullHttpResponse response = new DefaultFullHttpResponse(msg.protocolVersion(), HttpResponseStatus.OK);
// 设置响应内容
byte[] bytes = "<h1>Hello, World!</h1>".getBytes(StandardCharsets.UTF_8);
// 设置响应体长度，避免浏览器一直接收响应内容
response.headers().setInt(CONTENT_LENGTH, bytes.length);
// 设置响应体
response.content().writeBytes(bytes);
```

结果:

```java
// 请求内容
1714 [nioEventLoopGroup-2-2] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x72630ef7, L:/0:0:0:0:0:0:0:1:8080 - R:/0:0:0:0:0:0:0:1:55503] READ: 688B
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 47 45 54 20 2f 66 61 76 69 63 6f 6e 2e 69 63 6f |GET /favicon.ico|
|00000010| 20 48 54 54 50 2f 31 2e 31 0d 0a 48 6f 73 74 3a | HTTP/1.1..Host:|
|00000020| 20 6c 6f 63 61 6c 68 6f 73 74 3a 38 30 38 30 0d | localhost:8080.|
|00000030| 0a 43 6f 6e 6e 65 63 74 69 6f 6e 3a 20 6b 65 65 |.Connection: kee|
|00000040| 70 2d 61 6c 69 76 65 0d 0a 50 72 61 67 6d 61 3a |p-alive..Pragma:|
....

// 响应内容
1716 [nioEventLoopGroup-2-2] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x72630ef7, L:/0:0:0:0:0:0:0:1:8080 - R:/0:0:0:0:0:0:0:1:55503] WRITE: 61B
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 48 54 54 50 2f 31 2e 31 20 32 30 30 20 4f 4b 0d |HTTP/1.1 200 OK.|
|00000010| 0a 43 6f 6e 74 65 6e 74 2d 4c 65 6e 67 74 68 3a |.Content-Length:|
|00000020| 20 32 32 0d 0a 0d 0a 3c 68 31 3e 48 65 6c 6c 6f | 22....<h1>Hello|
|00000030| 2c 20 57 6f 72 6c 64 21 3c 2f 68 31 3e          |, World!</h1>   |
+--------+-------------------------------------------------+----------------+
```

#### 自定义协议

协议要素：

- 魔数，用来在第一时间判定是否是无效数据包
- 版本号，可以支持协议的升级
- 序列化算法，消息正文到底采用哪种序列化反序列化方式，可以由此扩展，例如：json、protobuf、hessian、jdk
- 指令类型，是登录、注册、单聊、群聊... 跟业务相关
- 请求序号，为了双工通信，提供异步能力
- 正文长度
- 消息正文

根据上面的要素，设计一个登录请求消息和登录响应消息，并使用 Netty 完成收发。

编码器与解码器：

```java
public class MessageCodec extends ByteToMessageCodec<Message> {

    @Override
    protected void encode(ChannelHandlerContext ctx, Message msg, ByteBuf out) throws Exception {
        // 设置魔数 4个字节
        out.writeBytes(new byte[]{'N','Y','I','M'});
        // 设置版本号 1个字节
        out.writeByte(1);
        // 设置序列化方式 1个字节
        out.writeByte(1);
        // 设置指令类型 1个字节
        out.writeByte(msg.getMessageType());
        // 设置请求序号 4个字节
        out.writeInt(msg.getSequenceId());
        // 为了补齐为16个字节，填充1个字节的数据
        out.writeByte(0xff);

        // 获得序列化后的msg
        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        ObjectOutputStream oos = new ObjectOutputStream(bos);
        oos.writeObject(msg);
        byte[] bytes = bos.toByteArray();

        // 获得并设置正文长度 长度用4个字节标识
        out.writeInt(bytes.length);
        // 设置消息正文
        out.writeBytes(bytes);
    }

    @Override
    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {
        // 获取魔数
        int magic = in.readInt();
        // 获取版本号
        byte version = in.readByte();
        // 获得序列化方式
        byte seqType = in.readByte();
        // 获得指令类型
        byte messageType = in.readByte();
        // 获得请求序号
        int sequenceId = in.readInt();
        // 移除补齐字节
        in.readByte();
        // 获得正文长度
        int length = in.readInt();
        // 获得正文
        byte[] bytes = new byte[length];
        in.readBytes(bytes, 0, length);
        ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(bytes));
        Message message = (Message) ois.readObject();
		// 将信息放入List中，传递给下一个handler
        out.add(message);
        
        // 打印获得的信息正文
        System.out.println("===========魔数===========");
        System.out.println(magic);
        System.out.println("===========版本号===========");
        System.out.println(version);
        System.out.println("===========序列化方法===========");
        System.out.println(seqType);
        System.out.println("===========指令类型===========");
        System.out.println(messageType);
        System.out.println("===========请求序号===========");
        System.out.println(sequenceId);
        System.out.println("===========正文长度===========");
        System.out.println(length);
        System.out.println("===========正文===========");
        System.out.println(message);
    }
}
```

- 编码器与解码器方法源于父类 ByteToMessageCodec，通过该类可以自定义编码器与解码器，泛型类型为被编码与被解码的类。此处使用了自定义类 Message，代表消息。

```java
public class MessageCodec extends ByteToMessageCodec<Message>
```

- 编码器负责将附加信息与正文信息写入到 ByteBuf 中，其中附加信息总字节数最好为 2N，不足需要补齐。正文内容如果为对象，需要通过序列化将其放入到 ByteBuf 中。

- 解码器负责将 ByteBuf 中的信息取出，并放入 List 中，该 List 用于将信息传递给下一个 handler。

测试类：

```java
public class TestCodec {
    static final org.slf4j.Logger log = LoggerFactory.getLogger(StudyServer.class);
    public static void main(String[] args) throws Exception {
        EmbeddedChannel channel = new EmbeddedChannel();
        // 添加解码器，避免粘包半包问题
        channel.pipeline().addLast(new LengthFieldBasedFrameDecoder(1024, 12, 4, 0, 0));
        channel.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));
        channel.pipeline().addLast(new MessageCodec());
        LoginRequestMessage user = new LoginRequestMessage("Nyima", "123");

        // 测试编码与解码
        ByteBuf byteBuf = ByteBufAllocator.DEFAULT.buffer();
        new MessageCodec().encode(null, user, byteBuf);
        channel.writeInbound(byteBuf);
    }
}
```

- 测试类中用到了 LengthFieldBasedFrameDecoder，避免粘包半包问题。
- 通过 MessageCodec 的 encode 方法将附加信息与正文写入到 ByteBuf 中，通过 Channel 执行入站操作。入站时会调用 decode 方法进行解码。

##### Sharable 注解

为了提高 handler 的复用率，可以将 handler 创建为 handler 对象，然后在不同的 Channel 中使用该 handler 对象进行处理操作。

Netty 中用 `@Sharable` 注解来标明该 handler 能否在多个 Channel 中共享，只有带有该注解，才能通过对象的方式被共享，否则无法被共享。

> 注意：当 handler 不保存状态时，才可以安全地在多线程下被共享。

### WebSocket 服务器

`real-time web`（实时 Web）是一组技术和实践，使用户能够实时地接收 到作者发布的信息，而不需要用户用他们的软件定期检查更新源。
HTTP 的请求/响应的设计并不能满足实时的需求，而 WebSocket 协议从设计以来就提供双向数据传输，允许客户和服务器在任何时间发送消息，并要求它们能够异步处理消息。
Netty 提供了 WebSocket 的支持和实现，我们可以使用 Netty 完成 WebSocket 服务器的开发，而不必担心其内部实现细节。

#### WebSocket 协议

WebSocket 使用一种被称作 "Upgrade handshake（升级握手）" 的机制将标准的 HTTP 或HTTPS 协议转为 WebSocket。因此，使用 WebSocket 的应用程序将始终以 HTTP/S 开始，然后进行升级。
这种升级发生在什么时候取决于具体的应用：可以在应用启动的时候，或者当一个特定的 URL 被请求的时候。

在我们的应用中，仅当 URL 请求以 "/ws" 结束时，我们才升级协议为 WebSocket。否则，服务器将使用基本的 HTTP/S。一旦连接升级，之后的数据传输都将使用 WebSocket。

##### WebSocket frame

WebSockets 在 "帧" 里面来发送数据，其中每一个都代表了一个消息的一部分，一个完整的消息可以利用了多个帧。

`WebSocket "Request for Comments" (RFC)` 定义了六种不同的 frame; Netty 给他们每个都提供了一个实现 ，如下：

- BinaryWebSocketFrame：contains binary data.
- TextWebSocketFrame：contains text data.
- ContinuationWebSocketFrame：contains text or binary data that belongs to a previous BinaryWebSocketFrame or TextWebSocketFrame.
- CloseWebSocketFrame：represents a CLOSE request and contains close status code and a phrase.
- PingWebSocketFrame：requests the transmission of a PongWebSocketFrame.
- PongWebSocketFrame：sent as a response to a PingWebSocketFrame.

对于应用程序，只需要使用下面 4 钟帧：

- CloseWebSocketFrame
- PingWebSocketFrame
- PongWebSocketFrame
- TextWebSocketFrame

大多数情况，我们只需要处理 TextWebSocketFrame，其他的会由 WebSocketServerProtocolHandler 自动处理。

TextWebSocketFrame 是文本帧，里面是链接建立后传输的文本数据。

#### 引导类

服务端引导类：

```java
public class WebSocketServer {

    public static void main(String[] args) {
        
        NioEventLoopGroup boss = new NioEventLoopGroup();
        NioEventLoopGroup worker = new NioEventLoopGroup();

        try {
            ServerBootstrap serverBootstrap = new ServerBootstrap();
            serverBootstrap.group(boss, worker);
            serverBootstrap.channel(NioServerSocketChannel.class);
            //保持长连接
            serverBootstrap.childOption(ChannelOption.SO_KEEPALIVE, true);
            serverBootstrap.childHandler(new ChannelInitializer<SocketChannel>() {
                @Override
                protected void initChannel(SocketChannel ch) throws Exception {
                    // WebSocket 协议本身是基于 HTTP 协议的，所以这边也要使用 HTTP 解编码器
                    ch.pipeline().addLast("http-codec", new HttpServerCodec());
                    // Netty 是基于分段请求的，HttpObjectAggregator 的作用是将请求分段再聚合,参数是聚合字节的最大长度。
                    ch.pipeline().addLast("aggregator", new HttpObjectAggregator(Integer.parseInt(ServerConstans.MAX_CONTENT_LENGTH.getValue())));
                    // 以块的方式来写的处理器,方便大文件传输
                    ch.pipeline().addLast("http-chunked", new ChunkedWriteHandler());
                    // WebSocket 数据压缩扩展
                    ch.pipeline().addLast(new WebSocketServerCompressionHandler());

                    // 增加心跳事件支持
                    // 第一个参数:  读空闲20秒
                    // 第二个参数： 写空闲20秒
                    // 第三个参数： 读写空闲20秒
                    ch.pipeline().addLast(new IdleStateHandler(20, 20, 20));
                    ch.pipeline().addLast(new HearBeatHandler());

                    // 会话处理器
                    ch.pipeline().addLast(new SessionHander());

                    // WebSocket 握手、控制帧处理
                    ch.pipeline().addLast(new WebSocketServerProtocolHandler(ServerConstans.SERVER_PATH.getValue(), null, true));

                    // 入站请求
                    ch.pipeline().addLast(new IncomingRequestHander());
                }
            });
            Channel channel = serverBootstrap.bind(9999).sync().channel();
            System.out.println("Connection is opened");
            // Wait until the connection is closed.
            channel.closeFuture().sync();
            System.out.println("Connection is closed");
        } catch (InterruptedException e) {
            System.out.println("Exception:" + e.getMessage() + " > " + e.getClass().getName());
            throw new Error("Server Disconnected");
        } finally {
            boss.shutdownGracefully();
            worker.shutdownGracefully();
        }
    }
}
```

- HttpServerCodec：WebSocket 协议本身是基于 HTTP 协议的，所以这边也要使用 HTTP 解编码器。
- HttpObjectAggregator：Netty 是基于分段请求的，HttpObjectAggregator 的作用是将请求分段再聚合,参数是聚合字节的最大长度。
- ChunkedWriteHandler：以块的方式来写的处理器,方便大文件传输。
- WebSocketServerCompressionHandler：WebSocket 数据压缩扩展。
- WebSocketServerProtocolHandler：WebSocket 握手、控制帧处理。
- IdleStateHandler：闲置状态处理器，一般用于心跳检测。
- HearBeatHandler：心跳检测处理器，自行实现，通过 IdleStateHandler 触发闲置事件完成心跳检测。
- SessionHander：会话处理器，自行实现，管理会话。
- IncomingRequestHander：入站请求处理器，处理 TextWebSocketFrame，即真正进行业务处理的地方。

更多代码 [Communication](https://github.com/lazecoding/Communication) 。

#### 心跳检测

我们有意识地添加心跳检测，这是必要的。

原因：

- 网络设备出现故障，例如网卡，机房等，底层的 TCP 连接已经断开了，但应用程序没有感知到，仍然占用着资源。
- 公网网络不稳定，出现丢包。如果连续出现丢包，这时现象就是客户端数据发不出去，服务端也一直收不到数据，会白白地消耗资源。
- 应用程序线程阻塞，无法进行数据读写。

问题：

- 假死的连接占用的资源不能自动释放。
- 向假死的连接发送数据，得到的反馈是发送超时。

解决：

添加 IdleStateHandler 检测闲置时间，并构建自定义处理器去处理 IdleStateHandler 触发的事件。

IdleStateHandler 构造函数：

```java
Creates a new instance firing IdleStateEvents.
Params:
    readerIdleTimeSeconds – an IdleStateEvent whose state is IdleState.READER_IDLE will be triggered when no read was performed for the specified
period of time. Specify 0 to disable.
    writerIdleTimeSeconds – an IdleStateEvent whose state is IdleState.WRITER_IDLE will be triggered when no write was performed for the specified
period of time. Specify 0 to disable.
    allIdleTimeSeconds – an IdleStateEvent whose state is IdleState.ALL_IDLE will be triggered when neither read nor write was performed for the
specified period of time. Specify 0 to disable.
public IdleStateHandler(
        int readerIdleTimeSeconds,
        int writerIdleTimeSeconds,
        int allIdleTimeSeconds) {

    this(readerIdleTimeSeconds, writerIdleTimeSeconds, allIdleTimeSeconds,
         TimeUnit.SECONDS);
}
```

- readerIdleTimeSeconds：读空闲经过的秒数。
- writerIdleTimeSeconds：写空闲经过的秒数。
- allIdleTimeSeconds：读和写空闲经过的秒数。

当指定时间内未发生读或写事件时，会触发特定事件。

- 读空闲会触发 READER_IDLE。
- 写空闲会触发 WRITE_IDLE。
- 读和写空闲会触发 ALL_IDEL。

心跳处理器：

```java
public class HearBeatHandler extends ChannelInboundHandlerAdapter {

    /**
     * 客户端在一定的时间没有动作就会触发这个事件
     */
    @Override
    public void userEventTriggered(ChannelHandlerContext ctx, Object eventObj) throws Exception {
        if (eventObj instanceof IdleStateEvent) {
            IdleStateEvent event = (IdleStateEvent) eventObj;
            if (event.state() == IdleState.READER_IDLE) {
                System.out.println("读空闲");
            } else if (event.state() == IdleState.WRITER_IDLE) {
                System.out.println("写空闲");
            } else if (event.state() == IdleState.ALL_IDLE) {
                System.out.println("读写都空闲你，关闭通道");
                ctx.channel().close();
            }
        }
    }
}
```

客户端需要向服务器发送心跳包，发送频率要小于服务器设置的闲置时间，一般设置为其值的一半。

### 参数优化

在 Netty 中使用 Bootstrap 和 ServerBootstrap 设置属性。

- 客户端通过 `Bootstrap.option` 函数来配置参数，配置参数作用于 SocketChannel。
- 服务端通过 `ServerBootstrap` 来配置参数：
    - 通过 `option` 来配置 ServerSocketChannel 上的参数。
    - 通过 `childOption` 来配置 SocketChannel 上的参数。

这意味着，在服务端 `option` 作用在服务启动时，`childOption` 作用在链接建立时。

#### CONNECT_TIMEOUT_MILLIS

建立连接时，如果在指定毫秒内无法连接，会抛出 timeout 异常。

```java
// SocketChannel 5s内未建立连接就抛出异常
new Bootstrap().option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 5000);

// ServerSocketChannel 5s内未建立连接就抛出异常
new ServerBootstrap().option(ChannelOption.CONNECT_TIMEOUT_MILLIS,5000);
// SocketChannel 5s内未建立连接就抛出异常
new ServerBootstrap().childOption(ChannelOption.CONNECT_TIMEOUT_MILLIS, 5000);
```

#### SO_BACKLOG

在 Netty 中，SO_BACKLOG 主要用于设置全连接队列的大小。当处理 Accept 的速率小于连接建立的速率时，全连接队列中堆积的连接数大于 SO_BACKLOG 设置的值时， 便会抛出异常。

对于高并发的服务端，建议设置的大一点，如 1024。

```java
new ServerBootstrap().option(ChannelOption.SO_BACKLOG, 1024);
```

#### SO_REUSEADDR

这个参数表示允许重复使用本地地址和端口。

比如某个进程非正常退出，该程序占用的端口可能要被占用一段时间才能允许其他进程使用，而且程序死掉以后，内核一需要一定的时间才能够释放此端口，不设置 SO_REUSEADDR 就无法正常使用该端口。

```java
new ServerBootstrap().option(ChannelOption.SO_REUSEADDR, true);
```

#### TCP_NODELAY

因为 Nagle 算法，数据包会堆积到一定的数量后一起发送，这就可能导致数据的发送存在一定的延时。该参数默认为 false，如果不希望的发送被延时，则需要将该值设置为 true。

我们总希望服务端可以及时响应，建议设置为 true。

```java
new ServerBootstrap().option(ChannelOption.TCP_NODELAY, true);
```

#### ALLOCATOR

ALLOCATOR 参数用来配置 ByteBuf 是池化还是非池化，是直接内存还是堆内存。

- 池化并使用直接内存

```java
new ServerBootstrap().option(ChannelOption.ALLOCATOR, new PooledByteBufAllocator(true));
```

- 池化并使用堆内存

```java
new ServerBootstrap().option(ChannelOption.ALLOCATOR, new PooledByteBufAllocator(false));
```

- 非池化并使用直接内存

```java
new ServerBootstrap().option(ChannelOption.ALLOCATOR, new UnpooledByteBufAllocator(true));
```

- 非池化并使用堆内存

```java
new ServerBootstrap().option(ChannelOption.ALLOCATOR, new UnpooledByteBufAllocator(false));
```

#### ulimit -n

Linux 系统参数，一般系统默认 1024。

进行 TCP 连接时，系统为每个 TCP 连接创建一个 socket 句柄，也就是一个文件句柄，但是 Linux 对每个进程打开的文件句柄数量做了限制，如果超出：报错 "Too many open file"。

建议调大,如 65535：

```C
echo ulimit -n 65535 >>/etc/profile 
source /etc/profile
```