# Netty 入门

- 目录
  - [入门案例](#入门案例)
  - [组件](#组件)
    - [EventLoop](#EventLoop)
      - [处理普通与定时任务](#处理普通与定时任务)
      - [任务分工](#任务分工)

Netty 是一个异步的、基于事件驱动的网络应用框架，用于快速开发可维护、高性能的网络服务器和客户端。

> 注意：Netty 的异步还是基于多路复用的，并没有实现真正意义上的异步 IO。

如果使用传统 NIO，其工作量大，bug 多，如：

- 需要自己构建协议
- 解决 TCP 传输问题，如粘包、半包
- 因为 bug 的存在，epoll 空轮询导致 CPU 100%

Netty 还对 API 进行增强，使之更易用，如 FastThreadLocal => ThreadLocal、ByteBuf => ByteBuffer。

### 入门案例

目标：开发一个简单的服务器端和客户端。

- 客户端向服务器端发送 "hello, world"。
- 服务器仅接收，不返回。

依赖：

```xml
<dependency>
    <groupId>io.netty</groupId>
    <artifactId>netty-all</artifactId>
    <version>4.1.39.Final</version>
</dependency>
```

服务端：

```java
public class HelloServer {
    public static void main(String[] args) {
        // 启动器，负责装配 netty 组件，启动服务器
        new ServerBootstrap()
                // 创建 NioEventLoopGroup，即 BossEventLoop, WorkerEventLoop(selector,thread), group 组
                // 可以简单理解为 线程池 + Selector
                .group(new NioEventLoopGroup())
                // 选择服务器的 ServerSocketChannel 实现
                .channel(NioServerSocketChannel.class)
                // child 负责处理读写，该方法决定了 child 执行哪些操作
                // boss 负责处理连接，worker(child) 负责处理读写，决定了 worker(child) 能执行哪些操作（handler）
                // ChannelInitializer 处理器（仅执行一次）
                // 它的作用是待客户端 SocketChannel 建立连接后，执行 initChannel 以便添加更多的处理器
                .childHandler(
                    // channel 代表和客户端进行数据读写的通道 Initializer 初始化，负责添加别的 handler
                    new ChannelInitializer<NioSocketChannel>() {
                        @Override
                        protected void initChannel(NioSocketChannel nioSocketChannel) {
                            // SocketChannel 的处理器，使用 StringDecoder 解码，ByteBuf=>String
                            nioSocketChannel.pipeline().addLast(new StringDecoder());
                            // SocketChannel 的业务处理，使用上一个处理器的处理结果
                            nioSocketChannel.pipeline().addLast(new SimpleChannelInboundHandler<String>() {
                                @Override
                                protected void channelRead0(ChannelHandlerContext channelHandlerContext, String s) {
                                    System.out.println(s);
                                }
                            });
                        }
                    }
                // ServerSocketChannel 绑定 8080 端口
                ).bind(8080);
    }
}
```

客户端：

```java
public class HelloClient {
    public static void main(String[] args) throws InterruptedException {
        // 启动类
        new Bootstrap()
                // 添加 EventLoop
                .group(new NioEventLoopGroup())
                // 选择客户 Socket 实现类，NioSocketChannel 表示基于 NIO 的客户端实现
                .channel(NioSocketChannel.class)
                // ChannelInitializer 处理器（仅执行一次）
                // 它的作用是待客户端SocketChannel建立连接后，执行initChannel以便添加更多的处理器
                .handler(new ChannelInitializer<Channel>() {
                    @Override
                    protected void initChannel(Channel channel) {
                        // 消息会经过通道 handler 处理，这里是将 String => ByteBuf 编码发出
                        channel.pipeline().addLast(new StringEncoder());
                    }
                })
                // 指定要连接的服务器和端口
                .connect(new InetSocketAddress("localhost", 8080))
                // Netty 中很多方法都是异步的，如 connect
                // 这时需要使用 sync 方法，这是一个阻塞方法，等待 connect 建立连接完毕
                .sync()
                // 获取 channel 对象，它即为通道抽象，可以进行数据读写操作
                .channel()
                // 写入消息并清空缓冲区
                .writeAndFlush("hello world");
    }
}
```

运行流程：

<div align="left">
    <img src="https://github.com/lazecoding/Note/blob/main/images/netty/netty入门案例流程分析.png" width="1000px">
</div>

> 解释：
>
> * 把 channel 理解为数据的通道
> * 把 msg 理解为流动的数据，最开始输入是 ByteBuf，但经过 pipeline 的加工，会变成其它类型对象，最后输出又变成 ByteBuf
> * 把 handler 理解为数据的处理工序
>   * 工序有多道，合在一起就是 pipeline，pipeline 负责发布事件（读、读取完成...）传播给每个 handler， handler 对自己感兴趣的事件进行处理（重写了相应事件处理方法）
>   * handler 分 Inbound 和 Outbound 两类
> * 把 eventLoop 理解为处理数据的工人
>   * 工人可以管理多个 channel 的 io 操作，并且一旦工人负责了某个 channel，就要负责到底（绑定）
>   * 工人既可以执行 io 操作，也可以进行任务处理，每位工人有任务队列，队列里可以堆放多个 channel 的待处理任务，任务分为普通任务、定时任务
>   * 工人按照 pipeline 顺序，依次按照 handler 的规划（代码）处理数据，可以为每道工序指定不同的工人

### 组件

#### EventLoop

EventLoop（事件循环对象）本质是一个`单线程执行器`（同时维护了一个 `Selector`），里面有 run 方法处理一个或多个 Channel 上源源不断的 IO 事件。

EventLoop 是个接口类，它的类图如下：

<我是图>

从 EventLoop 的继承结构上看，EventLoop  最近的父类是 OrderedEventExecutor 和 EventLoopGroup，他们都继承自 ScheduledExecutorService，
所以 EventLoop 的本质是一个 `单线程的任务执行器`，并拥有 next、parent、inEventLoop 等方法遍历执行器、获取此 EventLoop 所在的 EventExecutorGroup、
判断一个线程是否属于此 EventLoop。

EventLoopGroup（事件循环组）是一组 EventLoop，channel 一般会调用 EventLoopGroup 的 register 方法来绑定其中一个 EventLoop，
后续这个 Channel 上的 IO 事件都由此 EventLoop 来处理（保证了 IO 事件处理时的线程安全）。

##### 处理普通与定时任务

EventLoopGroup 继承自 ScheduledExecutorService，所以 EventLoopGroup 可以执行普通任务和定时任务。

```java
public class TestEventLoop {
    public static void main(String[] args) {
        // 创建拥有两个EventLoop的NioEventLoopGroup，对应两个线程
        EventLoopGroup group = new NioEventLoopGroup(2);
        // 通过next方法可以获得下一个 EventLoop
        System.out.println(group.next());
        System.out.println(group.next());

        // 通过EventLoop执行普通任务
        group.next().execute(()->{
            System.out.println(Thread.currentThread().getName() + " hello");
        });

        // 通过EventLoop执行定时任务
        group.next().scheduleAtFixedRate(()->{
            System.out.println(Thread.currentThread().getName() + " hello2");
        }, 0, 1, TimeUnit.SECONDS);
        
        // 优雅地关闭
        group.shutdownGracefully();
    }
}
```

`shutdownGracefully` 方法可以优雅地关闭执行器。该方法会首先切换 `EventLoopGroup` 到关闭状态以拒绝新的任务的加入，然后在任务队列的任务都处理完成后，停止线程的运行，
从而确保整体应用是在正常有序的状态下退出的。

##### 任务分工

ServerBootstrap 的 group() 方法可以传入两个 EventLoopGroup 参数，分别负责处理不同的事件。

```java
public ServerBootstrap group(EventLoopGroup group) {
    return this.group(group, group);
}

public ServerBootstrap group(EventLoopGroup parentGroup, EventLoopGroup childGroup) {
    super.group(parentGroup);
    ObjectUtil.checkNotNull(childGroup, "childGroup");
    if (this.childGroup != null) {
        throw new IllegalStateException("childGroup set already");
    } else {
        this.childGroup = childGroup;
        return this;
    }
}
```

两个 EventLoopGroup，分别为 Boss 负责 Accept 事件和 Worker 负责读写事件。

一个 EventLoop 可以负责多个 Channel，且 EventLoop 一旦与 Channel 绑定，则一直负责处理该 Channel 中的事件。

但是，当有的任务需要较长的时间处理时，同一个 NioEventLoop 中的其他 Channel 在较长的时间内都无法得到处理。为了避免这种情况，可以采用自定义 EventLoopGroup。

```java
public class MyServer {
    public static void main(String[] args) {
        // 增加自定义的非 NioEventLoopGroup
        EventLoopGroup group = new DefaultEventLoopGroup();
        
        new ServerBootstrap()
            .group(new NioEventLoopGroup(), new NioEventLoopGroup(2))
            .channel(NioServerSocketChannel.class)
            .childHandler(new ChannelInitializer<SocketChannel>() {
                @Override
                protected void initChannel(SocketChannel socketChannel) throws Exception {
                    // 增加两个 handler，第一个使用 NioEventLoopGroup 处理，第二个使用自定义 EventLoopGroup 处理
                    
                    // 使用 NioEventLoopGroup 处理
                    socketChannel.pipeline().addLast("nioHandler",new ChannelInboundHandlerAdapter() {
                        @Override
                        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
                            ByteBuf buf = (ByteBuf) msg;
                            System.out.println(Thread.currentThread().getName() + " " + buf.toString(StandardCharsets.UTF_8));
                            // 调用下一个handler
                            ctx.fireChannelRead(msg);
                        }
                    })
                    
                    // 该 handler 绑定自定义的 Group
                    .addLast(group, "myHandler", new ChannelInboundHandlerAdapter() {
                        @Override
                        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
                            ByteBuf buf = (ByteBuf) msg;
                            System.out.println(Thread.currentThread().getName() + " " + buf.toString(StandardCharsets.UTF_8));
                        }
                    });
                }
            })
            .bind(8080);
    }
}
```


