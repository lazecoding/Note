# Netty 入门

- 目录
  - [入门案例](#入门案例)
  - [组件](#组件)
    - [EventLoop](#EventLoop)
      - [处理普通与定时任务](#处理普通与定时任务)
      - [任务分工](#任务分工)
    - [Channel](#Channel)
      - [ChannelHandler](#ChannelHandler)
      - [ChannelPipeline](#ChannelPipeline)
      - [ChannelHandlerContext](#ChannelHandlerContext)

Netty 是一个异步的、基于事件驱动的网络应用框架，用于快速开发可维护、高性能的网络服务器和客户端。

> 注意：Netty 的异步还是基于多路复用的，并没有实现真正意义上的异步 IO。

如果使用传统 NIO，其工作量大，bug 多，如：

- 需要自己构建协议
- 解决 TCP 传输问题，如粘包、半包
- 因为 bug 的存在，epoll 空轮询导致 CPU 100%

Netty 还对 API 进行增强，使之更易用，如 FastThreadLocal => ThreadLocal、ByteBuf => ByteBuffer。

### 入门案例

目标：开发一个简单的服务器端和客户端。

- 客户端向服务器端发送 "hello, world"。
- 服务器仅接收，不返回。

依赖：

```xml
<dependency>
    <groupId>io.netty</groupId>
    <artifactId>netty-all</artifactId>
    <version>4.1.39.Final</version>
</dependency>
```

服务端：

```java
public class HelloServer {
    public static void main(String[] args) {
        // 启动器，负责装配 netty 组件，启动服务器
        new ServerBootstrap()
                // 创建 NioEventLoopGroup，即 BossEventLoop, WorkerEventLoop(selector,thread), group 组
                // 可以简单理解为 线程池 + Selector
                .group(new NioEventLoopGroup())
                // 选择服务器的 ServerSocketChannel 实现
                .channel(NioServerSocketChannel.class)
                // child 负责处理读写，该方法决定了 child 执行哪些操作
                // boss 负责处理连接，worker(child) 负责处理读写，决定了 worker(child) 能执行哪些操作（handler）
                // ChannelInitializer 处理器（仅执行一次）
                // 它的作用是待客户端 SocketChannel 建立连接后，执行 initChannel 以便添加更多的处理器
                .childHandler(
                    // channel 代表和客户端进行数据读写的通道 Initializer 初始化，负责添加别的 handler
                    new ChannelInitializer<NioSocketChannel>() {
                        @Override
                        protected void initChannel(NioSocketChannel nioSocketChannel) {
                            // SocketChannel 的处理器，使用 StringDecoder 解码，ByteBuf=>String
                            nioSocketChannel.pipeline().addLast(new StringDecoder());
                            // SocketChannel 的业务处理，使用上一个处理器的处理结果
                            nioSocketChannel.pipeline().addLast(new SimpleChannelInboundHandler<String>() {
                                @Override
                                protected void channelRead0(ChannelHandlerContext channelHandlerContext, String s) {
                                    System.out.println(s);
                                }
                            });
                        }
                    }
                // ServerSocketChannel 绑定 8080 端口
                ).bind(8080);
    }
}
```

客户端：

```java
public class HelloClient {
    public static void main(String[] args) throws InterruptedException {
        // 启动类
        new Bootstrap()
                // 添加 EventLoop
                .group(new NioEventLoopGroup())
                // 选择客户 Socket 实现类，NioSocketChannel 表示基于 NIO 的客户端实现
                .channel(NioSocketChannel.class)
                // ChannelInitializer 处理器（仅执行一次）
                // 它的作用是待客户端SocketChannel建立连接后，执行initChannel以便添加更多的处理器
                .handler(new ChannelInitializer<Channel>() {
                    @Override
                    protected void initChannel(Channel channel) {
                        // 消息会经过通道 handler 处理，这里是将 String => ByteBuf 编码发出
                        channel.pipeline().addLast(new StringEncoder());
                    }
                })
                // 指定要连接的服务器和端口
                .connect(new InetSocketAddress("localhost", 8080))
                // Netty 中很多方法都是异步的，如 connect
                // 这时需要使用 sync 方法，这是一个阻塞方法，等待 connect 建立连接完毕
                .sync()
                // 获取 channel 对象，它即为通道抽象，可以进行数据读写操作
                .channel()
                // 写入消息并清空缓冲区
                .writeAndFlush("hello world");
    }
}
```

运行流程：

<div align="left">
    <img src="https://github.com/lazecoding/Note/blob/main/images/netty/netty入门案例流程分析.png" width="1000px">
</div>

> 解释：
>
> * 把 channel 理解为数据的通道
> * 把 msg 理解为流动的数据，最开始输入是 ByteBuf，但经过 pipeline 的加工，会变成其它类型对象，最后输出又变成 ByteBuf
> * 把 handler 理解为数据的处理工序
>   * 工序有多道，合在一起就是 pipeline，pipeline 负责发布事件（读、读取完成...）传播给每个 handler， handler 对自己感兴趣的事件进行处理（重写了相应事件处理方法）
>   * handler 分 Inbound 和 Outbound 两类
> * 把 eventLoop 理解为处理数据的工人
>   * 工人可以管理多个 channel 的 io 操作，并且一旦工人负责了某个 channel，就要负责到底（绑定）
>   * 工人既可以执行 io 操作，也可以进行任务处理，每位工人有任务队列，队列里可以堆放多个 channel 的待处理任务，任务分为普通任务、定时任务
>   * 工人按照 pipeline 顺序，依次按照 handler 的规划（代码）处理数据，可以为每道工序指定不同的工人

### 组件

#### EventLoop

EventLoop（事件循环对象）本质是一个`单线程执行器`（同时维护了一个 `Selector`），里面有 run 方法处理一个或多个 Channel 上源源不断的 IO 事件。

EventLoop 是个接口类，它的类图如下：

<div align="left">
    <img src="https://github.com/lazecoding/Note/blob/main/images/netty/EventLoop类图.png" width="600px">
</div>

从 EventLoop 的继承结构上看，EventLoop  最近的父类是 OrderedEventExecutor 和 EventLoopGroup，他们都继承自 ScheduledExecutorService，
所以 EventLoop 的本质是一个 `单线程的任务执行器`，并拥有 next、parent、inEventLoop 等方法遍历执行器、获取此 EventLoop 所在的 EventExecutorGroup、
判断一个线程是否属于此 EventLoop。

EventLoopGroup（事件循环组）是一组 EventLoop，channel 一般会调用 EventLoopGroup 的 register 方法来绑定其中一个 EventLoop，
后续这个 Channel 上的 IO 事件都由此 EventLoop 来处理（保证了 IO 事件处理时的线程安全）。

##### 处理普通与定时任务

EventLoopGroup 继承自 ScheduledExecutorService，所以 EventLoopGroup 可以执行普通任务和定时任务。

```java
public class TestEventLoop {
    public static void main(String[] args) {
        // 创建拥有两个EventLoop的NioEventLoopGroup，对应两个线程
        EventLoopGroup group = new NioEventLoopGroup(2);
        // 通过next方法可以获得下一个 EventLoop
        System.out.println(group.next());
        System.out.println(group.next());

        // 通过EventLoop执行普通任务
        group.next().execute(()->{
            System.out.println(Thread.currentThread().getName() + " hello");
        });

        // 通过EventLoop执行定时任务
        group.next().scheduleAtFixedRate(()->{
            System.out.println(Thread.currentThread().getName() + " hello2");
        }, 0, 1, TimeUnit.SECONDS);
        
        // 优雅地关闭
        group.shutdownGracefully();
    }
}
```

`shutdownGracefully` 方法可以优雅地关闭执行器。该方法会首先切换 `EventLoopGroup` 到关闭状态以拒绝新的任务的加入，然后在任务队列的任务都处理完成后，停止线程的运行，
从而确保整体应用是在正常有序的状态下退出的。

##### 任务分工

ServerBootstrap 的 group() 方法可以传入两个 EventLoopGroup 参数，分别负责处理不同的事件。

```java
public ServerBootstrap group(EventLoopGroup group) {
    return this.group(group, group);
}

public ServerBootstrap group(EventLoopGroup parentGroup, EventLoopGroup childGroup) {
    super.group(parentGroup);
    ObjectUtil.checkNotNull(childGroup, "childGroup");
    if (this.childGroup != null) {
        throw new IllegalStateException("childGroup set already");
    } else {
        this.childGroup = childGroup;
        return this;
    }
}
```

两个 EventLoopGroup，分别为 Boss 负责 Accept 事件和 Worker 负责读写事件。

一个 EventLoop 可以负责多个 Channel，且 EventLoop 一旦与 Channel 绑定，则一直负责处理该 Channel 中的事件。

但是，当有的任务需要较长的时间处理时，同一个 NioEventLoop 中的其他 Channel 在较长的时间内都无法得到处理。为了避免这种情况，可以采用自定义 EventLoopGroup。

```java
public class MyServer {
    public static void main(String[] args) {
        // 增加自定义的非 NioEventLoopGroup
        EventLoopGroup group = new DefaultEventLoopGroup();
        
        new ServerBootstrap()
            .group(new NioEventLoopGroup(), new NioEventLoopGroup(2))
            .channel(NioServerSocketChannel.class)
            .childHandler(new ChannelInitializer<SocketChannel>() {
                @Override
                protected void initChannel(SocketChannel socketChannel) throws Exception {
                    // 增加两个 handler，第一个使用 NioEventLoopGroup 处理，第二个使用自定义 EventLoopGroup 处理
                    
                    // 使用 NioEventLoopGroup 处理
                    socketChannel.pipeline().addLast("nioHandler",new ChannelInboundHandlerAdapter() {
                        @Override
                        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
                            ByteBuf buf = (ByteBuf) msg;
                            System.out.println(Thread.currentThread().getName() + " " + buf.toString(StandardCharsets.UTF_8));
                            // 调用下一个handler
                            ctx.fireChannelRead(msg);
                        }
                    })
                    
                    // 该 handler 绑定自定义的 Group
                    .addLast(group, "myHandler", new ChannelInboundHandlerAdapter() {
                        @Override
                        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
                            ByteBuf buf = (ByteBuf) msg;
                            System.out.println(Thread.currentThread().getName() + " " + buf.toString(StandardCharsets.UTF_8));
                        }
                    });
                }
            })
            .bind(8080);
    }
}
```

#### Channel

Channel 是 Netty 的核心概念之一，它是 Netty 网络通信的主体，由它负责同对端进行网络通信、注册和数据操作等功能。

Channel 有个简单但强大的状态模型，与 ChannelInboundHandler API 密切相关。Channel 的 4 个状态如下：

- channelUnregistered：channel创建但未注册到一个 EventLoop。
- channelRegistered：channel 注册到一个 EventLoop。
- channelActive：channel 的活动的(连接到了它的 remote peer（远程对等方）)，现在可以接收和发送数据了。
- channelInactive：channel 没有连接到 remote peer（远程对等方）。

Channel 常用方法：

- close() 可以用来关闭 channel
- closeFuture() 用来处理 channel 的关闭
  - sync 方法作用是同步等待 channel 关闭
  - 而 addListener 方法是异步等待 channel 关闭
- pipeline() 方法添加处理器
- write() 方法将数据写入
- writeAndFlush() 方法将数据写入并刷出

##### ChannelHandler

当 Channel 状态变化出现，对应的事件将会生成，这样与 ChannelPipeline 中的 ChannelHandler 的交互就能及时响应。Channel 的一般的生命周期如下：

<div align="left">
    <img src="https://github.com/lazecoding/Note/blob/main/images/netty/Channel状态转移示意图.png" width="800px">
</div>

ChannelHandler 定义的生命周期操作：当 ChannelHandler 添加到 ChannelPipeline，或者从 ChannelPipeline 移除后，这些将会调用。每个方法都会带 ChannelHandlerContext 参数。

- handlerAdded：当 ChannelHandler 添加到 ChannelPipeline 调用。
- handlerRemoved：当 ChannelHandler 从 ChannelPipeline 移除时调用。
- exceptionCaught：当 ChannelPipeline 执行发生错误时调用。

Netty 提供 2 个重要的 ChannelHandler 子接口：

- ChannelInboundHandler：处理进站数据，并且所有状态都更改。
- ChannelOutboundHandler：处理出站数据，允许拦截各种操作。

打个比喻，每个 Channel 是一个产品的加工车间，Pipeline 是车间中的流水线，ChannelHandler 就是流水线上的各道工序，而后面要讲的 ByteBuf 是原材料，经过很多工序的加工：
先经过一道道入站工序，再经过一道道出站工序最终变成产品。

##### ChannelPipeline

我们可以认为 ChannelPipeline 是一系列 ChannelHandler 实例,用于拦截流经一个 Channel 的入站和出站事件,这些 ChannelHandler 可以提供的交互的核心应用程序的数据和事件处理逻辑。
每一个创建新 Channel ,分配一个新的 ChannelPipeline。这个关联是永久性的；Channel 既不能附上另一个 ChannelPipeline 也不能分离当前这个。

根据事件的起源，一个事件将由 ChannelInboundHandler 或 ChannelOutboundHandler 处理。随后它将调用 ChannelHandlerContext 实现转发到下一个相同的超类型的处理程序。

一组 ChannelHandler 的典型 ChannelPipeline 布局如下：

<div align="left">
    <img src="https://github.com/lazecoding/Note/blob/main/images/netty/一组ChannelHandler的典型ChannelPipeline布局示意图.png" width="800px">
</div>

可以看到，ChannelInboundHandler 是按照 addLast 的顺序执行的，而 ChannelOutboundHandler 是按照 addLast 的逆序执行的。
ChannelPipeline 的实现是一个 ChannelHandlerContext 组成的双向链表。

##### ChannelHandlerContext

ChannelHandlerContext 代表 ChannelHandler 和ChannelPipeline 之间的关联,并在 ChannelHandler 添加到 ChannelPipeline 时创建一个实例。
ChannelHandlerContext 的主要功能是管理通过同一个 ChannelPipeline 关联的 ChannelHandler 之间的交互。

ChannelPipeline 的实现是一个 ChannelHandlerContext 组成的双向链表。

<div align="left">
    <img src="https://github.com/lazecoding/Note/blob/main/images/netty/ChannelPipeline的实现是ChannelHandlerContext双向链表.png" width="800px">
</div>

1. Channel 绑定到 ChannelPipeline。
2. ChannelPipeline 绑定到 包含 ChannelHandler 的 Channel。
3. ChannelHandler。
4. 当添加 ChannelHandler 到 ChannelPipeline 时，ChannelHandlerContext 被创建。

