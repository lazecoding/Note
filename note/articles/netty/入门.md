# Netty 入门

- 目录
  - [入门案例](#入门案例)

Netty 是一个异步的、基于事件驱动的网络应用框架，用于快速开发可维护、高性能的网络服务器和客户端。

> 注意：Netty 的异步还是基于多路复用的，并没有实现真正意义上的异步 IO。

如果使用传统 NIO，其工作量大，bug 多，如：

- 需要自己构建协议
- 解决 TCP 传输问题，如粘包、半包
- 因为 bug 的存在，epoll 空轮询导致 CPU 100%

Netty 还对 API 进行增强，使之更易用，如 FastThreadLocal => ThreadLocal、ByteBuf => ByteBuffer。

### 入门案例

目标：开发一个简单的服务器端和客户端。

- 客户端向服务器端发送 "hello, world"。
- 服务器仅接收，不返回。

依赖：

```xml
<dependency>
    <groupId>io.netty</groupId>
    <artifactId>netty-all</artifactId>
    <version>4.1.39.Final</version>
</dependency>
```

服务端：

```java
public class HelloServer {
    public static void main(String[] args) {
        // 启动器，负责装配 netty 组件，启动服务器
        new ServerBootstrap()
                // 创建 NioEventLoopGroup，即 BossEventLoop, WorkerEventLoop(selector,thread), group 组
                // 可以简单理解为 线程池 + Selector
                .group(new NioEventLoopGroup())
                // 选择服务器的 ServerSocketChannel 实现
                .channel(NioServerSocketChannel.class)
                // child 负责处理读写，该方法决定了 child 执行哪些操作
                // boss 负责处理连接，worker(child) 负责处理读写，决定了 worker(child) 能执行哪些操作（handler）
                // ChannelInitializer 处理器（仅执行一次）
                // 它的作用是待客户端 SocketChannel 建立连接后，执行 initChannel 以便添加更多的处理器
                .childHandler(
                    // channel 代表和客户端进行数据读写的通道 Initializer 初始化，负责添加别的 handler
                    new ChannelInitializer<NioSocketChannel>() {
                        @Override
                        protected void initChannel(NioSocketChannel nioSocketChannel) {
                            // SocketChannel 的处理器，使用 StringDecoder 解码，ByteBuf=>String
                            nioSocketChannel.pipeline().addLast(new StringDecoder());
                            // SocketChannel 的业务处理，使用上一个处理器的处理结果
                            nioSocketChannel.pipeline().addLast(new SimpleChannelInboundHandler<String>() {
                                @Override
                                protected void channelRead0(ChannelHandlerContext channelHandlerContext, String s) {
                                    System.out.println(s);
                                }
                            });
                        }
                    }
                // ServerSocketChannel 绑定 8080 端口
                ).bind(8080);
    }
}
```

客户端：

```java
public class HelloClient {
    public static void main(String[] args) throws InterruptedException {
        // 启动类
        new Bootstrap()
                // 添加 EventLoop
                .group(new NioEventLoopGroup())
                // 选择客户 Socket 实现类，NioSocketChannel 表示基于 NIO 的客户端实现
                .channel(NioSocketChannel.class)
                // ChannelInitializer 处理器（仅执行一次）
                // 它的作用是待客户端SocketChannel建立连接后，执行initChannel以便添加更多的处理器
                .handler(new ChannelInitializer<Channel>() {
                    @Override
                    protected void initChannel(Channel channel) {
                        // 消息会经过通道 handler 处理，这里是将 String => ByteBuf 编码发出
                        channel.pipeline().addLast(new StringEncoder());
                    }
                })
                // 指定要连接的服务器和端口
                .connect(new InetSocketAddress("localhost", 8080))
                // Netty 中很多方法都是异步的，如 connect
                // 这时需要使用 sync 方法，这是一个阻塞方法，等待 connect 建立连接完毕
                .sync()
                // 获取 channel 对象，它即为通道抽象，可以进行数据读写操作
                .channel()
                // 写入消息并清空缓冲区
                .writeAndFlush("hello world");
    }
}
```

运行流程：

<div align="left">
    <img src="https://github.com/lazecoding/Note/blob/main/images/netty/netty入门案例流程分析.png" width="600px">
</div>

> 解释：
>
> * 把 channel 理解为数据的通道
> * 把 msg 理解为流动的数据，最开始输入是 ByteBuf，但经过 pipeline 的加工，会变成其它类型对象，最后输出又变成 ByteBuf
> * 把 handler 理解为数据的处理工序
>   * 工序有多道，合在一起就是 pipeline，pipeline 负责发布事件（读、读取完成...）传播给每个 handler， handler 对自己感兴趣的事件进行处理（重写了相应事件处理方法）
>   * handler 分 Inbound 和 Outbound 两类
> * 把 eventLoop 理解为处理数据的工人
>   * 工人可以管理多个 channel 的 io 操作，并且一旦工人负责了某个 channel，就要负责到底（绑定）
>   * 工人既可以执行 io 操作，也可以进行任务处理，每位工人有任务队列，队列里可以堆放多个 channel 的待处理任务，任务分为普通任务、定时任务
>   * 工人按照 pipeline 顺序，依次按照 handler 的规划（代码）处理数据，可以为每道工序指定不同的工人

