# 启动流程

- 目录
  - [环境准备](#环境准备)
  - [代码实例](#代码实例)
  - [流程简化](#流程简化)
  - [NioEventLoopGroup](#NioEventLoopGroup)
    - [NioEventLoop](#NioEventLoop)
  
Netty 作为 NIO 的库，自然既可以作为服务端接受请求，也可以作为客户端发起请求。使用 Netty 开发客户端或服务端都是非常简单的，Netty 做了很好的封装，
我们通常只要开发一个或多个 handler 用来处理我们的自定义逻辑就可以了。

前面我们已经分析过 [Netty 架构模型](https://github.com/lazecoding/Note/blob/main/note/articles/netty/架构模型.md) ,
现在我们从 Netty 服务器的启动流程开始讲解。

### 环境准备

新建 SpringBoot 工程引入 netty 依赖。

maven 依赖：

```xml
<dependency>
  <groupId>io.netty</groupId>
  <artifactId>netty-all</artifactId>
  <version>4.1.39.Final</version>
</dependency>
```

### 代码实例

客户端：

```java
// Configure the client.
EventLoopGroup group = new NioEventLoopGroup(); // 创建 EventLoopGroup
try {
    Bootstrap b = new Bootstrap(); // 创建 Bootstrap
    b.group(group) // 为 Bootstrap 设置 EventLoopGroup
     .channel(NioSocketChannel.class)  // 指定使用 NIO 的传输 Channel
     .option(ChannelOption.TCP_NODELAY, true)
     .handler(new ChannelInitializer<SocketChannel>() { // 设置处理器
         @Override
         public void initChannel(SocketChannel ch) throws Exception {
             ChannelPipeline p = ch.pipeline();
             if (sslCtx != null) {
                 p.addLast(sslCtx.newHandler(ch.alloc(), HOST, PORT));
             }
             //p.addLast(new LoggingHandler(LogLevel.INFO));
             p.addLast(new EchoClientHandler());
         }
     });

    // Start the client.
    ChannelFuture f = b.connect(HOST, PORT).sync(); // 连接到远程，sync等待连接完成

    // Wait until the connection is closed. 
    f.channel().closeFuture().sync(); // 等待服务器关闭
} finally {
    // Shut down the event loop to terminate all threads.
    // 释放 EventLoopGroup 资源
    group.shutdownGracefully();
}
```

服务器：

```java
 // Configure the server.
EventLoopGroup bossGroup = new NioEventLoopGroup(1);  // 创建 boss EventLoopGroup 
EventLoopGroup workerGroup = new NioEventLoopGroup(); // 创建 worker EventLoopGroup
final EchoServerHandler serverHandler = new EchoServerHandler();
try {
    ServerBootstrap b = new ServerBootstrap(); // 创建 ServerBootstrap
    b.group(bossGroup, workerGroup)   // 为 ServerBootstrap 设置 EventLoopGroup
     .channel(NioServerSocketChannel.class) // 指定使用 NIO 的传输 Channel
     .option(ChannelOption.SO_BACKLOG, 100) // 设置 boss 线程的属性
     .handler(new LoggingHandler(LogLevel.INFO)) // 设置 boss 线程的处理器
     .childHandler(new ChannelInitializer<SocketChannel>() { // 设置 worker 线程的处理器
         @Override
         public void initChannel(SocketChannel ch) throws Exception {
             ChannelPipeline p = ch.pipeline();
             if (sslCtx != null) {
                 p.addLast(sslCtx.newHandler(ch.alloc()));
             }
             //p.addLast(new LoggingHandler(LogLevel.INFO));
             p.addLast(serverHandler); // 添加处理器
         }
     });

    // Start the server.
    ChannelFuture f = b.bind(PORT).sync(); // 绑定的服务器，sync 等待服务器关闭

    // Wait until the server socket is closed.
    f.channel().closeFuture().sync(); // 等待服务器关闭
} finally {
    // Shut down all event loops to terminate all threads.
    // 释放 EventLoopGroup 资源
    bossGroup.shutdownGracefully();
    workerGroup.shutdownGracefully();
}
```

分析：

- ServerBootstrap 类用于创建服务端实例，Bootstrap 用于创建客户端实例。
- 客户端一个 EventLoopGroup，服务器有来个 EventLoopGroup（bossGroup 和 workerGroup） ，它们就是 Netty 中的线程池。
- Netty 中的 Channel，没有直接使用 Java 原生的 ServerSocketChannel 和 SocketChannel，而是包装了 NioServerSocketChannel 和 NioSocketChannel 与之对应。
- `option()` 和 `handler()` 用于设置 EventLoopGroup 的属性和处理器，
  对于服务端设置的是 bossGroup 的属性和处理器，服务端的 workerGroup 的属性和处理器是通过 `childOption()` 和 `childHandler()` 设置的。
- handler 可以指定多个（ChannelInitializer 类辅助完成），它们会组成了一个 pipeline，每个 NioSocketChannel 或 NioServerSocketChannel 实例内部都会有一个 pipeline 实例。
- bind 就是绑定端口。
- ChannelFuture：这个涉及到 Netty 中的异步编程，和 JDK 中的 Future 接口类似。

### 流程简化

Netty 服务端启动流程可以简化成如下代码：

```java
// Netty 中使用 NioEventLoopGroup 来封装线程和 Selector
Selector selector = Selector.open(); 

// 当发生建立连接事件，创建 NioServerSocketChannel 并初始化它关联的 ChannelHandler。
NioServerSocketChannel attachment = new NioServerSocketChannel();

// 创建 NioServerSocketChannel 时，创建 Java 原生的 ServerSocketChannel，将其设置为非阻塞模式
ServerSocketChannel serverSocketChannel = ServerSocketChannel.open(); 
serverSocketChannel.configureBlocking(false);

// 将 ServerSocketChannel 注册到 Selector 中，此时还未关注事件        
SelectionKey selectionKey = serverSocketChannel.register(selector, 0, attachment);

// head -> 初始化器 -> ServerBootstrapAcceptor -> tail，初始化器是一次性的，只为添加 acceptor

// 绑定端口
serverSocketChannel.bind(new InetSocketAddress(8080));

// 设置关注的事件: 触发 channel active 事件，关注 op_accept 事件
selectionKey.interestOps(SelectionKey.OP_ACCEPT);
```

- NioEventloopGroup 中封装了线程和 Selector。
- 当发生建立连接事件，创建 NioServerSocketChannel 并初始化它关联的 ChannelHandler。
- 创建 Java 原生的 ServerSocketChannel，将其设置为非阻塞模式，并注册到 Selector 中，此时未关注事件。
- 绑定端口。
- 设置关注的事件。

### NioEventLoopGroup

NioEventLoopGroup 中封装了线程和 Selector，在看 Netty 启动流程之前，首先需要看 NioEventLoopGroup。

NioEventLoopGroup 类图：

<div align="left">
    <img src="https://github.com/lazecoding/Note/blob/main/images/netty/NioEventLoopGroup类图.png" width="600px">
</div>

我们可以看到 NioEventLoopGroup 继承自 Executor，Executor 是线程池执行器接口，这意味着 NioEventLoopGroup 本身就是线程池的实现，也由此封装了线程。

我们接着看 NioEventLoopGroup 是如何封装 Selector 的，走进构造函数，一步步点进去，
最终会进入 `MultithreadEventExecutorGroup 构造函数`。

MultithreadEventExecutorGroup 构造函数：

```java
// io/netty/util/concurrent/MultithreadEventExecutorGroup.java#MultithreadEventExecutorGroup
protected MultithreadEventExecutorGroup(int nThreads, Executor executor,
                                        EventExecutorChooserFactory chooserFactory, Object... args) {
    if (nThreads <= 0) {
        throw new IllegalArgumentException(String.format("nThreads: %d (expected: > 0)", nThreads));
    }

    if (executor == null) {
        executor = new ThreadPerTaskExecutor(newDefaultThreadFactory());
    }
    // children 是个 EventExecutor[]，由线程池线程数量决定数组大小 
    children = new EventExecutor[nThreads];

    for (int i = 0; i < nThreads; i ++) {
        boolean success = false;
        try {
            // 重点！
            // newChild 是个接口，具体我们看 NioEventLoopGroup 中的实现
            children[i] = newChild(executor, args);
            success = true;
        } catch (Exception e) {
            // TODO: Think about if this is a good exception type
            throw new IllegalStateException("failed to create a child event loop", e);
        } finally {
            if (!success) {
                for (int j = 0; j < i; j ++) {
                    children[j].shutdownGracefully();
                }

                for (int j = 0; j < i; j ++) {
                    EventExecutor e = children[j];
                    try {
                        while (!e.isTerminated()) {
                            e.awaitTermination(Integer.MAX_VALUE, TimeUnit.SECONDS);
                        }
                    } catch (InterruptedException interrupted) {
                        // Let the caller handle the interruption.
                        Thread.currentThread().interrupt();
                        break;
                    }
                }
            }
        }
    }
    
    // chooser 是一个分发器，根据 eventLoopGroup 中的 loop 数量来选择分发策略，把接受得到的事件分发给 group 中的 eventloop 执行。
    chooser = chooserFactory.newChooser(children);

    final FutureListener<Object> terminationListener = new FutureListener<Object>() {
        @Override
        public void operationComplete(Future<Object> future) throws Exception {
            if (terminatedChildren.incrementAndGet() == children.length) {
                terminationFuture.setSuccess(null);
            }
        }
    };

    for (EventExecutor e: children) {
        e.terminationFuture().addListener(terminationListener);
    }

    Set<EventExecutor> childrenSet = new LinkedHashSet<EventExecutor>(children.length);
    Collections.addAll(childrenSet, children);
    readonlyChildren = Collections.unmodifiableSet(childrenSet);
}
```

我们可以看到，NioEventLoopGroup 线程数设置了多少，就创建多少个 EventLoop 存储在数组 children 中。children 是个 EventExecutor[] 数组，
这里存储的是 `NioEventLoopGroup#newChild` 返回的 EventLoop。

NioEventLoopGroup#newChild：

```java
// io/netty/channel/nio/NioEventLoopGroup.java#newChild
@Override
protected EventLoop newChild(Executor executor, Object... args) throws Exception {
    return new NioEventLoop(this, executor, (SelectorProvider) args[0],
        ((SelectStrategyFactory) args[1]).newSelectStrategy(), (RejectedExecutionHandler) args[2]);
}
```

newChild 是个接口，我们关注它在 NioEventLoopGroup 中的实现，它实际上是 `new NioEventLoop`。

#### NioEventLoop

NioEventLoop 构造函数：

```java
// io/netty/channel/nio/NioEventLoop.java#NioEventLoop
NioEventLoop(NioEventLoopGroup parent, Executor executor, SelectorProvider selectorProvider,
             SelectStrategy strategy, RejectedExecutionHandler rejectedExecutionHandler) {
    super(parent, executor, false, DEFAULT_MAX_PENDING_TASKS, rejectedExecutionHandler);
    if (selectorProvider == null) {
        throw new NullPointerException("selectorProvider");
    }
    if (strategy == null) {
        throw new NullPointerException("selectStrategy");
    }
    provider = selectorProvider;
    final SelectorTuple selectorTuple = openSelector();
    selector = selectorTuple.selector;
    unwrappedSelector = selectorTuple.unwrappedSelector;
    selectStrategy = strategy;
}
```

NioEventLoop 构造函数中，通过 `openSelector()` 获取了 Selector 并注入 NioEventLoop 中，这就完成了 NioEventLoopGroup 对 Selector 的封装。

NioEventLoop 类图：

<div align="left">
    <img src="https://github.com/lazecoding/Note/blob/main/images/netty/NioEventLoop类图.png" width="600px">
</div>

从类图中，我们可以看到 NioEventLoop 继承了 SingleThreadEventExecutor，从名字看它是一个单线程的时间执行器。

```java
// io/netty/util/concurrent/SingleThreadEventExecutor.java

// 任务队列
private final Queue<Runnable> taskQueue;

// 线程
private volatile Thread thread;
```

SingleThreadEventExecutor 内部包含一个 taskQueue（任务队列）和一个 thread（处理任务的线程）。

当我们执行 ` EventLoop.execute(...);`,调用的是 `SingleThreadEventExecutor#execute`。

SingleThreadEventExecutor#execute：

```java
// io/netty/util/concurrent/SingleThreadEventExecutor.java#execute
@Override
public void execute(Runnable task) {
    if (task == null) {
        throw new NullPointerException("task");
    }

    // 判断当前线程是否为NIO线程
    // 判断方法为 return thread == this.thread;
    // this.thread即为NIO线程，首次执行任务时，其为null
    boolean inEventLoop = inEventLoop();

    if (inEventLoop) {
        // 当前线程是 NIO 线程 分支
        // 向任务队列 taskQueue 中添加任务
        addTask(task);
    } else {
        // 当前线程不是 NIO 线程 分支
        // 启动 NIO 线程的核心方法
        startThread();
        // 向任务队列 taskQueue 中添加任务
        addTask(task);
        if (isShutdown() && removeTask(task)) {
            reject();
        }
    }

    // 有任务需要被执行时，唤醒阻塞的 NIO 线程
    if (!addTaskWakesUp && wakesUpForTask(task)) {
        wakeup(inEventLoop);
    }
}
```

我们可以看到，NioEventLoop 中的线程，在首次执行任务时，才会被创建，且只会被创建一次。

SingleThreadEventExecutor#startThread:

```java
// io/netty/util/concurrent/SingleThreadEventExecutor.java#startThread
private void startThread() {
    // 查看 NIO 线程状态是否为未启动
    // 该 if 代码块只会执行一次
    // state 一开始的值就是 ST_NOT_STARTED
    // private volatile int state = ST_NOT_STARTED;
    if (state == ST_NOT_STARTED) {
        // 通过原子属性更新器将状态更新为启动（ST_STARTED）
        if (STATE_UPDATER.compareAndSet(this, ST_NOT_STARTED, ST_STARTED)) {
            boolean success = false;
            try {
                // 执行启动线程
                doStartThread();
                success = true;
            } finally {
                if (!success) {
                    STATE_UPDATER.compareAndSet(this, ST_STARTED, ST_NOT_STARTED);
                }
            }
        }
    }
}
```

这里通过 CAS 保证 state 的线程安全，意味着只会创建一个线程。

SingleThreadEventExecutor#doStartThread：

```java
// io/netty/util/concurrent/SingleThreadEventExecutor.java#doStartThread
private void doStartThread() {
    assert thread == null;
    // 创建 NIO 线程并执行任务
    executor.execute(new Runnable() {
        @Override
        public void run() {
            // 这个 thread 即为 NIO 线程
            thread = Thread.currentThread();
            if (interrupted) {
                thread.interrupt();
            }

            boolean success = false;
            updateLastExecutionTime();
            try {
                // 通过 SingleThreadEventExecutor.this.run() 执行传入的任务
                // 该 run 方法是 NioEvnetLoop 的 run 方法
                SingleThreadEventExecutor.this.run();
                success = true;
            } catch (Throwable t) {
                logger.warn("Unexpected exception from an event executor: ", t);
            } finally {
                // ...
            }
        }
    });
}
```

doStartThread() 真正创建了 NIO 线程并执行任务。

NioEventLoop#run：

```java
// io/netty/channel/nio/NioEventLoop.java#run
@Override
protected void run() {
    // 这是一个死循环，不断地从任务队列中获取各种任务来执行
    for (;;) {
        try {
            switch (selectStrategy.calculateStrategy(selectNowSupplier, hasTasks())) {
                case SelectStrategy.CONTINUE:
                    continue;
                case SelectStrategy.SELECT:
                    // 如果没有事件，就阻塞
                    select(wakenUp.getAndSet(false));

                    // 有任务需要被执行时，唤醒阻塞的 NIO 线程
                    if (wakenUp.get()) {
                        selector.wakeup();
                    }
                    // fall through
                default:
            }

            cancelledKeys = 0;
            needsToSelectAgain = false;
            final int ioRatio = this.ioRatio;
            // ioRatio 是处理 IO 事件用时的比例（分为处理 IO 事件和其他任务）
            if (ioRatio == 100) {
                try {
                    // 处理 IO 事件
                    processSelectedKeys();
                } finally {
                    // Ensure we always run tasks.
                    // 处理普通任务和定时任务
                    runAllTasks();
                }
            } else {
                final long ioStartTime = System.nanoTime();
                try {
                    // 处理 IO 事件
                    processSelectedKeys();
                } finally {
                    // Ensure we always run tasks.
                    // ioTime 为处理 IO 事件耗费的时间
                    final long ioTime = System.nanoTime() - ioStartTime;
                    // 计算出处理其他任务的时间
                    // 超过设定的时间后，将会停止任务的执行，会在下一次循环中再继续执行
                    runAllTasks(ioTime * (100 - ioRatio) / ioRatio);
                }
            }
        } catch (Throwable t) {
            handleLoopException(t);
        }
        // Always handle shutdown even if the loop processing threw an exception.
        try {
            if (isShuttingDown()) {
                closeAll();
                if (confirmShutdown()) {
                    return;
                }
            }
        } catch (Throwable t) {
            handleLoopException(t);
        }
    }
}
```

`NioEventLoop#run` 内部是一个死循环，不断地从任务列表中取出任务执行，但该循环不会空转，执行到某些代码时，会被阻塞。
当有任务需要处理，先唤醒阻塞的 NIO 线程。

ioRatio 是处理 IO 事件用时的比例，根据这个参数决定处理 IO 事件和其他任务的时间。
`processSelectedKeys()` 处理 IO 事件，`runAllTasks()` 处理普通任务和定时任务。