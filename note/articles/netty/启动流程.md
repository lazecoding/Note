# 启动流程

Netty 作为 NIO 的库，自然既可以作为服务端接受请求，也可以作为客户端发起请求。使用 Netty 开发客户端或服务端都是非常简单的，Netty 做了很好的封装，
我们通常只要开发一个或多个 handler 用来处理我们的自定义逻辑就可以了。

前面我们已经分析过 [Netty 架构模型](https://github.com/lazecoding/Note/blob/main/note/articles/netty/架构模型.md) ,
现在我们从 Netty 服务器的启动流程开始讲解。

### 环境准备

新建 SpringBoot 工程引入 netty 依赖。

maven 依赖：

```xml
<dependency>
  <groupId>io.netty</groupId>
  <artifactId>netty-all</artifactId>
  <version>4.1.39.Final</version>
</dependency>
```

### 代码实例

客户端：

```java
// Configure the client.
EventLoopGroup group = new NioEventLoopGroup(); // 创建 EventLoopGroup
try {
    Bootstrap b = new Bootstrap(); // 创建 Bootstrap
    b.group(group) // 为 Bootstrap 设置 EventLoopGroup
     .channel(NioSocketChannel.class)  // 指定使用 NIO 的传输 Channel
     .option(ChannelOption.TCP_NODELAY, true)
     .handler(new ChannelInitializer<SocketChannel>() { // 设置处理器
         @Override
         public void initChannel(SocketChannel ch) throws Exception {
             ChannelPipeline p = ch.pipeline();
             if (sslCtx != null) {
                 p.addLast(sslCtx.newHandler(ch.alloc(), HOST, PORT));
             }
             //p.addLast(new LoggingHandler(LogLevel.INFO));
             p.addLast(new EchoClientHandler());
         }
     });

    // Start the client.
    ChannelFuture f = b.connect(HOST, PORT).sync(); // 连接到远程，sync等待连接完成

    // Wait until the connection is closed. 
    f.channel().closeFuture().sync(); // 等待服务器关闭
} finally {
    // Shut down the event loop to terminate all threads.
    // 释放 EventLoopGroup 资源
    group.shutdownGracefully();
}
```

服务器：

```java
 // Configure the server.
EventLoopGroup bossGroup = new NioEventLoopGroup(1);  // 创建 boss EventLoopGroup 
EventLoopGroup workerGroup = new NioEventLoopGroup(); // 创建 worker EventLoopGroup
final EchoServerHandler serverHandler = new EchoServerHandler();
try {
    ServerBootstrap b = new ServerBootstrap(); // 创建 ServerBootstrap
    b.group(bossGroup, workerGroup)   // 为 ServerBootstrap 设置 EventLoopGroup
     .channel(NioServerSocketChannel.class) // 指定使用 NIO 的传输 Channel
     .option(ChannelOption.SO_BACKLOG, 100) // 设置 boss 线程的属性
     .handler(new LoggingHandler(LogLevel.INFO)) // 设置 boss 线程的处理器
     .childHandler(new ChannelInitializer<SocketChannel>() { // 设置 worker 线程的处理器
         @Override
         public void initChannel(SocketChannel ch) throws Exception {
             ChannelPipeline p = ch.pipeline();
             if (sslCtx != null) {
                 p.addLast(sslCtx.newHandler(ch.alloc()));
             }
             //p.addLast(new LoggingHandler(LogLevel.INFO));
             p.addLast(serverHandler); // 添加处理器
         }
     });

    // Start the server.
    ChannelFuture f = b.bind(PORT).sync(); // 绑定的服务器，sync 等待服务器关闭

    // Wait until the server socket is closed.
    f.channel().closeFuture().sync(); // 等待服务器关闭
} finally {
    // Shut down all event loops to terminate all threads.
    // 释放 EventLoopGroup 资源
    bossGroup.shutdownGracefully();
    workerGroup.shutdownGracefully();
}
```

分析：

- ServerBootstrap 类用于创建服务端实例，Bootstrap 用于创建客户端实例。
- 客户端一个 EventLoopGroup，服务器有来个 EventLoopGroup（bossGroup 和 workerGroup） ，它们就是 Netty 中的线程池。
- Netty 中的 Channel，没有直接使用 Java 原生的 ServerSocketChannel 和 SocketChannel，而是包装了 NioServerSocketChannel 和 NioSocketChannel 与之对应。
- `option()` 和 `handler()` 用于设置 EventLoopGroup 的属性和处理器，
  对于服务端设置的是 bossGroup 的属性和处理器，服务端的 workerGroup 的属性和处理器是通过 `childOption()` 和 `childHandler()` 设置的。
- handler 可以指定多个（ChannelInitializer 类辅助完成），它们会组成了一个 pipeline，每个 NioSocketChannel 或 NioServerSocketChannel 实例内部都会有一个 pipeline 实例。
- bind 就是绑定端口。
- ChannelFuture：这个涉及到 Netty 中的异步编程，和 JDK 中的 Future 接口类似。

### 流程简化

Netty 服务端启动流程可以简化成如下代码：

```java
// Netty 中使用 NioEventLoopGroup 来封装线程和 Selector
Selector selector = Selector.open(); 

// 当发生建立连接事件，创建 NioServerSocketChannel 并初始化它关联的 ChannelHandler。
NioServerSocketChannel attachment = new NioServerSocketChannel();

// 创建 NioServerSocketChannel 时，创建 Java 原生的 ServerSocketChannel，将其设置为非阻塞模式
ServerSocketChannel serverSocketChannel = ServerSocketChannel.open(); 
serverSocketChannel.configureBlocking(false);

// 将 ServerSocketChannel 注册到 Selector 中，此时还未关注事件        
SelectionKey selectionKey = serverSocketChannel.register(selector, 0, attachment);

// head -> 初始化器 -> ServerBootstrapAcceptor -> tail，初始化器是一次性的，只为添加 acceptor

// 绑定端口
serverSocketChannel.bind(new InetSocketAddress(8080));

// 设置关注的事件: 触发 channel active 事件，关注 op_accept 事件
selectionKey.interestOps(SelectionKey.OP_ACCEPT);
```

- NioEventloopGroup 中封装了线程和 Selector。
- 当发生建立连接事件，创建 NioServerSocketChannel 并初始化它关联的 ChannelHandler。
- 创建 Java 原生的 ServerSocketChannel，将其设置为非阻塞模式，并注册到 Selector 中，此时未关注事件。
- 绑定端口。
- 设置关注的事件。