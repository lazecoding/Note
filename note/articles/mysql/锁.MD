# 锁

数据库系统使用锁是为例支持对共享资源进行并发访问，保障数据的完整性和一致性。

###  锁设计

不同存储引擎的锁设计是不一样的，InnoDB 存储引擎会在行级对数据上锁，不过 InnoDB 存储引擎也会在数据库内部其他多个地方使用锁。例如，操作缓存池中的LRU列表，删除、添加、移动LRU列表中的元素，为了保持一致性，必须有锁的介入。
MyISAM 存储引擎中锁是表锁设计，在并发读没啥问题，但是相比行锁并发写的性能就差了很多。

### InnoDB 存储引擎中的锁

InnoDB 存储引擎实现了两种标准的行级锁：
- `共享锁（S Lock）`:允许事务读一行数据
- `排他锁（X Lock）`:允许事务删除或更新一行数据

如果一个事务 T1 已经获取了行 r 的共享锁，那么另外的事务 T2 也可以获得行 r 的共享锁，称锁兼容，因为读共享，并没有改变数据。但如果其他事务 T3 想获取行 r 的排他锁，则必须等待事务 T1 和 T2 释放行 r 上的共享锁，称锁不兼容。下表显示了共享锁和排他锁的兼容性：

|     |    X  |   S   |
| --- | ----- | ----- |
|  X  | 不兼容 | 不兼容 |
|  S  | 不兼容 | 兼容   |

InnoDB 存储引擎支持多粒度锁定，这种锁定允许事务在行级上的锁和表级上的锁同时存在，为了支持多粒度上加锁 InnoDB 存储引擎支持一种额外加锁方式，称之为意向锁。
意向锁是将锁定的对象分为多个层次，意向锁意味着事务希望在更细粒度上进行加锁。意向锁的设计比较简练，其意向锁即为表级锁，目的主要为了在一个事务中揭示下一行将被请求的锁类型。其支持两种意向锁：
- `意向共享锁（IS Lock）`:事务想要获得一张表中的某些行数据的共享锁
- `意向排他锁（IX Lock）`:事务想要获得一张表中的某些行数据的排他锁
由于 InnoDB 存储引擎支持的是行级的锁，因此意向锁并不会阻塞除全部扫以外的任何请求。表级意向锁和行级锁的兼容性如下表：


|     |    IS  |  IX   |   S    |   X   |
| --- | ----- | -----  | ------ | ----- |
|  IS | 兼容   | 兼容   |  兼容    | 不兼容 |
|  IX | 兼容   | 兼容   |  不兼容  | 不兼容   |
|  S  | 兼容   | 不兼容 |  兼容    | 不兼容 |
|  X  | 不兼容 | 不兼容  | 不兼容   | 不兼容   |

用户可以通过 `SHOW ENGINE INNODB STATUS` 命令查看当前锁请求的信息。