# 执行流程

一条 SQL 究竟是如何执行的，这是我们需要了解的。

### 体系结构 

总体上，我们可以把 MySQL 数据库分成三层，跟客户端对接的是连接层，真正执行操作的是服务（Server）层，和跟硬件打交道的存储引擎层。

<div align="left">
    <img src="https://github.com/lazecoding/Note/blob/main/images/mysql/体系结构.png" width="600px">
</div>

客户端要连接到 MySQL 服务器 3306 端口（默认端口），必须要跟服务端建立连接，管理所有的连接，验证客户端的身份和权限，这些功能就在连接层完成。

连接层会把 SQL 语句交给服务层，这里面又包含一系列的流程，包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。

存储引擎就是我们的数据真正存放的地方，MySQL 数据库支持插件式存储引擎，直接与内存、磁盘交互。

#### 连接器

第一步，客户端会先连接到 MySQL 服务器上，连接器就是负责跟客户端建立连接、获取权限、维持和管理连接的模块。连接命令如下：

```sql
mysql -h $ip -P $port -u $user -p
```

在完成经典的 TCP 握手后，连接器就要开始身份认证，如果用户名或密码不对，客户端就会收到一个 "Access denied for user" 的错误，然后客户端程序结束执行。

如果用户名密码认证通过，连接器会到权限表里面查出用户名拥有的权限。之后，这个连接执行命令的权限判断逻辑都将依赖于此时读到的权限。这就意味着，一个用户成功建立连接后，即使你用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。

#### 查询缓存

MySQL 内部自带了一个缓存模块，把数据以键值对的形式放到内存里面，加快数据读取，缩短服务器处理时间。但是这个功能很鸡肋：一方面它要求 SQL 语句必须一模一样，大小写、空格都不允许有出入；另一方面表里面任何一条数据发生变化，这张表所有缓存都会失效。

在 MySQL 8.0 中，查询缓存已被移除。

#### 分析器

如果查询缓存没有开启或没有命中，下面就要为执行语句做准备了。首先 MySQL 服务器需要分析语句：分为词法分析和语法分析。

分析器先会进行词法分析。它会识别出语句中每个字符串分别代表什么，如分析出关键字、列名、表名等。

完成词法分析，就要进行语法分析。语法分析会对 SQL 语句做一些语法检查，比如单引号有没有闭合，然后根据 MySQL 定义的语法规则，生成一个语法解析树。

分析器中还包含一个预处理器，它会检查生成的语法解析树，解决解析器无法解析的语义。比如，它会检查表和列名是否存在，检查名字和别名，保证没有歧义。预处理之后会得到一个新的语法解析树。

#### 优化器

得到解析树之后，并不会直接执行 SQL 语句，还会经过优化器的处理。

优化器的目的就是根据语法解析树生成不同的执行计划（Execution Plan），然后选择一种最优的执行计划，MySQL 里面使用的是基于开销（cost）的优化器，执行开销最小的执行计划。

优化器能处理的优化类型：
- 当我们对多张表进行关联查询的时候，以哪个表的数据作为基准表。
- 有多个索引可以使用的时候，选择哪个索引。
- ...

####  执行器

MySQL 通过分析器知道了做什么，通过优化器知道了怎么做，下面就进入了执行阶段。

开始执行的时候，会先判断一下该连接对这个表有没有对应权限，如果没有，就会返回没有权限的错误，如果有权限，就打开表继续执行。这时候就要涉及一个问题，数据是如何存储的。MySQL 采用的是插件式存储引擎，执行器对表的操作都是通过存储引擎提供的接口实现的，并负责接收并返回执行引擎接口的返回值。

### 执行流程

所有的 SQL 语句都需要经过分析器、优化器和执行器处理，下面以 InnoDB 存储引擎为了解描述 SQL 语句执行流程。

#### SELECT

- 执行器调用存储引擎，首先会去 innodb_buffer_pool 里的 data dictionary（元数据信息）得到表信息，并通过元数据信息,去 lock info 里查出是否会有相关的锁信息，并把这条 SELECT 语句需要的锁信息写入到 lock info。
- 执行器再调用执行引擎获取对应的行记录：如果数据页在内存中直接返回，如果不在的话执行引擎先从磁盘中读取数据返回给执行器。
- InnoDB 存储引擎中，数据是索引组织的 B+ 树,非叶子节点放 key，叶子节点放 value。每一次读取数据并不是只读取单独一行数据，而是读取了整个叶子节点存放在 Buffer Pool。

#### INSERT

- 执行器调用存储引擎，首先会去 innodb_buffer_pool 里的 data dictionary（元数据信息）得到表信息，并通过元数据信息,去 lock info 里查出是否会有相关的锁信息，并把这条 INSERT 语句需要的锁信息写入到 lock info。
- 执行器再调用执行引擎写入这行数据。存储引擎将这个数据更新到缓冲池（Buffer Pool）中，并写入 redo log redo log buffer，接着修改辅助索引，InnoDB 1.0.x 版本引入了 Change Buffer，用于缓存 DML 操作对普通索引页的修改，在以一定频率将 Change Buffer 和辅助索引页合并，这样避免了每次操作都产生随机读取页。
- 此时 INSERT 语句已经完成，需要 commit 或者 rollback。
- commit 操作会做下面三件事情：将 redo log buffer 中的数据刷入到 redo log 文件中；将本次操作记录写入到 bin log文件中；将 bin log 文件名字和更新内容在 bin log 中的位置记录到redo log中，同时在 redo log 最后添加 commit 标记。此外，如果开启了缓存还会清除该表的缓存。

#### UPDATE

- 执行器调用存储引擎，首先会去 innodb_buffer_pool 里的 data dictionary（元数据信息）得到表信息，并通过元数据信息,去 lock info 里查出是否会有相关的锁信息，并把这条 UPDATE 语句需要的锁信息写入到 lock info。
- 执行器再调用执行引擎获取对应的行记录：如果数据页在内存中直接返回，如果不在的话执行引擎先从磁盘中读取数据返回给执行器。
- 执行器拿到存储引擎的值后进行修改得到一行数据，再调用存储引擎写入这行数据。存储引擎将这个数据更新到缓冲池（Buffer Pool）中，并写入 redo log redo log buffer,同时会将旧数据写入 undo log，接着修改辅助索引。
- 此时 UPDATE 语句已经完成，需要 commit 或者 rollback。
- commit 操作会做下面三件事情：将 redo log buffer 中的数据刷入到 redo log 文件中；将本次操作记录写入到 bin log文件中；将 bin log 文件名字和更新内容在 bin log 中的位置记录到redo log中，同时在 redo log 最后添加 commit 标记。此外，如果开启了缓存还会清除该表的缓存。

#### DELETE
- 执行器调用存储引擎，首先会去 innodb_buffer_pool 里的 data dictionary（元数据信息）得到表信息，并通过元数据信息,去 lock info 里查出是否会有相关的锁信息，并把这条 DELETE 语句需要的锁信息写入到 lock info。
- 执行器调用存储引擎删除这行数据。存储引擎将这个数据更新到缓冲池（Buffer Pool）中，并写入 redo log redo log buffer,同时会将旧数据写入 undo log，接着修改辅助索引。
- 此时 DELETE 语句已经完成，需要 commit 或者 rollback。
- commit 操作会做下面三件事情：将 redo log buffer 中的数据刷入到 redo log 文件中；将本次操作记录写入到 bin log文件中；将 bin log 文件名字和更新内容在 bin log 中的位置记录到redo log中，同时在 redo log 最后添加 commit 标记。此外，如果开启了缓存还会清除该表的缓存。

注意：在 InnoDB 存储引擎中 DELETE 操作并不会立即把数据删除，实际上只是给删除的数据打了个删除标记，因此表文件在磁盘上所占空间不会变小。

### 执行顺序

1、`FROM` table1 left join table2 on 将table1和table2中的数据产生笛卡尔积，生成Temp1；

2、`JOIN` table2 所以先是确定表，再确定关联条件；

3、`ON` table1.column = table2.column 确定表的绑定条件 由Temp1产生中间表Temp2；

4、`WHERE` 对中间表Temp2产生的结果进行过滤 产生中间表Temp3；

5、`GROUP BY` 对中间表Temp3进行分组，产生中间表Temp4；

6、`HAVING` 对分组后的记录进行聚合 产生中间表Temp5；

7、`SELECT` 对中间表Temp5进行列筛选，产生中间表 Temp6；

8、`DISTINCT` 对中间表 Temp6进行去重，产生中间表 Temp7；

9、`ORDER BY` 对Temp7中的数据进行排序，产生中间表Temp8；

10、`LIMIT` 对中间表Temp8进行分页，产生中间表Temp9；